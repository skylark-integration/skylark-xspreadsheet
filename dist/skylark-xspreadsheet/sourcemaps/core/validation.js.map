{"version":3,"sources":["core/validation.js"],"names":["define","Validator","m_cell_range","Validation","[object Object]","mode","refs","validator","this","ri","ci","i","length","CellRange","valueOf","includes","ref","remove","push","cellRange","nrefs","forEach","it","cr","intersects","difference","it1","toString","type","required","operator","value","Validations","_","errors","Map","get","text","v","key","flag","message","validate","delete","set","getByValidator","addRef","equals","each","cb","filter","map","getData","d"],"mappings":";;;;;;;AAAAA,QACI,cACA,gBACD,SAAUC,EAAWC,GACpB,mBACMC,EACFC,YAAYC,EAAMC,EAAMC,GACpBC,KAAKF,KAAOA,EACZE,KAAKH,KAAOA,EACZG,KAAKD,UAAYA,EAErBH,SAASK,EAAIC,GACT,MAAMJ,KAACA,GAAQE,KACf,IAAK,IAAIG,EAAI,EAAGA,EAAIL,EAAKM,OAAQD,GAAK,EAAG,CAErC,GADWT,EAAaW,UAAUC,QAAQR,EAAKK,IACxCI,SAASN,EAAIC,GAChB,OAAO,EAEf,OAAO,EAEXN,OAAOY,GACHR,KAAKS,OAAOf,EAAaW,UAAUC,QAAQE,IAC3CR,KAAKF,KAAKY,KAAKF,GAEnBZ,OAAOe,GACH,MAAMC,KACNZ,KAAKF,KAAKe,QAAQC,IACd,MAAMC,EAAKrB,EAAaW,UAAUC,QAAQQ,GAC1C,GAAIC,EAAGC,WAAWL,GAAY,CACdI,EAAGE,WAAWN,GACtBE,QAAQK,GAAON,EAAMF,KAAKQ,EAAIC,kBAElCP,EAAMF,KAAKI,KAGnBd,KAAKF,KAAOc,EAEhBhB,UACI,MAAME,KAACA,EAAID,KAAEA,EAAIE,UAAEA,GAAaC,MAC1BoB,KAACA,EAAIC,SAAEA,EAAQC,SAAEA,EAAQC,MAAEA,GAASxB,EAC1C,OACID,KAAAA,EACAD,KAAAA,EACAuB,KAAAA,EACAC,SAAAA,EACAC,SAAAA,EACAC,MAAAA,GAGR3B,gBAAeE,KAACA,EAAID,KAAEA,EAAIuB,KAAEA,EAAIC,SAAEA,EAAQC,SAAEA,EAAQC,MAAEA,IAClD,OAAO,IAAI5B,EAAWE,EAAMC,EAAM,IAAIL,EAAU2B,EAAMC,EAAUE,EAAOD,KAoE/E,OACIE,kBAjEA5B,cACII,KAAKyB,KACLzB,KAAK0B,OAAS,IAAIC,IAEtB/B,SAASK,EAAIC,GACT,OAAOF,KAAK0B,OAAOE,OAAQ3B,KAAQC,KAEvCN,SAASK,EAAIC,EAAI2B,GACb,MAAMC,EAAI9B,KAAK4B,IAAI3B,EAAIC,GACjB6B,KAAU9B,KAAQC,KAClBwB,OAACA,GAAU1B,KACjB,GAAU,OAAN8B,EAAY,CACZ,MAAOE,EAAMC,GAAWH,EAAE/B,UAAUmC,SAASL,GACxCG,EAGDN,EAAOS,OAAOJ,GAFdL,EAAOU,IAAIL,EAAKE,QAKpBP,EAAOS,OAAOJ,GAElB,OAAO,EAEXnC,IAAIC,EAAMW,GAAKY,KAACA,EAAIC,SAAEA,EAAQE,MAAEA,EAAKD,SAAEA,IACnC,MAAMvB,EAAY,IAAIN,EAAU2B,EAAMC,EAAUE,EAAOD,GACjDQ,EAAI9B,KAAKqC,eAAetC,GACpB,OAAN+B,EACAA,EAAEQ,OAAO9B,GAETR,KAAKyB,EAAEf,KAAK,IAAIf,EAAWE,GAAOW,GAAMT,IAGhDH,eAAeG,GACX,IAAK,IAAII,EAAI,EAAGA,EAAIH,KAAKyB,EAAErB,OAAQD,GAAK,EAAG,CACvC,MAAM2B,EAAI9B,KAAKyB,EAAEtB,GACjB,GAAI2B,EAAE/B,UAAUwC,OAAOxC,GACnB,OAAO+B,EAGf,OAAO,KAEXlC,IAAIK,EAAIC,GACJ,IAAK,IAAIC,EAAI,EAAGA,EAAIH,KAAKyB,EAAErB,OAAQD,GAAK,EAAG,CACvC,MAAM2B,EAAI9B,KAAKyB,EAAEtB,GACjB,GAAI2B,EAAEvB,SAASN,EAAIC,GACf,OAAO4B,EAEf,OAAO,KAEXlC,OAAOe,GACHX,KAAKwC,KAAK1B,IACNA,EAAGL,OAAOE,KAGlBf,KAAK6C,GACDzC,KAAKyB,EAAEZ,QAAQC,GAAM2B,EAAG3B,IAE5BlB,UACI,OAAOI,KAAKyB,EAAEiB,OAAO5B,GAAMA,EAAGhB,KAAKM,OAAS,GAAGuC,IAAI7B,GAAMA,EAAG8B,WAEhEhD,QAAQiD,GACJ7C,KAAKyB,EAAIoB,EAAEF,IAAI7B,GAAMnB,EAAWW,QAAQQ","file":"../../core/validation.js","sourcesContent":["define([\n    './validator',\n    './cell_range'\n], function (Validator, m_cell_range) {\n    'use strict';\n    class Validation {\n        constructor(mode, refs, validator) {\n            this.refs = refs;\n            this.mode = mode;\n            this.validator = validator;\n        }\n        includes(ri, ci) {\n            const {refs} = this;\n            for (let i = 0; i < refs.length; i += 1) {\n                const cr = m_cell_range.CellRange.valueOf(refs[i]);\n                if (cr.includes(ri, ci))\n                    return true;\n            }\n            return false;\n        }\n        addRef(ref) {\n            this.remove(m_cell_range.CellRange.valueOf(ref));\n            this.refs.push(ref);\n        }\n        remove(cellRange) {\n            const nrefs = [];\n            this.refs.forEach(it => {\n                const cr = m_cell_range.CellRange.valueOf(it);\n                if (cr.intersects(cellRange)) {\n                    const crs = cr.difference(cellRange);\n                    crs.forEach(it1 => nrefs.push(it1.toString()));\n                } else {\n                    nrefs.push(it);\n                }\n            });\n            this.refs = nrefs;\n        }\n        getData() {\n            const {refs, mode, validator} = this;\n            const {type, required, operator, value} = validator;\n            return {\n                refs,\n                mode,\n                type,\n                required,\n                operator,\n                value\n            };\n        }\n        static valueOf({refs, mode, type, required, operator, value}) {\n            return new Validation(mode, refs, new Validator(type, required, value, operator));\n        }\n    }\n    class Validations {\n        constructor() {\n            this._ = [];\n            this.errors = new Map();\n        }\n        getError(ri, ci) {\n            return this.errors.get(`${ ri }_${ ci }`);\n        }\n        validate(ri, ci, text) {\n            const v = this.get(ri, ci);\n            const key = `${ ri }_${ ci }`;\n            const {errors} = this;\n            if (v !== null) {\n                const [flag, message] = v.validator.validate(text);\n                if (!flag) {\n                    errors.set(key, message);\n                } else {\n                    errors.delete(key);\n                }\n            } else {\n                errors.delete(key);\n            }\n            return true;\n        }\n        add(mode, ref, {type, required, value, operator}) {\n            const validator = new Validator(type, required, value, operator);\n            const v = this.getByValidator(validator);\n            if (v !== null) {\n                v.addRef(ref);\n            } else {\n                this._.push(new Validation(mode, [ref], validator));\n            }\n        }\n        getByValidator(validator) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const v = this._[i];\n                if (v.validator.equals(validator)) {\n                    return v;\n                }\n            }\n            return null;\n        }\n        get(ri, ci) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const v = this._[i];\n                if (v.includes(ri, ci))\n                    return v;\n            }\n            return null;\n        }\n        remove(cellRange) {\n            this.each(it => {\n                it.remove(cellRange);\n            });\n        }\n        each(cb) {\n            this._.forEach(it => cb(it));\n        }\n        getData() {\n            return this._.filter(it => it.refs.length > 0).map(it => it.getData());\n        }\n        setData(d) {\n            this._ = d.map(it => Validation.valueOf(it));\n        }\n    }\n    return {\n        Validations\n    };\n});"]}