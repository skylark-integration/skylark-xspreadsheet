{"version":3,"sources":["core/validator.js"],"names":["define","m_locale","helper","rules","phone","email","returnMessage","flag","key","arg","message","t","[object Object]","type","required","value","operator","this","v","Date","Number","other","Array","isArray","arrayEquals","split","test","values","includes","v1","parseValue","min","max"],"mappings":";;;;;;;AAAAA,QACI,mBACA,YACD,SAAUC,EAAUC,GACnB,aACA,MAAMC,GACFC,MAAO,gBACPC,MAAO,wCAEX,SAASC,EAAcC,EAAMC,KAAQC,GACjC,IAAIC,EAAU,GAId,OAHKH,IACDG,EAAUT,EAASU,gBAAiBH,OAAWC,KAG/CF,EACAG,GAiFR,aA7EIE,YAAYC,EAAMC,EAAUC,EAAOC,GAC/BC,KAAKH,SAAWA,EAChBG,KAAKF,MAAQA,EACbE,KAAKJ,KAAOA,EACZI,KAAKD,SAAWA,EAChBC,KAAKP,QAAU,GAEnBE,WAAWM,GACP,MAAML,KAACA,GAAQI,KACf,MAAa,SAATJ,EACO,IAAIM,KAAKD,GAEP,WAATL,EACOO,OAAOF,GAEXA,EAEXN,OAAOS,GACH,IAAId,EAAOU,KAAKJ,OAASQ,EAAMR,MAAQI,KAAKH,WAAaO,EAAMP,UAAYG,KAAKD,WAAaK,EAAML,SAQnG,OAPIT,IAEIA,EADAe,MAAMC,QAAQN,KAAKF,OACZb,EAAOsB,YAAYP,KAAKF,MAAOM,EAAMN,OAErCE,KAAKF,QAAUM,EAAMN,OAG7BR,EAEXK,SACI,OAAOK,KAAKF,MAAMU,MAAM,KAE5Bb,SAASM,GACL,MAAMJ,SAACA,EAAQE,SAAEA,EAAQD,MAAEA,EAAKF,KAAEA,GAAQI,KAC1C,GAAIH,GAAY,QAAQY,KAAKR,GACzB,OAAOZ,GAAc,EAAO,YAEhC,GAAI,QAAQoB,KAAKR,GACb,QAAQ,GACZ,GAAIf,EAAMU,KAAUV,EAAMU,GAAMa,KAAKR,GACjC,OAAOZ,GAAc,EAAO,YAEhC,GAAa,SAATO,EACA,OAAOP,EAAcW,KAAKU,SAASC,SAASV,GAAI,SAEpD,GAAIF,EAAU,CACV,MAAMa,EAAKZ,KAAKa,WAAWZ,GAC3B,GAAiB,OAAbF,EAAmB,CACnB,MAAOe,EAAKC,GAAOjB,EACnB,OAAOT,EAAcuB,GAAMZ,KAAKa,WAAWC,IAAQF,GAAMZ,KAAKa,WAAWE,GAAM,UAAWD,EAAKC,GAEnG,GAAiB,QAAbhB,EAAoB,CACpB,MAAOe,EAAKC,GAAOjB,EACnB,OAAOT,EAAcuB,EAAKZ,KAAKa,WAAWC,IAAQF,EAAKZ,KAAKa,WAAWE,GAAM,aAAcD,EAAKC,GAEpG,GAAiB,OAAbhB,EACA,OAAOV,EAAcuB,IAAOZ,KAAKa,WAAWf,GAAQ,QAASA,GAEjE,GAAiB,QAAbC,EACA,OAAOV,EAAcuB,IAAOZ,KAAKa,WAAWf,GAAQ,WAAYA,GAEpE,GAAiB,OAAbC,EACA,OAAOV,EAAcuB,EAAKZ,KAAKa,WAAWf,GAAQ,WAAYA,GAElE,GAAiB,QAAbC,EACA,OAAOV,EAAcuB,GAAMZ,KAAKa,WAAWf,GAAQ,gBAAiBA,GAExE,GAAiB,OAAbC,EACA,OAAOV,EAAcuB,EAAKZ,KAAKa,WAAWf,GAAQ,cAAeA,GAErE,GAAiB,QAAbC,EACA,OAAOV,EAAcuB,GAAMZ,KAAKa,WAAWf,GAAQ,mBAAoBA,GAG/E,QAAQ","file":"../../core/validator.js","sourcesContent":["define([\n    '../locale/locale',\n    './helper'\n], function (m_locale, helper) {\n    'use strict';\n    const rules = {\n        phone: /^[1-9]\\d{10}$/,\n        email: /w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*/\n    };\n    function returnMessage(flag, key, ...arg) {\n        let message = '';\n        if (!flag) {\n            message = m_locale.t(`validation.${ key }`, ...arg);\n        }\n        return [\n            flag,\n            message\n        ];\n    }\n    class Validator {\n        constructor(type, required, value, operator) {\n            this.required = required;\n            this.value = value;\n            this.type = type;\n            this.operator = operator;\n            this.message = '';\n        }\n        parseValue(v) {\n            const {type} = this;\n            if (type === 'date') {\n                return new Date(v);\n            }\n            if (type === 'number') {\n                return Number(v);\n            }\n            return v;\n        }\n        equals(other) {\n            let flag = this.type === other.type && this.required === other.required && this.operator === other.operator;\n            if (flag) {\n                if (Array.isArray(this.value)) {\n                    flag = helper.arrayEquals(this.value, other.value);\n                } else {\n                    flag = this.value === other.value;\n                }\n            }\n            return flag;\n        }\n        values() {\n            return this.value.split(',');\n        }\n        validate(v) {\n            const {required, operator, value, type} = this;\n            if (required && /^\\s*$/.test(v)) {\n                return returnMessage(false, 'required');\n            }\n            if (/^\\s*$/.test(v))\n                return [true];\n            if (rules[type] && !rules[type].test(v)) {\n                return returnMessage(false, 'notMatch');\n            }\n            if (type === 'list') {\n                return returnMessage(this.values().includes(v), 'notIn');\n            }\n            if (operator) {\n                const v1 = this.parseValue(v);\n                if (operator === 'be') {\n                    const [min, max] = value;\n                    return returnMessage(v1 >= this.parseValue(min) && v1 <= this.parseValue(max), 'between', min, max);\n                }\n                if (operator === 'nbe') {\n                    const [min, max] = value;\n                    return returnMessage(v1 < this.parseValue(min) || v1 > this.parseValue(max), 'notBetween', min, max);\n                }\n                if (operator === 'eq') {\n                    return returnMessage(v1 === this.parseValue(value), 'equal', value);\n                }\n                if (operator === 'neq') {\n                    return returnMessage(v1 !== this.parseValue(value), 'notEqual', value);\n                }\n                if (operator === 'lt') {\n                    return returnMessage(v1 < this.parseValue(value), 'lessThan', value);\n                }\n                if (operator === 'lte') {\n                    return returnMessage(v1 <= this.parseValue(value), 'lessThanEqual', value);\n                }\n                if (operator === 'gt') {\n                    return returnMessage(v1 > this.parseValue(value), 'greaterThan', value);\n                }\n                if (operator === 'gte') {\n                    return returnMessage(v1 >= this.parseValue(value), 'greaterThanEqual', value);\n                }\n            }\n            return [true];\n        }\n    };\n\n    return Validator;\n});"]}