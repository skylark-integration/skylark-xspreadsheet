{"version":3,"sources":["core/merge.js"],"names":["define","m_cell_range","Merges","[object Object]","d","this","_","cb","forEach","cr","filter","it","within","ri","ci","i","length","includes","cellRange","intersects","union","deleteWithin","push","type","index","n","cbWithin","sri","sci","eri","eci","range","rn","cn","it1","merges","map","merge","CellRange","valueOf","toString"],"mappings":";;;;;;;AAAAA,QAAQ,gBAAiB,SAAUC,GAC/B,mBACMC,EACFC,YAAYC,MACRC,KAAKC,EAAIF,EAEbD,QAAQI,GACJF,KAAKC,EAAEE,QAAQD,GAEnBJ,aAAaM,GACTJ,KAAKC,EAAID,KAAKC,EAAEI,OAAOC,IAAOA,EAAGC,OAAOH,IAE5CN,iBAAiBU,EAAIC,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIV,KAAKC,EAAEU,OAAQD,GAAK,EAAG,CACvC,MAAMJ,EAAKN,KAAKC,EAAES,GAClB,GAAIJ,EAAGM,SAASJ,EAAIC,GAChB,OAAOH,EAGf,OAAO,KAEXR,iBAAiBe,GACb,OAAO,IAAIhB,EAAOG,KAAKC,EAAEI,OAAOC,GAAMA,EAAGQ,WAAWD,KAExDf,WAAWe,GACP,IAAK,IAAIH,EAAI,EAAGA,EAAIV,KAAKC,EAAEU,OAAQD,GAAK,EAAG,CAEvC,GADWV,KAAKC,EAAES,GACXI,WAAWD,GACd,OAAO,EAGf,OAAO,EAEXf,MAAMe,GACF,IAAIT,EAAKS,EAMT,OALAb,KAAKC,EAAEE,QAAQG,IACPA,EAAGQ,WAAWV,KACdA,EAAKE,EAAGS,MAAMX,MAGfA,EAEXN,IAAIM,GACAJ,KAAKgB,aAAaZ,GAClBJ,KAAKC,EAAEgB,KAAKb,GAEhBN,MAAMoB,EAAMC,EAAOC,EAAGC,GAClBrB,KAAKC,EAAEE,QAAQU,IACX,MAAMS,IAACA,EAAGC,IAAEA,EAAGC,IAAEA,EAAGC,IAAEA,GAAOZ,EACvBa,EAAQb,EACD,QAATK,EACII,GAAOH,GACPO,EAAMJ,KAAOF,EACbM,EAAMF,KAAOJ,GACNE,EAAMH,GAASA,GAASK,IAC/BE,EAAMF,KAAOJ,EACbC,EAASC,EAAKC,EAAKH,EAAG,IAEV,WAATF,IACHK,GAAOJ,GACPO,EAAMH,KAAOH,EACbM,EAAMD,KAAOL,GACNG,EAAMJ,GAASA,GAASM,IAC/BC,EAAMD,KAAOL,EACbC,EAASC,EAAKC,EAAK,EAAGH,OAKtCtB,KAAKe,EAAWc,EAAIC,GAChB5B,KAAKC,EAAEE,QAAQ0B,IACX,MAAMvB,EAAKuB,EACPvB,EAAGC,OAAOM,KACVP,EAAGkB,KAAOG,EACVrB,EAAGgB,KAAOK,EACVrB,EAAGiB,KAAOK,EACVtB,EAAGmB,KAAOG,KAItB9B,QAAQgC,GAEJ,OADA9B,KAAKC,EAAI6B,EAAOC,IAAIC,GAASpC,EAAaqC,UAAUC,QAAQF,IACrDhC,KAEXF,UACI,OAAOE,KAAKC,EAAE8B,IAAIC,GAASA,EAAMG,aAGzC,OACItC,OAAAA","file":"../../core/merge.js","sourcesContent":["define(['./cell_range'], function (m_cell_range) {\n    'use strict';\n    class Merges {\n        constructor(d = []) {\n            this._ = d;\n        }\n        forEach(cb) {\n            this._.forEach(cb);\n        }\n        deleteWithin(cr) {\n            this._ = this._.filter(it => !it.within(cr));\n        }\n        getFirstIncludes(ri, ci) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const it = this._[i];\n                if (it.includes(ri, ci)) {\n                    return it;\n                }\n            }\n            return null;\n        }\n        filterIntersects(cellRange) {\n            return new Merges(this._.filter(it => it.intersects(cellRange)));\n        }\n        intersects(cellRange) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const it = this._[i];\n                if (it.intersects(cellRange)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        union(cellRange) {\n            let cr = cellRange;\n            this._.forEach(it => {\n                if (it.intersects(cr)) {\n                    cr = it.union(cr);\n                }\n            });\n            return cr;\n        }\n        add(cr) {\n            this.deleteWithin(cr);\n            this._.push(cr);\n        }\n        shift(type, index, n, cbWithin) {\n            this._.forEach(cellRange => {\n                const {sri, sci, eri, eci} = cellRange;\n                const range = cellRange;\n                if (type === 'row') {\n                    if (sri >= index) {\n                        range.sri += n;\n                        range.eri += n;\n                    } else if (sri < index && index <= eri) {\n                        range.eri += n;\n                        cbWithin(sri, sci, n, 0);\n                    }\n                } else if (type === 'column') {\n                    if (sci >= index) {\n                        range.sci += n;\n                        range.eci += n;\n                    } else if (sci < index && index <= eci) {\n                        range.eci += n;\n                        cbWithin(sri, sci, 0, n);\n                    }\n                }\n            });\n        }\n        move(cellRange, rn, cn) {\n            this._.forEach(it1 => {\n                const it = it1;\n                if (it.within(cellRange)) {\n                    it.eri += rn;\n                    it.sri += rn;\n                    it.sci += cn;\n                    it.eci += cn;\n                }\n            });\n        }\n        setData(merges) {\n            this._ = merges.map(merge => m_cell_range.CellRange.valueOf(merge));\n            return this;\n        }\n        getData() {\n            return this._.map(merge => merge.toString());\n        }\n    }\n    return {\n        Merges\n    };\n});"]}