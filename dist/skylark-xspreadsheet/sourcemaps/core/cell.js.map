{"version":3,"sources":["core/cell.js"],"names":["define","m_alphabet","m_helper","infixExprToSuffixExpr","src","operatorStack","stack","subStrs","fnArgType","fnArgOperator","fnArgsLen","oldc","i","length","c","charAt","push","toUpperCase","join","test","c1","pop","ex","ey","expr2xy","sx","sy","rangelen","x","y","xy2expr","e","nc","top","evalSubExpr","subExpr","cellRender","fl","expr","substring","ret","Number","formulaMap","getCellText","cellList","srcStack","fc","numberCalc","isNaN","left","Array","isArray","formula","len","params","j","render","reverse","includes","evalSuffixExpr"],"mappings":"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","file":"../../core/cell.js","sourcesContent":["define([\n    './alphabet',\n    './helper'\n], function (m_alphabet, m_helper) {\n    'use strict';\n\n// Converting infix expression to a suffix expression\n// src: AVERAGE(SUM(A1,A2), B1) + 50 + B20\n// return: [A1, A2], SUM[, B1],AVERAGE,50,+,B20,+\n\n    const infixExprToSuffixExpr = src => {\n        const operatorStack = [];\n        const stack = [];\n        let subStrs = [];\n        let fnArgType = 0;\n        let fnArgOperator = '';\n        let fnArgsLen = 1;\n        let oldc = '';\n        for (let i = 0; i < src.length; i += 1) {\n            const c = src.charAt(i);\n            if (c !== ' ') {\n                if (c >= 'a' && c <= 'z') {\n                    subStrs.push(c.toUpperCase());\n                } else if (c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c === '.') {\n                    subStrs.push(c);\n                } else if (c === '\"') {\n                    i += 1;\n                    while (src.charAt(i) !== '\"') {\n                        subStrs.push(src.charAt(i));\n                        i += 1;\n                    }\n                    stack.push(`\"${ subStrs.join('') }`);\n                    subStrs = [];\n                } else if (c === '-' && /[+\\-*/,(]/.test(oldc)) {\n                    subStrs.push(c);\n                } else {\n                    if (c !== '(' && subStrs.length > 0) {\n                        stack.push(subStrs.join(''));\n                    }\n                    if (c === ')') {\n                        let c1 = operatorStack.pop();\n                        if (fnArgType === 2) {\n                            try {\n                                const [ex, ey] = m_alphabet.expr2xy(stack.pop());\n                                const [sx, sy] = m_alphabet.expr2xy(stack.pop());\n                                let rangelen = 0;\n                                for (let x = sx; x <= ex; x += 1) {\n                                    for (let y = sy; y <= ey; y += 1) {\n                                        stack.push(m_alphabet.xy2expr(x, y));\n                                        rangelen += 1;\n                                    }\n                                }\n                                stack.push([\n                                    c1,\n                                    rangelen\n                                ]);\n                            } catch (e) {\n                            }\n                        } else if (fnArgType === 1 || fnArgType === 3) {\n                            if (fnArgType === 3)\n                                stack.push(fnArgOperator);\n                            stack.push([\n                                c1,\n                                fnArgsLen\n                            ]);\n                            fnArgsLen = 1;\n                        } else {\n                            while (c1 !== '(') {\n                                stack.push(c1);\n                                if (operatorStack.length <= 0)\n                                    break;\n                                c1 = operatorStack.pop();\n                            }\n                        }\n                        fnArgType = 0;\n                    } else if (c === '=' || c === '>' || c === '<') {\n                        const nc = src.charAt(i + 1);\n                        fnArgOperator = c;\n                        if (nc === '=' || nc === '-') {\n                            fnArgOperator += nc;\n                            i += 1;\n                        }\n                        fnArgType = 3;\n                    } else if (c === ':') {\n                        fnArgType = 2;\n                    } else if (c === ',') {\n                        if (fnArgType === 3) {\n                            stack.push(fnArgOperator);\n                        }\n                        fnArgType = 1;\n                        fnArgsLen += 1;\n                    } else if (c === '(' && subStrs.length > 0) {\n                        operatorStack.push(subStrs.join(''));\n                    } else {\n                        if (operatorStack.length > 0 && (c === '+' || c === '-')) {\n                            let top = operatorStack[operatorStack.length - 1];\n                            if (top !== '(')\n                                stack.push(operatorStack.pop());\n                            if (top === '*' || top === '/') {\n                                while (operatorStack.length > 0) {\n                                    top = operatorStack[operatorStack.length - 1];\n                                    if (top !== '(')\n                                        stack.push(operatorStack.pop());\n                                    else\n                                        break;\n                                }\n                            }\n                        } else if (operatorStack.length > 0) {\n                            const top = operatorStack[operatorStack.length - 1];\n                            if (top === '*' || top === '/')\n                                stack.push(operatorStack.pop());\n                        }\n                        operatorStack.push(c);\n                    }\n                    subStrs = [];\n                }\n                oldc = c;\n            }\n        }\n        if (subStrs.length > 0) {\n            stack.push(subStrs.join(''));\n        }\n        while (operatorStack.length > 0) {\n            stack.push(operatorStack.pop());\n        }\n        return stack;\n    };\n    const evalSubExpr = (subExpr, cellRender) => {\n        const [fl] = subExpr;\n        let expr = subExpr;\n        if (fl === '\"') {\n            return subExpr.substring(1);\n        }\n        let ret = 1;\n        if (fl === '-') {\n            expr = subExpr.substring(1);\n            ret = -1;\n        }\n        if (expr[0] >= '0' && expr[0] <= '9') {\n            return ret * Number(expr);\n        }\n        const [x, y] = m_alphabet.expr2xy(expr);\n        return ret * cellRender(x, y);\n    };\n\n// evaluate the suffix expression\n// srcStack: <= infixExprToSufixExpr\n// formulaMap: {'SUM': {}, ...}\n// cellRender: (x, y) => {}\n    const evalSuffixExpr = (srcStack, formulaMap, cellRender, cellList) => {\n        const stack = [];\n        for (let i = 0; i < srcStack.length; i += 1) {\n            const expr = srcStack[i];\n            const fc = expr[0];\n            if (expr === '+') {\n                const top = stack.pop();\n                stack.push(m_helper.numberCalc('+', stack.pop(), top));\n            } else if (expr === '-') {\n                if (stack.length === 1) {\n                    const top = stack.pop();\n                    stack.push(m_helper.numberCalc('*', top, -1));\n                } else {\n                    const top = stack.pop();\n                    stack.push(m_helper.numberCalc('-', stack.pop(), top));\n                }\n            } else if (expr === '*') {\n                stack.push(m_helper.numberCalc('*', stack.pop(), stack.pop()));\n            } else if (expr === '/') {\n                const top = stack.pop();\n                stack.push(m_helper.numberCalc('/', stack.pop(), top));\n            } else if (fc === '=' || fc === '>' || fc === '<') {\n                let top = stack.pop();\n                if (!Number.isNaN(top))\n                    top = Number(top);\n                let left = stack.pop();\n                if (!Number.isNaN(left))\n                    left = Number(left);\n                let ret = false;\n                if (fc === '=') {\n                    ret = left === top;\n                } else if (expr === '>') {\n                    ret = left > top;\n                } else if (expr === '>=') {\n                    ret = left >= top;\n                } else if (expr === '<') {\n                    ret = left < top;\n                } else if (expr === '<=') {\n                    ret = left <= top;\n                }\n                stack.push(ret);\n            } else if (Array.isArray(expr)) {\n                const [formula, len] = expr;\n                const params = [];\n                for (let j = 0; j < len; j += 1) {\n                    params.push(stack.pop());\n                }\n                stack.push(formulaMap[formula].render(params.reverse()));\n            } else {\n                if (cellList.includes(expr)) {\n                    return 0;\n                }\n                if (fc >= 'a' && fc <= 'z' || fc >= 'A' && fc <= 'Z') {\n                    cellList.push(expr);\n                }\n                stack.push(evalSubExpr(expr, cellRender));\n                cellList.pop();\n            }\n        }\n        return stack[0];\n    };\n    const cellRender = (src, formulaMap, getCellText, cellList = []) => {\n        if (src[0] === '=') {\n            const stack = infixExprToSuffixExpr(src.substring(1));\n            if (stack.length <= 0)\n                return src;\n            return evalSuffixExpr(stack, formulaMap, (x, y) => cellRender(getCellText(x, y), formulaMap, getCellText, cellList), cellList);\n        }\n        return src;\n    };\n\n    return {\n        render: cellRender ,\n        infixExprToSuffixExpr\n    };\n});"]}