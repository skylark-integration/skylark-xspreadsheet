{"version":3,"sources":["core/data_proxy.js"],"names":["define","Selector","Scroll","History","Clipboard","AutoFilter","m_merge","helper","m_row","m_col","m_validation","m_cell_range","m_alphabet","m_locale","defaultSettings","mode","view","height","document","documentElement","clientHeight","width","clientWidth","showGrid","showToolbar","showContextmenu","row","len","col","indexWidth","minWidth","style","bgcolor","align","valign","textwrap","strike","underline","color","font","name","size","bold","italic","format","canPaste","src","dst","error","merges","this","cellRange","clone","srn","scn","drn","dcn","eri","sri","eci","sci","intersects","t","copyPaste","srcCellRange","dstCellRange","what","autofill","rows","deleteCells","deleteWithin","ri","ci","cell","merge","rn","cn","add","CellRange","setStyleBorder","bss","styles","getCellOrNew","cstyle","undefined","cloneDeep","border","addStyle","[object Object]","settings","freeze","Merges","Rows","cols","Cols","validations","Validations","hyperlinks","comments","selector","scroll","history","clipboard","autoFilter","change","exceptRowSet","Set","sortedRowMap","Map","unsortedRowMap","ref","validator","changeData","range","remove","v","get","ret","toString","canUndo","canRedo","undo","getData","d","setData","redo","copy","cut","isClear","call","isCopy","isCut","cutPaste","move","clear","txt","lines","split","map","it","replace","length","paste","srcRange","cri","cci","nri","nci","union","getFirstIncludes","property","value","unmerge","multiple","isSignleSelected","each","getCell","ns","mergeIndexes","ii","mri","mci","push","forEach","splice","mrl","mcl","bottom","top","left","right","Object","keys","getCellMerge","i","text","xy2expr","nfont","assign","state","has","oldCell","oldText","setCellText","active","filter","getFilter","vIndex","findIndex","x","y","getSelectedRect","x1","y1","getRect","l","sumWidth","sumHeight","left0","top0","fsh","freezeTotalHeight","fsw","freezeTotalWidth","scrollOffsety","inits","frset","getHeight","scrollOffsetx","rangeReduceIf","getWidth","totalWidth","totalHeight","cellRect","setCell","deleteCell","order","operator","addFilter","setSort","resetAutoFilter","sort","rset","fset","filteredRows","r","c","fary","Array","from","oldAry","a","b","index","set","type","n","si","insert","insertColumn","shift","rsize","csize","delete","deleteColumn","cb","fci","fri","cellStyle","defaultStyle","getCellStyleOrDefault","validate","setHeight","setWidth","h","maxCell","w","exceptRowTH","viewHeight","j","viewWidth","viewRange","filterIntersects","rlen","clen","setHide","unhide","min","max","frary","offset","rowHeight","colWidth","nstyle","equals","expr2xy","autofilter"],"mappings":"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","file":"../../core/data_proxy.js","sourcesContent":["define([\n    './selector',\n    './scroll',\n    './history',\n    './clipboard',\n    './auto_filter',\n    './merge',\n    './helper',\n    './row',\n    './col',\n    './validation',\n    './cell_range',\n    './alphabet',\n    '../locale/locale'\n], function (\n    Selector, \n    Scroll, \n    History, \n    Clipboard, \n    AutoFilter, \n    m_merge, \n    helper, \n    m_row, \n    m_col, \n    m_validation, \n    m_cell_range, \n    m_alphabet, \n    m_locale\n) {\n    'use strict';\n    const defaultSettings = {\n        mode: 'edit',\n        view: {\n            height: () => document.documentElement.clientHeight,\n            width: () => document.documentElement.clientWidth\n        },\n        showGrid: true,\n        showToolbar: true,\n        showContextmenu: true,\n        row: {\n            len: 100,\n            height: 25\n        },\n        col: {\n            len: 26,\n            width: 100,\n            indexWidth: 60,\n            minWidth: 60\n        },\n        style: {\n            bgcolor: '#ffffff',\n            align: 'left',\n            valign: 'middle',\n            textwrap: false,\n            strike: false,\n            underline: false,\n            color: '#0a0a0a',\n            font: {\n                name: 'Arial',\n                size: 10,\n                bold: false,\n                italic: false\n            },\n            format: 'normal'\n        }\n    };\n    const toolbarHeight = 41;\n    const bottombarHeight = 41;\n    function canPaste(src, dst, error = () => {\n    }) {\n        const {merges} = this;\n        const cellRange = dst.clone();\n        const [srn, scn] = src.size();\n        const [drn, dcn] = dst.size();\n        if (srn > drn) {\n            cellRange.eri = dst.sri + srn - 1;\n        }\n        if (scn > dcn) {\n            cellRange.eci = dst.sci + scn - 1;\n        }\n        if (merges.intersects(cellRange)) {\n            error(m_locale.t('error.pasteForMergedCell'));\n            return false;\n        }\n        return true;\n    }\n    function copyPaste(srcCellRange, dstCellRange, what, autofill = false) {\n        const {rows, merges} = this;\n        if (what === 'all' || what === 'format') {\n            rows.deleteCells(dstCellRange, what);\n            merges.deleteWithin(dstCellRange);\n        }\n        rows.copyPaste(srcCellRange, dstCellRange, what, autofill, (ri, ci, cell) => {\n            if (cell && cell.merge) {\n                const [rn, cn] = cell.merge;\n                if (rn <= 0 && cn <= 0)\n                    return;\n                merges.add(new m_cell_range.CellRange(ri, ci, ri + rn, ci + cn));\n            }\n        });\n    }\n    function cutPaste(srcCellRange, dstCellRange) {\n        const {clipboard, rows, merges} = this;\n        rows.cutPaste(srcCellRange, dstCellRange);\n        merges.move(srcCellRange, dstCellRange.sri - srcCellRange.sri, dstCellRange.sci - srcCellRange.sci);\n        clipboard.clear();\n    }\n    function setStyleBorder(ri, ci, bss) {\n        const {styles, rows} = this;\n        const cell = rows.getCellOrNew(ri, ci);\n        let cstyle = {};\n        if (cell.style !== undefined) {\n            cstyle = helper.cloneDeep(styles[cell.style]);\n        }\n        cstyle = helper.merge(cstyle, { border: bss });\n        cell.style = this.addStyle(cstyle);\n    }\n    function setStyleBorders({mode, style, color}) {\n        const {styles, selector, rows} = this;\n        const {sri, sci, eri, eci} = selector.range;\n        const multiple = !this.isSignleSelected();\n        if (!multiple) {\n            if (mode === 'inside' || mode === 'horizontal' || mode === 'vertical') {\n                return;\n            }\n        }\n        if (mode === 'outside' && !multiple) {\n            setStyleBorder.call(this, sri, sci, {\n                top: [\n                    style,\n                    color\n                ],\n                bottom: [\n                    style,\n                    color\n                ],\n                left: [\n                    style,\n                    color\n                ],\n                right: [\n                    style,\n                    color\n                ]\n            });\n        } else if (mode === 'none') {\n            selector.range.each((ri, ci) => {\n                const cell = rows.getCell(ri, ci);\n                if (cell && cell.style !== undefined) {\n                    const ns = helper.cloneDeep(styles[cell.style]);\n                    delete ns.border;\n                    cell.style = this.addStyle(ns);\n                }\n            });\n        } else if (mode === 'all' || mode === 'inside' || mode === 'outside' || mode === 'horizontal' || mode === 'vertical') {\n            const merges = [];\n            for (let ri = sri; ri <= eri; ri += 1) {\n                for (let ci = sci; ci <= eci; ci += 1) {\n                    const mergeIndexes = [];\n                    for (let ii = 0; ii < merges.length; ii += 1) {\n                        const [mri, mci, rn, cn] = merges[ii];\n                        if (ri === mri + rn + 1)\n                            mergeIndexes.push(ii);\n                        if (mri <= ri && ri <= mri + rn) {\n                            if (ci === mci) {\n                                ci += cn + 1;\n                                break;\n                            }\n                        }\n                    }\n                    mergeIndexes.forEach(it => merges.splice(it, 1));\n                    if (ci > eci)\n                        break;\n                    const cell = rows.getCell(ri, ci);\n                    let [rn, cn] = [\n                        0,\n                        0\n                    ];\n                    if (cell && cell.merge) {\n                        [rn, cn] = cell.merge;\n                        merges.push([\n                            ri,\n                            ci,\n                            rn,\n                            cn\n                        ]);\n                    }\n                    const mrl = rn > 0 && ri + rn === eri;\n                    const mcl = cn > 0 && ci + cn === eci;\n                    let bss = {};\n                    if (mode === 'all') {\n                        bss = {\n                            bottom: [\n                                style,\n                                color\n                            ],\n                            top: [\n                                style,\n                                color\n                            ],\n                            left: [\n                                style,\n                                color\n                            ],\n                            right: [\n                                style,\n                                color\n                            ]\n                        };\n                    } else if (mode === 'inside') {\n                        if (!mcl && ci < eci)\n                            bss.right = [\n                                style,\n                                color\n                            ];\n                        if (!mrl && ri < eri)\n                            bss.bottom = [\n                                style,\n                                color\n                            ];\n                    } else if (mode === 'horizontal') {\n                        if (!mrl && ri < eri)\n                            bss.bottom = [\n                                style,\n                                color\n                            ];\n                    } else if (mode === 'vertical') {\n                        if (!mcl && ci < eci)\n                            bss.right = [\n                                style,\n                                color\n                            ];\n                    } else if (mode === 'outside' && multiple) {\n                        if (sri === ri)\n                            bss.top = [\n                                style,\n                                color\n                            ];\n                        if (mrl || eri === ri)\n                            bss.bottom = [\n                                style,\n                                color\n                            ];\n                        if (sci === ci)\n                            bss.left = [\n                                style,\n                                color\n                            ];\n                        if (mcl || eci === ci)\n                            bss.right = [\n                                style,\n                                color\n                            ];\n                    }\n                    if (Object.keys(bss).length > 0) {\n                        setStyleBorder.call(this, ri, ci, bss);\n                    }\n                    ci += cn;\n                }\n            }\n        } else if (mode === 'top' || mode === 'bottom') {\n            for (let ci = sci; ci <= eci; ci += 1) {\n                if (mode === 'top') {\n                    setStyleBorder.call(this, sri, ci, {\n                        top: [\n                            style,\n                            color\n                        ]\n                    });\n                    ci += rows.getCellMerge(sri, ci)[1];\n                }\n                if (mode === 'bottom') {\n                    setStyleBorder.call(this, eri, ci, {\n                        bottom: [\n                            style,\n                            color\n                        ]\n                    });\n                    ci += rows.getCellMerge(eri, ci)[1];\n                }\n            }\n        } else if (mode === 'left' || mode === 'right') {\n            for (let ri = sri; ri <= eri; ri += 1) {\n                if (mode === 'left') {\n                    setStyleBorder.call(this, ri, sci, {\n                        left: [\n                            style,\n                            color\n                        ]\n                    });\n                    ri += rows.getCellMerge(ri, sci)[0];\n                }\n                if (mode === 'right') {\n                    setStyleBorder.call(this, ri, eci, {\n                        right: [\n                            style,\n                            color\n                        ]\n                    });\n                    ri += rows.getCellMerge(ri, eci)[0];\n                }\n            }\n        }\n    }\n    function getCellRowByY(y, scrollOffsety) {\n        const {rows} = this;\n        const fsh = this.freezeTotalHeight();\n        let inits = rows.height;\n        if (fsh + rows.height < y)\n            inits -= scrollOffsety;\n        const frset = this.exceptRowSet;\n        let ri = 0;\n        let top = inits;\n        let {height} = rows;\n        for (; ri < rows.len; ri += 1) {\n            if (top > y)\n                break;\n            if (!frset.has(ri)) {\n                height = rows.getHeight(ri);\n                top += height;\n            }\n        }\n        top -= height;\n        if (top <= 0) {\n            return {\n                ri: -1,\n                top: 0,\n                height\n            };\n        }\n        return {\n            ri: ri - 1,\n            top,\n            height\n        };\n    }\n    function getCellColByX(x, scrollOffsetx) {\n        const {cols} = this;\n        const fsw = this.freezeTotalWidth();\n        let inits = cols.indexWidth;\n        if (fsw + cols.indexWidth < x)\n            inits -= scrollOffsetx;\n        const [ci, left, width] = helper.rangeReduceIf(0, cols.len, inits, cols.indexWidth, x, i => cols.getWidth(i));\n        if (left <= 0) {\n            return {\n                ci: -1,\n                left: 0,\n                width: cols.indexWidth\n            };\n        }\n        return {\n            ci: ci - 1,\n            left,\n            width\n        };\n    }\n    return class DataProxy {\n        constructor(name, settings) {\n            this.settings = helper.merge(defaultSettings, settings || {});\n            this.name = name || 'sheet';\n            this.freeze = [\n                0,\n                0\n            ];\n            this.styles = [];\n            this.merges = new m_merge.Merges();\n            this.rows = new m_row.Rows(this.settings.row);\n            this.cols = new m_col.Cols(this.settings.col);\n            this.validations = new m_validation.Validations();\n            this.hyperlinks = {};\n            this.comments = {};\n            this.selector = new Selector();\n            this.scroll = new Scroll();\n            this.history = new History();\n            this.clipboard = new Clipboard();\n            this.autoFilter = new AutoFilter();\n            this.change = () => {\n            };\n            this.exceptRowSet = new Set();\n            this.sortedRowMap = new Map();\n            this.unsortedRowMap = new Map();\n        }\n        addValidation(mode, ref, validator) {\n            this.changeData(() => {\n                this.validations.add(mode, ref, validator);\n            });\n        }\n        removeValidation() {\n            const {range} = this.selector;\n            this.changeData(() => {\n                this.validations.remove(range);\n            });\n        }\n        getSelectedValidator() {\n            const {ri, ci} = this.selector;\n            const v = this.validations.get(ri, ci);\n            return v ? v.validator : null;\n        }\n        getSelectedValidation() {\n            const {ri, ci, range} = this.selector;\n            const v = this.validations.get(ri, ci);\n            const ret = { ref: range.toString() };\n            if (v !== null) {\n                ret.mode = v.mode;\n                ret.validator = v.validator;\n            }\n            return ret;\n        }\n        canUndo() {\n            return this.history.canUndo();\n        }\n        canRedo() {\n            return this.history.canRedo();\n        }\n        undo() {\n            this.history.undo(this.getData(), d => {\n                this.setData(d);\n            });\n        }\n        redo() {\n            this.history.redo(this.getData(), d => {\n                this.setData(d);\n            });\n        }\n        copy() {\n            this.clipboard.copy(this.selector.range);\n        }\n        cut() {\n            this.clipboard.cut(this.selector.range);\n        }\n        paste(what = 'all', error = () => {\n        }) {\n            const {clipboard, selector} = this;\n            if (clipboard.isClear())\n                return false;\n            if (!canPaste.call(this, clipboard.range, selector.range, error))\n                return false;\n            this.changeData(() => {\n                if (clipboard.isCopy()) {\n                    copyPaste.call(this, clipboard.range, selector.range, what);\n                } else if (clipboard.isCut()) {\n                    cutPaste.call(this, clipboard.range, selector.range);\n                }\n            });\n            return true;\n        }\n        pasteFromText(txt) {\n            const lines = txt.split('\\r\\n').map(it => it.replace(/\"/g, '').split('\\t'));\n            if (lines.length > 0)\n                lines.length -= 1;\n            const {rows, selector} = this;\n            this.changeData(() => {\n                rows.paste(lines, selector.range);\n            });\n        }\n        autofill(cellRange, what, error = () => {\n        }) {\n            const srcRange = this.selector.range;\n            if (!canPaste.call(this, srcRange, cellRange, error))\n                return false;\n            this.changeData(() => {\n                copyPaste.call(this, srcRange, cellRange, what, true);\n            });\n            return true;\n        }\n        clearClipboard() {\n            this.clipboard.clear();\n        }\n        calSelectedRangeByEnd(ri, ci) {\n            const {selector, rows, cols, merges} = this;\n            let {sri, sci, eri, eci} = selector.range;\n            const cri = selector.ri;\n            const cci = selector.ci;\n            let [nri, nci] = [\n                ri,\n                ci\n            ];\n            if (ri < 0)\n                nri = rows.len - 1;\n            if (ci < 0)\n                nci = cols.len - 1;\n            if (nri > cri)\n                [sri, eri] = [\n                    cri,\n                    nri\n                ];\n            else\n                [sri, eri] = [\n                    nri,\n                    cri\n                ];\n            if (nci > cci)\n                [sci, eci] = [\n                    cci,\n                    nci\n                ];\n            else\n                [sci, eci] = [\n                    nci,\n                    cci\n                ];\n            selector.range = merges.union(new m_cell_range.CellRange(sri, sci, eri, eci));\n            selector.range = merges.union(selector.range);\n            return selector.range;\n        }\n        calSelectedRangeByStart(ri, ci) {\n            const {selector, rows, cols, merges} = this;\n            let cellRange = merges.getFirstIncludes(ri, ci);\n            if (cellRange === null) {\n                cellRange = new m_cell_range.CellRange(ri, ci, ri, ci);\n                if (ri === -1) {\n                    cellRange.sri = 0;\n                    cellRange.eri = rows.len - 1;\n                }\n                if (ci === -1) {\n                    cellRange.sci = 0;\n                    cellRange.eci = cols.len - 1;\n                }\n            }\n            selector.range = cellRange;\n            return cellRange;\n        }\n        setSelectedCellAttr(property, value) {\n            this.changeData(() => {\n                const {selector, styles, rows} = this;\n                if (property === 'merge') {\n                    if (value)\n                        this.merge();\n                    else\n                        this.unmerge();\n                } else if (property === 'border') {\n                    setStyleBorders.call(this, value);\n                } else if (property === 'formula') {\n                    const {ri, ci, range} = selector;\n                    if (selector.multiple()) {\n                        const [rn, cn] = selector.size();\n                        const {sri, sci, eri, eci} = range;\n                        if (rn > 1) {\n                            for (let i = sci; i <= eci; i += 1) {\n                                const cell = rows.getCellOrNew(eri + 1, i);\n                                cell.text = `=${ value }(${ m_alphabet.xy2expr(i, sri) }:${ m_alphabet.xy2expr(i, eri) })`;\n                            }\n                        } else if (cn > 1) {\n                            const cell = rows.getCellOrNew(ri, eci + 1);\n                            cell.text = `=${ value }(${ m_alphabet.xy2expr(sci, ri) }:${ m_alphabet.xy2expr(eci, ri) })`;\n                        }\n                    } else {\n                        const cell = rows.getCellOrNew(ri, ci);\n                        cell.text = `=${ value }()`;\n                    }\n                } else {\n                    selector.range.each((ri, ci) => {\n                        const cell = rows.getCellOrNew(ri, ci);\n                        let cstyle = {};\n                        if (cell.style !== undefined) {\n                            cstyle = helper.cloneDeep(styles[cell.style]);\n                        }\n                        if (property === 'format') {\n                            cstyle.format = value;\n                            cell.style = this.addStyle(cstyle);\n                        } else if (property === 'font-bold' || property === 'font-italic' || property === 'font-name' || property === 'font-size') {\n                            const nfont = {};\n                            nfont[property.split('-')[1]] = value;\n                            cstyle.font = Object.assign(cstyle.font || {}, nfont);\n                            cell.style = this.addStyle(cstyle);\n                        } else if (property === 'strike' || property === 'textwrap' || property === 'underline' || property === 'align' || property === 'valign' || property === 'color' || property === 'bgcolor') {\n                            cstyle[property] = value;\n                            cell.style = this.addStyle(cstyle);\n                        } else {\n                            cell[property] = value;\n                        }\n                    });\n                }\n            });\n        }\n        setSelectedCellText(text, state = 'input') {\n            const {autoFilter, selector, rows} = this;\n            const {ri, ci} = selector;\n            let nri = ri;\n            if (this.unsortedRowMap.has(ri)) {\n                nri = this.unsortedRowMap.get(ri);\n            }\n            const oldCell = rows.getCell(nri, ci);\n            const oldText = oldCell ? oldCell.text : '';\n            this.setCellText(nri, ci, text, state);\n            if (autoFilter.active()) {\n                const filter = autoFilter.getFilter(ci);\n                if (filter) {\n                    const vIndex = filter.value.findIndex(v => v === oldText);\n                    if (vIndex >= 0) {\n                        filter.value.splice(vIndex, 1, text);\n                    }\n                }\n            }\n        }\n        getSelectedCell() {\n            const {ri, ci} = this.selector;\n            let nri = ri;\n            if (this.unsortedRowMap.has(ri)) {\n                nri = this.unsortedRowMap.get(ri);\n            }\n            return this.rows.getCell(nri, ci);\n        }\n        xyInSelectedRect(x, y) {\n            const {left, top, width, height} = this.getSelectedRect();\n            const x1 = x - this.cols.indexWidth;\n            const y1 = y - this.rows.height;\n            return x1 > left && x1 < left + width && y1 > top && y1 < top + height;\n        }\n        getSelectedRect() {\n            return this.getRect(this.selector.range);\n        }\n        getClipboardRect() {\n            const {clipboard} = this;\n            if (!clipboard.isClear()) {\n                return this.getRect(clipboard.range);\n            }\n            return {\n                left: -100,\n                top: -100\n            };\n        }\n        getRect(cellRange) {\n            const {scroll, rows, cols, exceptRowSet} = this;\n            const {sri, sci, eri, eci} = cellRange;\n            if (sri < 0 && sci < 0) {\n                return {\n                    left: 0,\n                    l: 0,\n                    top: 0,\n                    t: 0,\n                    scroll\n                };\n            }\n            const left = cols.sumWidth(0, sci);\n            const top = rows.sumHeight(0, sri, exceptRowSet);\n            const height = rows.sumHeight(sri, eri + 1, exceptRowSet);\n            const width = cols.sumWidth(sci, eci + 1);\n            let left0 = left - scroll.x;\n            let top0 = top - scroll.y;\n            const fsh = this.freezeTotalHeight();\n            const fsw = this.freezeTotalWidth();\n            if (fsw > 0 && fsw > left) {\n                left0 = left;\n            }\n            if (fsh > 0 && fsh > top) {\n                top0 = top;\n            }\n            return {\n                l: left,\n                t: top,\n                left: left0,\n                top: top0,\n                height,\n                width,\n                scroll\n            };\n        }\n        getCellRectByXY(x, y) {\n            const {scroll, merges, rows, cols} = this;\n            let {ri, top, height} = getCellRowByY.call(this, y, scroll.y);\n            let {ci, left, width} = getCellColByX.call(this, x, scroll.x);\n            if (ci === -1) {\n                width = cols.totalWidth();\n            }\n            if (ri === -1) {\n                height = rows.totalHeight();\n            }\n            if (ri >= 0 || ci >= 0) {\n                const merge = merges.getFirstIncludes(ri, ci);\n                if (merge) {\n                    ri = merge.sri;\n                    ci = merge.sci;\n                    ({left, top, width, height} = this.cellRect(ri, ci));\n                }\n            }\n            return {\n                ri,\n                ci,\n                left,\n                top,\n                width,\n                height\n            };\n        }\n        isSignleSelected() {\n            const {sri, sci, eri, eci} = this.selector.range;\n            const cell = this.getCell(sri, sci);\n            if (cell && cell.merge) {\n                const [rn, cn] = cell.merge;\n                if (sri + rn === eri && sci + cn === eci)\n                    return true;\n            }\n            return !this.selector.multiple();\n        }\n        canUnmerge() {\n            const {sri, sci, eri, eci} = this.selector.range;\n            const cell = this.getCell(sri, sci);\n            if (cell && cell.merge) {\n                const [rn, cn] = cell.merge;\n                if (sri + rn === eri && sci + cn === eci)\n                    return true;\n            }\n            return false;\n        }\n        merge() {\n            const {selector, rows} = this;\n            if (this.isSignleSelected())\n                return;\n            const [rn, cn] = selector.size();\n            if (rn > 1 || cn > 1) {\n                const {sri, sci} = selector.range;\n                this.changeData(() => {\n                    const cell = rows.getCellOrNew(sri, sci);\n                    cell.merge = [\n                        rn - 1,\n                        cn - 1\n                    ];\n                    this.merges.add(selector.range);\n                    this.rows.deleteCells(selector.range);\n                    this.rows.setCell(sri, sci, cell);\n                });\n            }\n        }\n        unmerge() {\n            const {selector} = this;\n            if (!this.isSignleSelected())\n                return;\n            const {sri, sci} = selector.range;\n            this.changeData(() => {\n                this.rows.deleteCell(sri, sci, 'merge');\n                this.merges.deleteWithin(selector.range);\n            });\n        }\n        canAutofilter() {\n            return !this.autoFilter.active();\n        }\n        autofilter() {\n            const {autoFilter, selector} = this;\n            this.changeData(() => {\n                if (autoFilter.active()) {\n                    autoFilter.clear();\n                    this.exceptRowSet = new Set();\n                    this.sortedRowMap = new Map();\n                    this.unsortedRowMap = new Map();\n                } else {\n                    autoFilter.ref = selector.range.toString();\n                }\n            });\n        }\n        setAutoFilter(ci, order, operator, value) {\n            const {autoFilter} = this;\n            autoFilter.addFilter(ci, operator, value);\n            autoFilter.setSort(ci, order);\n            this.resetAutoFilter();\n        }\n        resetAutoFilter() {\n            const {autoFilter, rows} = this;\n            if (!autoFilter.active())\n                return;\n            const {sort} = autoFilter;\n            const {rset, fset} = autoFilter.filteredRows((r, c) => rows.getCell(r, c));\n            const fary = Array.from(fset);\n            const oldAry = Array.from(fset);\n            if (sort) {\n                fary.sort((a, b) => {\n                    if (sort.order === 'asc')\n                        return a - b;\n                    if (sort.order === 'desc')\n                        return b - a;\n                    return 0;\n                });\n            }\n            this.exceptRowSet = rset;\n            this.sortedRowMap = new Map();\n            this.unsortedRowMap = new Map();\n            fary.forEach((it, index) => {\n                this.sortedRowMap.set(oldAry[index], it);\n                this.unsortedRowMap.set(it, oldAry[index]);\n            });\n        }\n        deleteCell(what = 'all') {\n            const {selector} = this;\n            this.changeData(() => {\n                this.rows.deleteCells(selector.range, what);\n                if (what === 'all' || what === 'format') {\n                    this.merges.deleteWithin(selector.range);\n                }\n            });\n        }\n        insert(type, n = 1) {\n            this.changeData(() => {\n                const {sri, sci} = this.selector.range;\n                const {rows, merges, cols} = this;\n                let si = sri;\n                if (type === 'row') {\n                    rows.insert(sri, n);\n                } else if (type === 'column') {\n                    rows.insertColumn(sci, n);\n                    si = sci;\n                    cols.len += 1;\n                }\n                merges.shift(type, si, n, (ri, ci, rn, cn) => {\n                    const cell = rows.getCell(ri, ci);\n                    cell.merge[0] += rn;\n                    cell.merge[1] += cn;\n                });\n            });\n        }\n        delete(type) {\n            this.changeData(() => {\n                const {rows, merges, selector, cols} = this;\n                const {range} = selector;\n                const {sri, sci, eri, eci} = selector.range;\n                const [rsize, csize] = selector.range.size();\n                let si = sri;\n                let size = rsize;\n                if (type === 'row') {\n                    rows.delete(sri, eri);\n                } else if (type === 'column') {\n                    rows.deleteColumn(sci, eci);\n                    si = range.sci;\n                    size = csize;\n                    cols.len -= 1;\n                }\n                merges.shift(type, si, -size, (ri, ci, rn, cn) => {\n                    const cell = rows.getCell(ri, ci);\n                    cell.merge[0] += rn;\n                    cell.merge[1] += cn;\n                    if (cell.merge[0] === 0 && cell.merge[1] === 0) {\n                        delete cell.merge;\n                    }\n                });\n            });\n        }\n        scrollx(x, cb) {\n            const {scroll, freeze, cols} = this;\n            const [, fci] = freeze;\n            const [ci, left, width] = helper.rangeReduceIf(fci, cols.len, 0, 0, x, i => cols.getWidth(i));\n            let x1 = left;\n            if (x > 0)\n                x1 += width;\n            if (scroll.x !== x1) {\n                scroll.ci = x > 0 ? ci : 0;\n                scroll.x = x1;\n                cb();\n            }\n        }\n        scrolly(y, cb) {\n            const {scroll, freeze, rows} = this;\n            const [fri] = freeze;\n            const [ri, top, height] = helper.rangeReduceIf(fri, rows.len, 0, 0, y, i => rows.getHeight(i));\n            let y1 = top;\n            if (y > 0)\n                y1 += height;\n            if (scroll.y !== y1) {\n                scroll.ri = y > 0 ? ri : 0;\n                scroll.y = y1;\n                cb();\n            }\n        }\n        cellRect(ri, ci) {\n            const {rows, cols} = this;\n            const left = cols.sumWidth(0, ci);\n            const top = rows.sumHeight(0, ri);\n            const cell = rows.getCell(ri, ci);\n            let width = cols.getWidth(ci);\n            let height = rows.getHeight(ri);\n            if (cell !== null) {\n                if (cell.merge) {\n                    const [rn, cn] = cell.merge;\n                    if (rn > 0) {\n                        for (let i = 1; i <= rn; i += 1) {\n                            height += rows.getHeight(ri + i);\n                        }\n                    }\n                    if (cn > 0) {\n                        for (let i = 1; i <= cn; i += 1) {\n                            width += cols.getWidth(ci + i);\n                        }\n                    }\n                }\n            }\n            return {\n                left,\n                top,\n                width,\n                height,\n                cell\n            };\n        }\n        getCell(ri, ci) {\n            return this.rows.getCell(ri, ci);\n        }\n        getCellTextOrDefault(ri, ci) {\n            const cell = this.getCell(ri, ci);\n            return cell && cell.text ? cell.text : '';\n        }\n        getCellStyle(ri, ci) {\n            const cell = this.getCell(ri, ci);\n            if (cell && cell.style !== undefined) {\n                return this.styles[cell.style];\n            }\n            return null;\n        }\n        getCellStyleOrDefault(ri, ci) {\n            const {styles, rows} = this;\n            const cell = rows.getCell(ri, ci);\n            const cellStyle = cell && cell.style !== undefined ? styles[cell.style] : {};\n            return helper.merge(this.defaultStyle(), cellStyle);\n        }\n        getSelectedCellStyle() {\n            const {ri, ci} = this.selector;\n            return this.getCellStyleOrDefault(ri, ci);\n        }\n        setCellText(ri, ci, text, state) {\n            const {rows, history, validations} = this;\n            if (state === 'finished') {\n                rows.setCellText(ri, ci, '');\n                history.add(this.getData());\n                rows.setCellText(ri, ci, text);\n            } else {\n                rows.setCellText(ri, ci, text);\n                this.change(this.getData());\n            }\n            validations.validate(ri, ci, text);\n        }\n        freezeIsActive() {\n            const [ri, ci] = this.freeze;\n            return ri > 0 || ci > 0;\n        }\n        setFreeze(ri, ci) {\n            this.changeData(() => {\n                this.freeze = [\n                    ri,\n                    ci\n                ];\n            });\n        }\n        freezeTotalWidth() {\n            return this.cols.sumWidth(0, this.freeze[1]);\n        }\n        freezeTotalHeight() {\n            return this.rows.sumHeight(0, this.freeze[0]);\n        }\n        setRowHeight(ri, height) {\n            this.changeData(() => {\n                this.rows.setHeight(ri, height);\n            });\n        }\n        setColWidth(ci, width) {\n            this.changeData(() => {\n                this.cols.setWidth(ci, width);\n            });\n        }\n        viewHeight() {\n            const {view, showToolbar} = this.settings;\n            let h = view.height();\n            h -= bottombarHeight;\n            if (showToolbar) {\n                h -= toolbarHeight;\n            }\n            return h;\n        }\n        viewWidth() {\n            return this.settings.view.width();\n        }\n        freezeViewRange() {\n            const [ri, ci] = this.freeze;\n            return new m_cell_range.CellRange(0, 0, ri - 1, ci - 1, this.freezeTotalWidth(), this.freezeTotalHeight());\n        }\n        contentRange() {\n            const {rows, cols} = this;\n            const [ri, ci] = rows.maxCell();\n            const h = rows.sumHeight(0, ri + 1);\n            const w = cols.sumWidth(0, ci + 1);\n            return new m_cell_range.CellRange(0, 0, ri, ci, w, h);\n        }\n        exceptRowTotalHeight(sri, eri) {\n            const {exceptRowSet, rows} = this;\n            const exceptRows = Array.from(exceptRowSet);\n            let exceptRowTH = 0;\n            exceptRows.forEach(ri => {\n                if (ri < sri || ri > eri) {\n                    const height = rows.getHeight(ri);\n                    exceptRowTH += height;\n                }\n            });\n            return exceptRowTH;\n        }\n        viewRange() {\n            const {scroll, rows, cols, freeze, exceptRowSet} = this;\n            let {ri, ci} = scroll;\n            if (ri <= 0)\n                [ri] = freeze;\n            if (ci <= 0)\n                [, ci] = freeze;\n            let [x, y] = [\n                0,\n                0\n            ];\n            let [eri, eci] = [\n                rows.len,\n                cols.len\n            ];\n            for (let i = ri; i < rows.len; i += 1) {\n                if (!exceptRowSet.has(i)) {\n                    y += rows.getHeight(i);\n                    eri = i;\n                }\n                if (y > this.viewHeight())\n                    break;\n            }\n            for (let j = ci; j < cols.len; j += 1) {\n                x += cols.getWidth(j);\n                eci = j;\n                if (x > this.viewWidth())\n                    break;\n            }\n            return new m_cell_range.CellRange(ri, ci, eri, eci, x, y);\n        }\n        eachMergesInView(viewRange, cb) {\n            this.merges.filterIntersects(viewRange).forEach(it => cb(it));\n        }\n        hideRowsOrCols() {\n            const {rows, cols, selector} = this;\n            const [rlen, clen] = selector.size();\n            const {sri, sci, eri, eci} = selector.range;\n            if (rlen === rows.len) {\n                for (let ci = sci; ci <= eci; ci += 1) {\n                    cols.setHide(ci, true);\n                }\n            } else if (clen === cols.len) {\n                for (let ri = sri; ri <= eri; ri += 1) {\n                    rows.setHide(ri, true);\n                }\n            }\n        }\n        unhideRowsOrCols(type, index) {\n            this[`${ type }s`].unhide(index);\n        }\n        rowEach(min, max, cb) {\n            let y = 0;\n            const {rows} = this;\n            const frset = this.exceptRowSet;\n            const frary = [...frset];\n            let offset = 0;\n            for (let i = 0; i < frary.length; i += 1) {\n                if (frary[i] < min) {\n                    offset += 1;\n                }\n            }\n            for (let i = min + offset; i <= max + offset; i += 1) {\n                if (frset.has(i)) {\n                    offset += 1;\n                } else {\n                    const rowHeight = rows.getHeight(i);\n                    if (rowHeight > 0) {\n                        cb(i, y, rowHeight);\n                        y += rowHeight;\n                        if (y > this.viewHeight())\n                            break;\n                    }\n                }\n            }\n        }\n        colEach(min, max, cb) {\n            let x = 0;\n            const {cols} = this;\n            for (let i = min; i <= max; i += 1) {\n                const colWidth = cols.getWidth(i);\n                if (colWidth > 0) {\n                    cb(i, x, colWidth);\n                    x += colWidth;\n                    if (x > this.viewWidth())\n                        break;\n                }\n            }\n        }\n        defaultStyle() {\n            return this.settings.style;\n        }\n        addStyle(nstyle) {\n            const {styles} = this;\n            for (let i = 0; i < styles.length; i += 1) {\n                const style = styles[i];\n                if (helper.equals(style, nstyle))\n                    return i;\n            }\n            styles.push(nstyle);\n            return styles.length - 1;\n        }\n        changeData(cb) {\n            this.history.add(this.getData());\n            cb();\n            this.change(this.getData());\n        }\n        setData(d) {\n            Object.keys(d).forEach(property => {\n                if (property === 'merges' || property === 'rows' || property === 'cols' || property === 'validations') {\n                    this[property].setData(d[property]);\n                } else if (property === 'freeze') {\n                    const [x, y] = m_alphabet.expr2xy(d[property]);\n                    this.freeze = [\n                        y,\n                        x\n                    ];\n                } else if (property === 'autofilter') {\n                    this.autoFilter.setData(d[property]);\n                } else if (d[property] !== undefined) {\n                    this[property] = d[property];\n                }\n            });\n            return this;\n        }\n        getData() {\n            const {name, freeze, styles, merges, rows, cols, validations, autoFilter} = this;\n            return {\n                name,\n                freeze: m_alphabet.xy2expr(freeze[1], freeze[0]),\n                styles,\n                merges: merges.getData(),\n                rows: rows.getData(),\n                cols: cols.getData(),\n                validations: validations.getData(),\n                autofilter: autoFilter.getData()\n            };\n        }\n    };\n});"]}