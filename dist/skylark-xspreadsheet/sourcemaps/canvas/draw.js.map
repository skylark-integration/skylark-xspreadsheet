{"version":3,"sources":["canvas/draw.js"],"names":["define","dpr","window","devicePixelRatio","thinLineWidth","npx","px","parseInt","npxLine","n","drawFontLine","type","tx","ty","align","valign","blheight","blwidth","floffset","x","y","this","line","Draw","[object Object]","el","width","height","ctx","getContext","resize","scale","style","clearRect","options","Object","assign","save","beginPath","restore","translate","w","h","fillRect","text","fillText","mtxt","box","attr","textWrap","font","color","strike","underline","textx","textAlign","textBaseline","italic","bold","size","name","fillStyle","strokeStyle","txts","split","biw","innerWidth","ntxts","forEach","it","txtWidth","measureText","textLine","len","start","i","length","push","substr","txtHeight","texty","txt","call","lineWidth","setLineDash","xys","moveTo","x1","y1","lineTo","stroke","borderTop","borderRight","borderBottom","borderLeft","border","topxys","rightxys","bottomxys","leftxys","sx","sy","closePath","fill","dtextcb","bgcolor","rect","clip","DrawBox","padding","top","bottom","left","right"],"mappings":"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","file":"../../canvas/draw.js","sourcesContent":["define(function () {\n    'use strict';\n    function dpr() {\n        return window.devicePixelRatio || 1;\n    }\n    function thinLineWidth() {\n        return dpr() - 0.5;\n    }\n    function npx(px) {\n        return parseInt(px * dpr(), 10);\n    }\n    function npxLine(px) {\n        const n = npx(px);\n        return n > 0 ? n - 0.5 : 0.5;\n    }\n    class DrawBox {\n        constructor(x, y, w, h, padding = 0) {\n            this.x = x;\n            this.y = y;\n            this.width = w;\n            this.height = h;\n            this.padding = padding;\n            this.bgcolor = '#ffffff';\n            this.borderTop = null;\n            this.borderRight = null;\n            this.borderBottom = null;\n            this.borderLeft = null;\n        }\n        setBorders({top, bottom, left, right}) {\n            if (top)\n                this.borderTop = top;\n            if (right)\n                this.borderRight = right;\n            if (bottom)\n                this.borderBottom = bottom;\n            if (left)\n                this.borderLeft = left;\n        }\n        innerWidth() {\n            return this.width - this.padding * 2 - 2;\n        }\n        innerHeight() {\n            return this.height - this.padding * 2 - 2;\n        }\n        textx(align) {\n            const {width, padding} = this;\n            let {x} = this;\n            if (align === 'left') {\n                x += padding;\n            } else if (align === 'center') {\n                x += width / 2;\n            } else if (align === 'right') {\n                x += width - padding;\n            }\n            return x;\n        }\n        texty(align, h) {\n            const {height, padding} = this;\n            let {y} = this;\n            if (align === 'top') {\n                y += padding;\n            } else if (align === 'middle') {\n                y += height / 2 - h / 2;\n            } else if (align === 'bottom') {\n                y += height - padding - h;\n            }\n            return y;\n        }\n        topxys() {\n            const {x, y, width} = this;\n            return [\n                [\n                    x,\n                    y\n                ],\n                [\n                    x + width,\n                    y\n                ]\n            ];\n        }\n        rightxys() {\n            const {x, y, width, height} = this;\n            return [\n                [\n                    x + width,\n                    y\n                ],\n                [\n                    x + width,\n                    y + height\n                ]\n            ];\n        }\n        bottomxys() {\n            const {x, y, width, height} = this;\n            return [\n                [\n                    x,\n                    y + height\n                ],\n                [\n                    x + width,\n                    y + height\n                ]\n            ];\n        }\n        leftxys() {\n            const {x, y, height} = this;\n            return [\n                [\n                    x,\n                    y\n                ],\n                [\n                    x,\n                    y + height\n                ]\n            ];\n        }\n    }\n    function drawFontLine(type, tx, ty, align, valign, blheight, blwidth) {\n        const floffset = {\n            x: 0,\n            y: 0\n        };\n        if (type === 'underline') {\n            if (valign === 'bottom') {\n                floffset.y = 0;\n            } else if (valign === 'top') {\n                floffset.y = -(blheight + 2);\n            } else {\n                floffset.y = -blheight / 2;\n            }\n        } else if (type === 'strike') {\n            if (valign === 'bottom') {\n                floffset.y = blheight / 2;\n            } else if (valign === 'top') {\n                floffset.y = -(blheight / 2 + 2);\n            }\n        }\n        if (align === 'center') {\n            floffset.x = blwidth / 2;\n        } else if (align === 'right') {\n            floffset.x = blwidth;\n        }\n        this.line([\n            tx - floffset.x,\n            ty - floffset.y\n        ], [\n            tx - floffset.x + blwidth,\n            ty - floffset.y\n        ]);\n    }\n    class Draw {\n        constructor(el, width, height) {\n            this.el = el;\n            this.ctx = el.getContext('2d');\n            this.resize(width, height);\n            this.ctx.scale(dpr(), dpr());\n        }\n        resize(width, height) {\n            this.el.style.width = `${ width }px`;\n            this.el.style.height = `${ height }px`;\n            this.el.width = npx(width);\n            this.el.height = npx(height);\n        }\n        clear() {\n            const {width, height} = this.el;\n            this.ctx.clearRect(0, 0, width, height);\n            return this;\n        }\n        attr(options) {\n            Object.assign(this.ctx, options);\n            return this;\n        }\n        save() {\n            this.ctx.save();\n            this.ctx.beginPath();\n            return this;\n        }\n        restore() {\n            this.ctx.restore();\n            return this;\n        }\n        beginPath() {\n            this.ctx.beginPath();\n            return this;\n        }\n        translate(x, y) {\n            this.ctx.translate(npx(x), npx(y));\n            return this;\n        }\n        scale(x, y) {\n            this.ctx.scale(x, y);\n            return this;\n        }\n        clearRect(x, y, w, h) {\n            this.ctx.clearRect(x, y, w, h);\n            return this;\n        }\n        fillRect(x, y, w, h) {\n            this.ctx.fillRect(npx(x) - 0.5, npx(y) - 0.5, npx(w), npx(h));\n            return this;\n        }\n        fillText(text, x, y) {\n            this.ctx.fillText(text, npx(x), npx(y));\n            return this;\n        }\n        text(mtxt, box, attr = {}, textWrap = true) {\n            const {ctx} = this;\n            const {align, valign, font, color, strike, underline} = attr;\n            const tx = box.textx(align);\n            ctx.save();\n            ctx.beginPath();\n            this.attr({\n                textAlign: align,\n                textBaseline: valign,\n                font: `${ font.italic ? 'italic' : '' } ${ font.bold ? 'bold' : '' } ${ npx(font.size) }px ${ font.name }`,\n                fillStyle: color,\n                strokeStyle: color\n            });\n            const txts = `${ mtxt }`.split('\\n');\n            const biw = box.innerWidth();\n            const ntxts = [];\n            txts.forEach(it => {\n                const txtWidth = ctx.measureText(it).width;\n                if (textWrap && txtWidth > npx(biw)) {\n                    let textLine = {\n                        w: 0,\n                        len: 0,\n                        start: 0\n                    };\n                    for (let i = 0; i < it.length; i += 1) {\n                        if (textLine.w >= npx(biw)) {\n                            ntxts.push(it.substr(textLine.start, textLine.len));\n                            textLine = {\n                                w: 0,\n                                len: 0,\n                                start: i\n                            };\n                        }\n                        textLine.len += 1;\n                        textLine.w += ctx.measureText(it[i]).width + 1;\n                    }\n                    if (textLine.len > 0) {\n                        ntxts.push(it.substr(textLine.start, textLine.len));\n                    }\n                } else {\n                    ntxts.push(it);\n                }\n            });\n            const txtHeight = (ntxts.length - 1) * (font.size + 2);\n            let ty = box.texty(valign, txtHeight);\n            ntxts.forEach(txt => {\n                const txtWidth = ctx.measureText(txt).width;\n                this.fillText(txt, tx, ty);\n                if (strike) {\n                    drawFontLine.call(this, 'strike', tx, ty, align, valign, font.size, txtWidth);\n                }\n                if (underline) {\n                    drawFontLine.call(this, 'underline', tx, ty, align, valign, font.size, txtWidth);\n                }\n                ty += font.size + 2;\n            });\n            ctx.restore();\n            return this;\n        }\n        border(style, color) {\n            const {ctx} = this;\n            ctx.lineWidth = thinLineWidth;\n            ctx.strokeStyle = color;\n            if (style === 'medium') {\n                ctx.lineWidth = npx(2) - 0.5;\n            } else if (style === 'thick') {\n                ctx.lineWidth = npx(3);\n            } else if (style === 'dashed') {\n                ctx.setLineDash([\n                    npx(3),\n                    npx(2)\n                ]);\n            } else if (style === 'dotted') {\n                ctx.setLineDash([\n                    npx(1),\n                    npx(1)\n                ]);\n            } else if (style === 'double') {\n                ctx.setLineDash([\n                    npx(2),\n                    0\n                ]);\n            }\n            return this;\n        }\n        line(...xys) {\n            const {ctx} = this;\n            if (xys.length > 1) {\n                ctx.beginPath();\n                const [x, y] = xys[0];\n                ctx.moveTo(npxLine(x), npxLine(y));\n                for (let i = 1; i < xys.length; i += 1) {\n                    const [x1, y1] = xys[i];\n                    ctx.lineTo(npxLine(x1), npxLine(y1));\n                }\n                ctx.stroke();\n            }\n            return this;\n        }\n        strokeBorders(box) {\n            const {ctx} = this;\n            ctx.save();\n            const {borderTop, borderRight, borderBottom, borderLeft} = box;\n            if (borderTop) {\n                this.border(...borderTop);\n                this.line(...box.topxys());\n            }\n            if (borderRight) {\n                this.border(...borderRight);\n                this.line(...box.rightxys());\n            }\n            if (borderBottom) {\n                this.border(...borderBottom);\n                this.line(...box.bottomxys());\n            }\n            if (borderLeft) {\n                this.border(...borderLeft);\n                this.line(...box.leftxys());\n            }\n            ctx.restore();\n        }\n        dropdown(box) {\n            const {ctx} = this;\n            const {x, y, width, height} = box;\n            const sx = x + width - 15;\n            const sy = y + height - 15;\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(npx(sx), npx(sy));\n            ctx.lineTo(npx(sx + 8), npx(sy));\n            ctx.lineTo(npx(sx + 4), npx(sy + 6));\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(0, 0, 0, .45)';\n            ctx.fill();\n            ctx.restore();\n        }\n        error(box) {\n            const {ctx} = this;\n            const {x, y, width} = box;\n            const sx = x + width - 1;\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(npx(sx - 8), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y + 8));\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(255, 0, 0, .65)';\n            ctx.fill();\n            ctx.restore();\n        }\n        frozen(box) {\n            const {ctx} = this;\n            const {x, y, width} = box;\n            const sx = x + width - 1;\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(npx(sx - 8), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y + 8));\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(0, 255, 0, .85)';\n            ctx.fill();\n            ctx.restore();\n        }\n        rect(box, dtextcb) {\n            const {ctx} = this;\n            const {x, y, width, height, bgcolor} = box;\n            ctx.save();\n            ctx.beginPath();\n            ctx.fillStyle = bgcolor || '#fff';\n            ctx.rect(npxLine(x + 1), npxLine(y + 1), npx(width - 2), npx(height - 2));\n            ctx.clip();\n            ctx.fill();\n            dtextcb();\n            ctx.restore();\n        }\n    }\n\n    return {\n        Draw,\n        DrawBox,\n        thinLineWidth,\n        npx\n    };\n});"]}