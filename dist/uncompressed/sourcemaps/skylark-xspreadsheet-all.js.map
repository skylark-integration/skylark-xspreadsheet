{"version":3,"sources":["skylark-xspreadsheet-all.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-xspreadsheet-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        if (ns[name]) {\r\n            if (obj2) {\r\n                throw new Error(\"This namespace already exists:\" + path);\r\n            }\r\n\r\n        } else {\r\n            ns[name] = obj2 || {};\r\n        }\r\n        return ns[name];\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var root = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(root,path,obj);\r\n    \t}\r\n    };\r\n    return root;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-xspreadsheet/component/element',[],function () {\n    'use strict';\n    class Element {\n        constructor(tag, className = '') {\n            if (typeof tag === 'string') {\n                this.el = document.createElement(tag);\n                this.el.className = className;\n            } else {\n                this.el = tag;\n            }\n            this.data = {};\n        }\n        data(key, value) {\n            if (value !== undefined) {\n                this.data[key] = value;\n                return this;\n            }\n            return this.data[key];\n        }\n        on(eventNames, handler) {\n            const [fen, ...oen] = eventNames.split('.');\n            let eventName = fen;\n            if (eventName === 'mousewheel' && /Firefox/i.test(window.navigator.userAgent)) {\n                eventName = 'DOMMouseScroll';\n            }\n            this.el.addEventListener(eventName, evt => {\n                handler(evt);\n                for (let i = 0; i < oen.length; i += 1) {\n                    const k = oen[i];\n                    if (k === 'left' && evt.button !== 0) {\n                        return;\n                    }\n                    if (k === 'right' && evt.button !== 2) {\n                        return;\n                    }\n                    if (k === 'stop') {\n                        evt.stopPropagation();\n                    }\n                }\n            });\n            return this;\n        }\n        offset(value) {\n            if (value !== undefined) {\n                Object.keys(value).forEach(k => {\n                    this.css(k, `${ value[k] }px`);\n                });\n                return this;\n            }\n            const {offsetTop, offsetLeft, offsetHeight, offsetWidth} = this.el;\n            return {\n                top: offsetTop,\n                left: offsetLeft,\n                height: offsetHeight,\n                width: offsetWidth\n            };\n        }\n        scroll(v) {\n            const {el} = this;\n            if (v !== undefined) {\n                if (v.left !== undefined) {\n                    el.scrollLeft = v.left;\n                }\n                if (v.top !== undefined) {\n                    el.scrollTop = v.top;\n                }\n            }\n            return {\n                left: el.scrollLeft,\n                top: el.scrollTop\n            };\n        }\n        box() {\n            return this.el.getBoundingClientRect();\n        }\n        parent() {\n            return new Element(this.el.parentNode);\n        }\n        children(...eles) {\n            if (arguments.length === 0) {\n                return this.el.childNodes;\n            }\n            eles.forEach(ele => this.child(ele));\n            return this;\n        }\n        removeChild(el) {\n            this.el.removeChild(el);\n        }\n        child(arg) {\n            let ele = arg;\n            if (typeof arg === 'string') {\n                ele = document.createTextNode(arg);\n            } else if (arg instanceof Element) {\n                ele = arg.el;\n            }\n            this.el.appendChild(ele);\n            return this;\n        }\n        contains(ele) {\n            return this.el.contains(ele);\n        }\n        className(v) {\n            if (v !== undefined) {\n                this.el.className = v;\n                return this;\n            }\n            return this.el.className;\n        }\n        addClass(name) {\n            this.el.classList.add(name);\n            return this;\n        }\n        hasClass(name) {\n            return this.el.classList.contains(name);\n        }\n        removeClass(name) {\n            this.el.classList.remove(name);\n            return this;\n        }\n        toggle(cls = 'active') {\n            return this.toggleClass(cls);\n        }\n        toggleClass(name) {\n            return this.el.classList.toggle(name);\n        }\n        active(flag = true, cls = 'active') {\n            if (flag)\n                this.addClass(cls);\n            else\n                this.removeClass(cls);\n            return this;\n        }\n        checked(flag = true) {\n            this.active(flag, 'checked');\n            return this;\n        }\n        disabled(flag = true) {\n            if (flag)\n                this.addClass('disabled');\n            else\n                this.removeClass('disabled');\n            return this;\n        }\n        attr(key, value) {\n            if (value !== undefined) {\n                this.el.setAttribute(key, value);\n            } else {\n                if (typeof key === 'string') {\n                    return this.el.getAttribute(key);\n                }\n                Object.keys(key).forEach(k => {\n                    this.el.setAttribute(k, key[k]);\n                });\n            }\n            return this;\n        }\n        removeAttr(key) {\n            this.el.removeAttribute(key);\n            return this;\n        }\n        html(content) {\n            if (content !== undefined) {\n                this.el.innerHTML = content;\n                return this;\n            }\n            return this.el.innerHTML;\n        }\n        val(v) {\n            if (v !== undefined) {\n                this.el.value = v;\n                return this;\n            }\n            return this.el.value;\n        }\n        focus() {\n            this.el.focus();\n        }\n        cssRemoveKeys(...keys) {\n            keys.forEach(k => this.el.style.removeProperty(k));\n            return this;\n        }\n        css(name, value) {\n            if (value === undefined && typeof name !== 'string') {\n                Object.keys(name).forEach(k => {\n                    this.el.style[k] = name[k];\n                });\n                return this;\n            }\n            if (value !== undefined) {\n                this.el.style[name] = value;\n                return this;\n            }\n            return this.el.style[name];\n        }\n        computedStyle() {\n            return window.getComputedStyle(this.el, null);\n        }\n        show() {\n            this.css('display', 'block');\n            return this;\n        }\n        hide() {\n            this.css('display', 'none');\n            return this;\n        }\n    }\n    const h = (tag, className = '') => new Element(tag, className);\n    return {\n        Element,\n        h\n    };\n});\ndefine('skylark-xspreadsheet/core/alphabet',[],function () {\n    'use strict';\n    const alphabets = [\n        'A',\n        'B',\n        'C',\n        'D',\n        'E',\n        'F',\n        'G',\n        'H',\n        'I',\n        'J',\n        'K',\n        'L',\n        'M',\n        'N',\n        'O',\n        'P',\n        'Q',\n        'R',\n        'S',\n        'T',\n        'U',\n        'V',\n        'W',\n        'X',\n        'Y',\n        'Z'\n    ];\n\n    /** index number 2 letters\n     * @example stringAt(26) ==> 'AA'\n     * @date 2019-10-10\n     * @export\n     * @param {number} index\n     * @returns {string}\n     */\n    function stringAt(index) {\n        let str = '';\n        let cindex = index;\n        while (cindex >= alphabets.length) {\n            cindex /= alphabets.length;\n            cindex -= 1;\n            str += alphabets[parseInt(cindex, 10) % alphabets.length];\n        }\n        const last = index % alphabets.length;\n        str += alphabets[last];\n        return str;\n    }\n\n    /** translate letter in A1-tag to number\n     * @date 2019-10-10\n     * @export\n     * @param {string} str \"AA\" in A1-tag \"AA1\"\n     * @returns {number}\n     */\n    function indexAt(str) {\n        let ret = 0;\n        for (let i = 0; i < str.length - 1; i += 1) {\n            const cindex = str.charCodeAt(i) - 65;\n            const exponet = str.length - 1 - i;\n            ret += alphabets.length ** exponet + alphabets.length * cindex;\n        }\n        ret += str.charCodeAt(str.length - 1) - 65;\n        return ret;\n    }\n\n\n    // B10 => x,y\n    /** translate A1-tag to XY-tag\n     * @date 2019-10-10\n     * @export\n     * @param {tagA1} src\n     * @returns {tagXY}\n     */\n    function expr2xy(src) {\n        let x = '';\n        let y = '';\n        for (let i = 0; i < src.length; i += 1) {\n            if (src.charAt(i) >= '0' && src.charAt(i) <= '9') {\n                y += src.charAt(i);\n            } else {\n                x += src.charAt(i);\n            }\n        }\n        return [\n            indexAt(x),\n            parseInt(y, 10) - 1\n        ];\n    }\n\n/** translate XY-tag to A1-tag\n * @example x,y => B10\n * @date 2019-10-10\n * @export\n * @param {number} x\n * @param {number} y\n * @returns {tagA1}\n */\n    function xy2expr(x, y) {\n        return `${ stringAt(x) }${ y + 1 }`;\n    }\n\n/** translate A1-tag src by (xn, yn)\n * @date 2019-10-10\n * @export\n * @param {tagA1} src\n * @param {number} xn\n * @param {number} yn\n * @returns {tagA1}\n */\n    function expr2expr(src, xn, yn, condition = () => true) {\n        if (xn === 0 && yn === 0)\n            return src;\n        const [x, y] = expr2xy(src);\n        if (!condition(x, y))\n            return src;\n        return xy2expr(x + xn, y + yn);\n    }\n    return {\n        stringAt,\n        indexAt,\n        expr2xy,\n        xy2expr,\n        expr2expr\n    };\n});\ndefine('skylark-xspreadsheet/core/cell_range',['./alphabet'], function (m_alphabet) {\n    'use strict';\n    class CellRange {\n        constructor(sri, sci, eri, eci, w = 0, h = 0) {\n            this.sri = sri;\n            this.sci = sci;\n            this.eri = eri;\n            this.eci = eci;\n            this.w = w;\n            this.h = h;\n        }\n        set(sri, sci, eri, eci) {\n            this.sri = sri;\n            this.sci = sci;\n            this.eri = eri;\n            this.eci = eci;\n        }\n        multiple() {\n            return this.eri - this.sri > 0 || this.eci - this.sci > 0;\n        }\n        includes(...args) {\n            let [ri, ci] = [\n                0,\n                0\n            ];\n            if (args.length === 1) {\n                [ci, ri] = m_alphabet.expr2xy(args[0]);\n            } else if (args.length === 2) {\n                [ri, ci] = args;\n            }\n            const {sri, sci, eri, eci} = this;\n            return sri <= ri && ri <= eri && sci <= ci && ci <= eci;\n        }\n        each(cb, rowFilter = () => true) {\n            const {sri, sci, eri, eci} = this;\n            for (let i = sri; i <= eri; i += 1) {\n                if (rowFilter(i)) {\n                    for (let j = sci; j <= eci; j += 1) {\n                        cb(i, j);\n                    }\n                }\n            }\n        }\n        contains(other) {\n            return this.sri <= other.sri && this.sci <= other.sci && this.eri >= other.eri && this.eci >= other.eci;\n        }\n        within(other) {\n            return this.sri >= other.sri && this.sci >= other.sci && this.eri <= other.eri && this.eci <= other.eci;\n        }\n        disjoint(other) {\n            return this.sri > other.eri || this.sci > other.eci || other.sri > this.eri || other.sci > this.eci;\n        }\n        intersects(other) {\n            return this.sri <= other.eri && this.sci <= other.eci && other.sri <= this.eri && other.sci <= this.eci;\n        }\n        union(other) {\n            const {sri, sci, eri, eci} = this;\n            return new CellRange(other.sri < sri ? other.sri : sri, other.sci < sci ? other.sci : sci, other.eri > eri ? other.eri : eri, other.eci > eci ? other.eci : eci);\n        }\n        difference(other) {\n            const ret = [];\n            const addRet = (sri, sci, eri, eci) => {\n                ret.push(new CellRange(sri, sci, eri, eci));\n            };\n            const {sri, sci, eri, eci} = this;\n            const dsr = other.sri - sri;\n            const dsc = other.sci - sci;\n            const der = eri - other.eri;\n            const dec = eci - other.eci;\n            if (dsr > 0) {\n                addRet(sri, sci, other.sri - 1, eci);\n                if (der > 0) {\n                    addRet(other.eri + 1, sci, eri, eci);\n                    if (dsc > 0) {\n                        addRet(other.sri, sci, other.eri, other.sci - 1);\n                    }\n                    if (dec > 0) {\n                        addRet(other.sri, other.eci + 1, other.eri, eci);\n                    }\n                } else {\n                    if (dsc > 0) {\n                        addRet(other.sri, sci, eri, other.sci - 1);\n                    }\n                    if (dec > 0) {\n                        addRet(other.sri, other.eci + 1, eri, eci);\n                    }\n                }\n            } else if (der > 0) {\n                addRet(other.eri + 1, sci, eri, eci);\n                if (dsc > 0) {\n                    addRet(sri, sci, other.eri, other.sci - 1);\n                }\n                if (dec > 0) {\n                    addRet(sri, other.eci + 1, other.eri, eci);\n                }\n            }\n            if (dsc > 0) {\n                addRet(sri, sci, eri, other.sci - 1);\n                if (dec > 0) {\n                    addRet(sri, other.eri + 1, eri, eci);\n                    if (dsr > 0) {\n                        addRet(sri, other.sci, other.sri - 1, other.eci);\n                    }\n                    if (der > 0) {\n                        addRet(other.sri + 1, other.sci, eri, other.eci);\n                    }\n                } else {\n                    if (dsr > 0) {\n                        addRet(sri, other.sci, other.sri - 1, eci);\n                    }\n                    if (der > 0) {\n                        addRet(other.sri + 1, other.sci, eri, eci);\n                    }\n                }\n            } else if (dec > 0) {\n                addRet(eri, other.eci + 1, eri, eci);\n                if (dsr > 0) {\n                    addRet(sri, sci, other.sri - 1, other.eci);\n                }\n                if (der > 0) {\n                    addRet(other.eri + 1, sci, eri, other.eci);\n                }\n            }\n            return ret;\n        }\n        size() {\n            return [\n                this.eri - this.sri + 1,\n                this.eci - this.sci + 1\n            ];\n        }\n        toString() {\n            const {sri, sci, eri, eci} = this;\n            let ref = m_alphabet.xy2expr(sci, sri);\n            if (this.multiple()) {\n                ref = `${ ref }:${ m_alphabet.xy2expr(eci, eri) }`;\n            }\n            return ref;\n        }\n        clone() {\n            const {sri, sci, eri, eci, w, h} = this;\n            return new CellRange(sri, sci, eri, eci, w, h);\n        }\n        equals(other) {\n            return this.eri === other.eri && this.eci === other.eci && this.sri === other.sri && this.sci === other.sci;\n        }\n        static valueOf(ref) {\n            const refs = ref.split(':');\n            const [sci, sri] = m_alphabet.expr2xy(refs[0]);\n            let [eri, eci] = [\n                sri,\n                sci\n            ];\n            if (refs.length > 1) {\n                [eci, eri] = m_alphabet.expr2xy(refs[1]);\n            }\n            return new CellRange(sri, sci, eri, eci);\n        }\n    }\n\n    return {\n        CellRange\n    };\n});\ndefine('skylark-xspreadsheet/core/selector',[\n    './cell_range'\n], function (m_cell_range) {\n    'use strict';\n    class Selector {\n        constructor() {\n            this.range = new m_cell_range.CellRange(0, 0, 0, 0);\n            this.ri = 0;\n            this.ci = 0;\n        }\n        multiple() {\n            return this.range.multiple();\n        }\n        setIndexes(ri, ci) {\n            this.ri = ri;\n            this.ci = ci;\n        }\n        size() {\n            return this.range.size();\n        }\n    }\n\n    return Selector;\n});\ndefine('skylark-xspreadsheet/core/scroll',[],function () {\n    'use strict';\n     class Scroll {\n        constructor() {\n            this.x = 0;\n            this.y = 0;\n            this.ri = 0;\n            this.ci = 0;\n        }\n    }\n\n    return Scroll;\n});\ndefine('skylark-xspreadsheet/core/history',[],function () {\n    'use strict';\n    return class History {\n        constructor() {\n            this.undoItems = [];\n            this.redoItems = [];\n        }\n        add(data) {\n            this.undoItems.push(JSON.stringify(data));\n            this.redoItems = [];\n        }\n        canUndo() {\n            return this.undoItems.length > 0;\n        }\n        canRedo() {\n            return this.redoItems.length > 0;\n        }\n        undo(currentd, cb) {\n            const {undoItems, redoItems} = this;\n            if (this.canUndo()) {\n                redoItems.push(JSON.stringify(currentd));\n                cb(JSON.parse(undoItems.pop()));\n            }\n        }\n        redo(currentd, cb) {\n            const {undoItems, redoItems} = this;\n            if (this.canRedo()) {\n                undoItems.push(JSON.stringify(currentd));\n                cb(JSON.parse(redoItems.pop()));\n            }\n        }\n    };\n});\ndefine('skylark-xspreadsheet/core/clipboard',[],function () {\n    'use strict';\n    class Clipboard {\n        constructor() {\n            this.range = null;\n            this.state = 'clear';\n        }\n        copy(cellRange) {\n            this.range = cellRange;\n            this.state = 'copy';\n            return this;\n        }\n        cut(cellRange) {\n            this.range = cellRange;\n            this.state = 'cut';\n            return this;\n        }\n        isCopy() {\n            return this.state === 'copy';\n        }\n        isCut() {\n            return this.state === 'cut';\n        }\n        isClear() {\n            return this.state === 'clear';\n        }\n        clear() {\n            this.range = null;\n            this.state = 'clear';\n        }\n    }\n\n    return Clipboard;\n});\ndefine('skylark-xspreadsheet/core/auto_filter',[\n    './cell_range'\n], function (m_cell_range) {\n    'use strict';\n\n// operator: all|eq|neq|gt|gte|lt|lte|in|be\n// value:\n//   in => []\n//   be => [min, max]\n    class Filter {\n        constructor(ci, operator, value) {\n            this.ci = ci;\n            this.operator = operator;\n            this.value = value;\n        }\n        set(operator, value) {\n            this.operator = operator;\n            this.value = value;\n        }\n        includes(v) {\n            const {operator, value} = this;\n            if (operator === 'all') {\n                return true;\n            }\n            if (operator === 'in') {\n                return value.includes(v);\n            }\n            return false;\n        }\n        vlength() {\n            const {operator, value} = this;\n            if (operator === 'in') {\n                return value.length;\n            }\n            return 0;\n        }\n        getData() {\n            const {ci, operator, value} = this;\n            return {\n                ci,\n                operator,\n                value\n            };\n        }\n    }\n    class Sort {\n        constructor(ci, order) {\n            this.ci = ci;\n            this.order = order;\n        }\n        asc() {\n            return this.order === 'asc';\n        }\n        desc() {\n            return this.order === 'desc';\n        }\n    }\n    class AutoFilter {\n        constructor() {\n            this.ref = null;\n            this.filters = [];\n            this.sort = null;\n        }\n        setData({ref, filters, sort}) {\n            if (ref != null) {\n                this.ref = ref;\n                this.fitlers = filters.map(it => new Filter(it.ci, it.operator, it.value));\n                if (sort) {\n                    this.sort = new Sort(sort.ci, sort.order);\n                }\n            }\n        }\n        getData() {\n            if (this.active()) {\n                const {ref, filters, sort} = this;\n                return {\n                    ref,\n                    filters: filters.map(it => it.getData()),\n                    sort\n                };\n            }\n            return {};\n        }\n        addFilter(ci, operator, value) {\n            const filter = this.getFilter(ci);\n            if (filter == null) {\n                this.filters.push(new Filter(ci, operator, value));\n            } else {\n                filter.set(operator, value);\n            }\n        }\n        setSort(ci, order) {\n            this.sort = order ? new Sort(ci, order) : null;\n        }\n        includes(ri, ci) {\n            if (this.active()) {\n                return this.hrange().includes(ri, ci);\n            }\n            return false;\n        }\n        getSort(ci) {\n            const {sort} = this;\n            if (sort && sort.ci === ci) {\n                return sort;\n            }\n            return null;\n        }\n        getFilter(ci) {\n            const {filters} = this;\n            for (let i = 0; i < filters.length; i += 1) {\n                if (filters[i].ci === ci) {\n                    return filters[i];\n                }\n            }\n            return null;\n        }\n        filteredRows(getCell) {\n            const rset = new Set();\n            const fset = new Set();\n            if (this.active()) {\n                const {sri, eri} = this.range();\n                const {filters} = this;\n                for (let ri = sri + 1; ri <= eri; ri += 1) {\n                    for (let i = 0; i < filters.length; i += 1) {\n                        const filter = filters[i];\n                        const cell = getCell(ri, filter.ci);\n                        const ctext = cell ? cell.text : '';\n                        if (!filter.includes(ctext)) {\n                            rset.add(ri);\n                            break;\n                        } else {\n                            fset.add(ri);\n                        }\n                    }\n                }\n            }\n            return {\n                rset,\n                fset\n            };\n        }\n        items(ci, getCell) {\n            const m = {};\n            if (this.active()) {\n                const {sri, eri} = this.range();\n                for (let ri = sri + 1; ri <= eri; ri += 1) {\n                    const cell = getCell(ri, ci);\n                    if (cell !== null && !/^\\s*$/.test(cell.text)) {\n                        const key = cell.text;\n                        const cnt = (m[key] || 0) + 1;\n                        m[key] = cnt;\n                    } else {\n                        m[''] = (m[''] || 0) + 1;\n                    }\n                }\n            }\n            return m;\n        }\n        range() {\n            return m_cell_range.CellRange.valueOf(this.ref);\n        }\n        hrange() {\n            const r = this.range();\n            r.eri = r.sri;\n            return r;\n        }\n        clear() {\n            this.ref = null;\n            this.filters = [];\n            this.sort = null;\n        }\n        active() {\n            return this.ref !== null;\n        }\n    };\n\n    return AutoFilter;\n});\ndefine('skylark-xspreadsheet/core/merge',['./cell_range'], function (m_cell_range) {\n    'use strict';\n    class Merges {\n        constructor(d = []) {\n            this._ = d;\n        }\n        forEach(cb) {\n            this._.forEach(cb);\n        }\n        deleteWithin(cr) {\n            this._ = this._.filter(it => !it.within(cr));\n        }\n        getFirstIncludes(ri, ci) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const it = this._[i];\n                if (it.includes(ri, ci)) {\n                    return it;\n                }\n            }\n            return null;\n        }\n        filterIntersects(cellRange) {\n            return new Merges(this._.filter(it => it.intersects(cellRange)));\n        }\n        intersects(cellRange) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const it = this._[i];\n                if (it.intersects(cellRange)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        union(cellRange) {\n            let cr = cellRange;\n            this._.forEach(it => {\n                if (it.intersects(cr)) {\n                    cr = it.union(cr);\n                }\n            });\n            return cr;\n        }\n        add(cr) {\n            this.deleteWithin(cr);\n            this._.push(cr);\n        }\n        shift(type, index, n, cbWithin) {\n            this._.forEach(cellRange => {\n                const {sri, sci, eri, eci} = cellRange;\n                const range = cellRange;\n                if (type === 'row') {\n                    if (sri >= index) {\n                        range.sri += n;\n                        range.eri += n;\n                    } else if (sri < index && index <= eri) {\n                        range.eri += n;\n                        cbWithin(sri, sci, n, 0);\n                    }\n                } else if (type === 'column') {\n                    if (sci >= index) {\n                        range.sci += n;\n                        range.eci += n;\n                    } else if (sci < index && index <= eci) {\n                        range.eci += n;\n                        cbWithin(sri, sci, 0, n);\n                    }\n                }\n            });\n        }\n        move(cellRange, rn, cn) {\n            this._.forEach(it1 => {\n                const it = it1;\n                if (it.within(cellRange)) {\n                    it.eri += rn;\n                    it.sri += rn;\n                    it.sci += cn;\n                    it.eci += cn;\n                }\n            });\n        }\n        setData(merges) {\n            this._ = merges.map(merge => m_cell_range.CellRange.valueOf(merge));\n            return this;\n        }\n        getData() {\n            return this._.map(merge => merge.toString());\n        }\n    }\n    return {\n        Merges\n    };\n});\ndefine('skylark-xspreadsheet/core/helper',[],function () {\n    'use strict';\n    function cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    const mergeDeep = (object = {}, ...sources) => {\n        sources.forEach(source => {\n            Object.keys(source).forEach(key => {\n                const v = source[key];\n                if (typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean') {\n                    object[key] = v;\n                } else if (typeof v !== 'function' && !Array.isArray(v) && v instanceof Object) {\n                    object[key] = object[key] || {};\n                    mergeDeep(object[key], v);\n                } else {\n                    object[key] = v;\n                }\n            });\n        });\n        return object;\n    };\n    function equals(obj1, obj2) {\n        const keys = Object.keys(obj1);\n        if (keys.length !== Object.keys(obj2).length)\n            return false;\n        for (let i = 0; i < keys.length; i += 1) {\n            const k = keys[i];\n            const v1 = obj1[k];\n            const v2 = obj2[k];\n            if (v2 === undefined)\n                return false;\n            if (typeof v1 === 'string' || typeof v1 === 'number' || typeof v1 === 'boolean') {\n                if (v1 !== v2)\n                    return false;\n            } else if (Array.isArray(v1)) {\n                if (v1.length !== v2.length)\n                    return false;\n                for (let ai = 0; ai < v1.length; ai += 1) {\n                    if (!equals(v1[ai], v2[ai]))\n                        return false;\n                }\n            } else if (typeof v1 !== 'function' && !Array.isArray(v1) && v1 instanceof Object) {\n                if (!equals(v1, v2))\n                    return false;\n            }\n        }\n        return true;\n    }\n    const sum = (objOrAry, cb = value => value) => {\n        let total = 0;\n        let size = 0;\n        Object.keys(objOrAry).forEach(key => {\n            total += cb(objOrAry[key], key);\n            size += 1;\n        });\n        return [\n            total,\n            size\n        ];\n    };\n    function deleteProperty(obj, property) {\n        const oldv = obj[`${ property }`];\n        delete obj[`${ property }`];\n        return oldv;\n    }\n    function rangeReduceIf(min, max, inits, initv, ifv, getv) {\n        let s = inits;\n        let v = initv;\n        let i = min;\n        for (; i < max; i += 1) {\n            if (s > ifv)\n                break;\n            v = getv(i);\n            s += v;\n        }\n        return [\n            i,\n            s - v,\n            v\n        ];\n    }\n    function rangeSum(min, max, getv) {\n        let s = 0;\n        for (let i = min; i < max; i += 1) {\n            s += getv(i);\n        }\n        return s;\n    }\n    function rangeEach(min, max, cb) {\n        for (let i = min; i < max; i += 1) {\n            cb(i);\n        }\n    }\n    function arrayEquals(a1, a2) {\n        if (a1.length === a2.length) {\n            for (let i = 0; i < a1.length; i += 1) {\n                if (a1[i] !== a2[i])\n                    return false;\n            }\n        } else\n            return false;\n        return true;\n    }\n    function digits(a) {\n        const v = `${ a }`;\n        let ret = 0;\n        let flag = false;\n        for (let i = 0; i < v.length; i += 1) {\n            if (flag === true)\n                ret += 1;\n            if (v.charAt(i) === '.')\n                flag = true;\n        }\n        return ret;\n    }\n    function numberCalc(type, a1, a2) {\n        if (Number.isNaN(a1) || Number.isNaN(a2)) {\n            return a1 + type + a2;\n        }\n        const al1 = digits(a1);\n        const al2 = digits(a2);\n        const num1 = Number(a1);\n        const num2 = Number(a2);\n        let ret = 0;\n        if (type === '-') {\n            ret = num1 - num2;\n        } else if (type === '+') {\n            ret = num1 + num2;\n        } else if (type === '*') {\n            ret = num1 * num2;\n        } else if (type === '/') {\n            ret = num1 / num2;\n            if (digits(ret) > 5)\n                return ret.toFixed(2);\n            return ret;\n        }\n        return ret.toFixed(Math.max(al1, al2));\n    }\n    return {\n        cloneDeep,\n        merge: (...sources) => mergeDeep({}, ...sources),\n        equals,\n        arrayEquals,\n        sum,\n        rangeEach,\n        rangeSum,\n        rangeReduceIf,\n        deleteProperty,\n        numberCalc\n    };\n});\ndefine('skylark-xspreadsheet/core/row',[\n    './helper',\n    './alphabet'\n], function (helper, m_alphabet) {\n    'use strict';\n    class Rows {\n        constructor({len, height}) {\n            this._ = {};\n            this.len = len;\n            this.height = height;\n        }\n        getHeight(ri) {\n            if (this.isHide(ri))\n                return 0;\n            const row = this.get(ri);\n            if (row && row.height) {\n                return row.height;\n            }\n            return this.height;\n        }\n        setHeight(ri, v) {\n            const row = this.getOrNew(ri);\n            row.height = v;\n        }\n        unhide(idx) {\n            let index = idx;\n            while (index > 0) {\n                index -= 1;\n                if (this.isHide(index)) {\n                    this.setHide(index, false);\n                } else\n                    break;\n            }\n        }\n        isHide(ri) {\n            const row = this.get(ri);\n            return row && row.hide;\n        }\n        setHide(ri, v) {\n            const row = this.getOrNew(ri);\n            if (v === true)\n                row.hide = true;\n            else\n                delete row.hide;\n        }\n        setStyle(ri, style) {\n            const row = this.getOrNew(ri);\n            row.style = style;\n        }\n        sumHeight(min, max, exceptSet) {\n            return helper.rangeSum(min, max, i => {\n                if (exceptSet && exceptSet.has(i))\n                    return 0;\n                return this.getHeight(i);\n            });\n        }\n        totalHeight() {\n            return this.sumHeight(0, this.len);\n        }\n        get(ri) {\n            return this._[ri];\n        }\n        getOrNew(ri) {\n            this._[ri] = this._[ri] || { cells: {} };\n            return this._[ri];\n        }\n        getCell(ri, ci) {\n            const row = this.get(ri);\n            if (row !== undefined && row.cells !== undefined && row.cells[ci] !== undefined) {\n                return row.cells[ci];\n            }\n            return null;\n        }\n        getCellMerge(ri, ci) {\n            const cell = this.getCell(ri, ci);\n            if (cell && cell.merge)\n                return cell.merge;\n            return [\n                0,\n                0\n            ];\n        }\n        getCellOrNew(ri, ci) {\n            const row = this.getOrNew(ri);\n            row.cells[ci] = row.cells[ci] || {};\n            return row.cells[ci];\n        }\n        setCell(ri, ci, cell, what = 'all') {\n            const row = this.getOrNew(ri);\n            if (what === 'all') {\n                row.cells[ci] = cell;\n            } else if (what === 'text') {\n                row.cells[ci] = row.cells[ci] || {};\n                row.cells[ci].text = cell.text;\n            } else if (what === 'format') {\n                row.cells[ci] = row.cells[ci] || {};\n                row.cells[ci].style = cell.style;\n                if (cell.merge)\n                    row.cells[ci].merge = cell.merge;\n            }\n        }\n        setCellText(ri, ci, text) {\n            const cell = this.getCellOrNew(ri, ci);\n            cell.text = text;\n        }\n        copyPaste(srcCellRange, dstCellRange, what, autofill = false, cb = () => {\n        }) {\n            const {sri, sci, eri, eci} = srcCellRange;\n            const dsri = dstCellRange.sri;\n            const dsci = dstCellRange.sci;\n            const deri = dstCellRange.eri;\n            const deci = dstCellRange.eci;\n            const [rn, cn] = srcCellRange.size();\n            const [drn, dcn] = dstCellRange.size();\n            let isAdd = true;\n            let dn = 0;\n            if (deri < sri || deci < sci) {\n                isAdd = false;\n                if (deri < sri)\n                    dn = drn;\n                else\n                    dn = dcn;\n            }\n            for (let i = sri; i <= eri; i += 1) {\n                if (this._[i]) {\n                    for (let j = sci; j <= eci; j += 1) {\n                        if (this._[i].cells && this._[i].cells[j]) {\n                            for (let ii = dsri; ii <= deri; ii += rn) {\n                                for (let jj = dsci; jj <= deci; jj += cn) {\n                                    const nri = ii + (i - sri);\n                                    const nci = jj + (j - sci);\n                                    const ncell = helper.cloneDeep(this._[i].cells[j]);\n                                    if (autofill && ncell && ncell.text && ncell.text.length > 0) {\n                                        const {text} = ncell;\n                                        let n = jj - dsci + (ii - dsri) + 2;\n                                        if (!isAdd) {\n                                            n -= dn + 1;\n                                        }\n                                        if (text[0] === '=') {\n                                            ncell.text = text.replace(/[a-zA-Z]{1,3}\\d+/g, word => {\n                                                let [xn, yn] = [\n                                                    0,\n                                                    0\n                                                ];\n                                                if (sri === dsri) {\n                                                    xn = n - 1;\n                                                } else {\n                                                    yn = n - 1;\n                                                }\n                                                if (/^\\d+$/.test(word))\n                                                    return word;\n                                                return m_alphabet.expr2expr(word, xn, yn);\n                                            });\n                                        } else if (rn <= 1 && cn > 1 && (dsri > eri || deri < sri) || cn <= 1 && rn > 1 && (dsci > eci || deci < sci) || rn <= 1 && cn <= 1) {\n                                            const result = /[\\\\.\\d]+$/.exec(text);\n                                            if (result !== null) {\n                                                const index = Number(result[0]) + n - 1;\n                                                ncell.text = text.substring(0, result.index) + index;\n                                            }\n                                        }\n                                    }\n                                    this.setCell(nri, nci, ncell, what);\n                                    cb(nri, nci, ncell);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cutPaste(srcCellRange, dstCellRange) {\n            const ncellmm = {};\n            this.each(ri => {\n                this.eachCells(ri, ci => {\n                    let nri = parseInt(ri, 10);\n                    let nci = parseInt(ci, 10);\n                    if (srcCellRange.includes(ri, ci)) {\n                        nri = dstCellRange.sri + (nri - srcCellRange.sri);\n                        nci = dstCellRange.sci + (nci - srcCellRange.sci);\n                    }\n                    ncellmm[nri] = ncellmm[nri] || { cells: {} };\n                    ncellmm[nri].cells[nci] = this._[ri].cells[ci];\n                });\n            });\n            this._ = ncellmm;\n        }\n        paste(src, dstCellRange) {\n            if (src.length <= 0)\n                return;\n            const {sri, sci} = dstCellRange;\n            src.forEach((row, i) => {\n                const ri = sri + i;\n                row.forEach((cell, j) => {\n                    const ci = sci + j;\n                    this.setCellText(ri, ci, cell);\n                });\n            });\n        }\n        insert(sri, n = 1) {\n            const ndata = {};\n            this.each((ri, row) => {\n                let nri = parseInt(ri, 10);\n                if (nri >= sri) {\n                    nri += n;\n                    this.eachCells(ri, (ci, cell) => {\n                        if (cell.text && cell.text[0] === '=') {\n                            cell.text = cell.text.replace(/[a-zA-Z]{1,3}\\d+/g, word => m_alphabet.expr2expr(word, 0, n, (x, y) => y >= sri));\n                        }\n                    });\n                }\n                ndata[nri] = row;\n            });\n            this._ = ndata;\n            this.len += n;\n        }\n        delete(sri, eri) {\n            const n = eri - sri + 1;\n            const ndata = {};\n            this.each((ri, row) => {\n                const nri = parseInt(ri, 10);\n                if (nri < sri) {\n                    ndata[nri] = row;\n                } else if (ri > eri) {\n                    ndata[nri - n] = row;\n                    this.eachCells(ri, (ci, cell) => {\n                        if (cell.text && cell.text[0] === '=') {\n                            cell.text = cell.text.replace(/[a-zA-Z]{1,3}\\d+/g, word => m_alphabet.expr2expr(word, 0, -n, (x, y) => y > eri));\n                        }\n                    });\n                }\n            });\n            this._ = ndata;\n            this.len -= n;\n        }\n        insertColumn(sci, n = 1) {\n            this.each((ri, row) => {\n                const rndata = {};\n                this.eachCells(ri, (ci, cell) => {\n                    let nci = parseInt(ci, 10);\n                    if (nci >= sci) {\n                        nci += n;\n                        if (cell.text && cell.text[0] === '=') {\n                            cell.text = cell.text.replace(/[a-zA-Z]{1,3}\\d+/g, word => m_alphabet.expr2expr(word, n, 0, x => x >= sci));\n                        }\n                    }\n                    rndata[nci] = cell;\n                });\n                row.cells = rndata;\n            });\n        }\n        deleteColumn(sci, eci) {\n            const n = eci - sci + 1;\n            this.each((ri, row) => {\n                const rndata = {};\n                this.eachCells(ri, (ci, cell) => {\n                    const nci = parseInt(ci, 10);\n                    if (nci < sci) {\n                        rndata[nci] = cell;\n                    } else if (nci > eci) {\n                        rndata[nci - n] = cell;\n                        if (cell.text && cell.text[0] === '=') {\n                            cell.text = cell.text.replace(/[a-zA-Z]{1,3}\\d+/g, word => m_alphabet.expr2expr(word, -n, 0, x => x > eci));\n                        }\n                    }\n                });\n                row.cells = rndata;\n            });\n        }\n        deleteCells(cellRange, what = 'all') {\n            cellRange.each((i, j) => {\n                this.deleteCell(i, j, what);\n            });\n        }\n        deleteCell(ri, ci, what = 'all') {\n            const row = this.get(ri);\n            if (row !== null) {\n                const cell = this.getCell(ri, ci);\n                if (cell !== null) {\n                    if (what === 'all') {\n                        delete row.cells[ci];\n                    } else if (what === 'text') {\n                        if (cell.text)\n                            delete cell.text;\n                        if (cell.value)\n                            delete cell.value;\n                    } else if (what === 'format') {\n                        if (cell.style !== undefined)\n                            delete cell.style;\n                        if (cell.merge)\n                            delete cell.merge;\n                    } else if (what === 'merge') {\n                        if (cell.merge)\n                            delete cell.merge;\n                    }\n                }\n            }\n        }\n        maxCell() {\n            const keys = Object.keys(this._);\n            const ri = keys[keys.length - 1];\n            const col = this._[ri];\n            if (col) {\n                const {cells} = col;\n                const ks = Object.keys(cells);\n                const ci = ks[ks.length - 1];\n                return [\n                    parseInt(ri, 10),\n                    parseInt(ci, 10)\n                ];\n            }\n            return [\n                0,\n                0\n            ];\n        }\n        each(cb) {\n            Object.entries(this._).forEach(([ri, row]) => {\n                cb(ri, row);\n            });\n        }\n        eachCells(ri, cb) {\n            if (this._[ri] && this._[ri].cells) {\n                Object.entries(this._[ri].cells).forEach(([ci, cell]) => {\n                    cb(ci, cell);\n                });\n            }\n        }\n        setData(d) {\n            if (d.len) {\n                this.len = d.len;\n                delete d.len;\n            }\n            this._ = d;\n        }\n        getData() {\n            const {len} = this;\n            return Object.assign({ len }, this._);\n        }\n    }\n    return {\n        Rows\n    };\n});\ndefine('skylark-xspreadsheet/core/col',['./helper'], function (helper) {\n    'use strict';\n    class Cols {\n        constructor({len, width, indexWidth, minWidth}) {\n            this._ = {};\n            this.len = len;\n            this.width = width;\n            this.indexWidth = indexWidth;\n            this.minWidth = minWidth;\n        }\n        setData(d) {\n            if (d.len) {\n                this.len = d.len;\n                delete d.len;\n            }\n            this._ = d;\n        }\n        getData() {\n            const {len} = this;\n            return Object.assign({ len }, this._);\n        }\n        getWidth(i) {\n            if (this.isHide(i))\n                return 0;\n            const col = this._[i];\n            if (col && col.width) {\n                return col.width;\n            }\n            return this.width;\n        }\n        getOrNew(ci) {\n            this._[ci] = this._[ci] || {};\n            return this._[ci];\n        }\n        setWidth(ci, width) {\n            const col = this.getOrNew(ci);\n            col.width = width;\n        }\n        unhide(idx) {\n            let index = idx;\n            while (index > 0) {\n                index -= 1;\n                if (this.isHide(index)) {\n                    this.setHide(index, false);\n                } else\n                    break;\n            }\n        }\n        isHide(ci) {\n            const col = this._[ci];\n            return col && col.hide;\n        }\n        setHide(ci, v) {\n            const col = this.getOrNew(ci);\n            if (v === true)\n                col.hide = true;\n            else\n                delete col.hide;\n        }\n        setStyle(ci, style) {\n            const col = this.getOrNew(ci);\n            col.style = style;\n        }\n        sumWidth(min, max) {\n            return helper.rangeSum(min, max, i => this.getWidth(i));\n        }\n        totalWidth() {\n            return this.sumWidth(0, this.len);\n        }\n    }\n    return {\n        Cols\n    };\n});\ndefine('skylark-xspreadsheet/locale/en',[],function () {\n    'use strict';\n    return {\n        toolbar: {\n            undo: 'Undo',\n            redo: 'Redo',\n            print: 'Print',\n            paintformat: 'Paint format',\n            clearformat: 'Clear format',\n            format: 'Format',\n            fontName: 'Font',\n            fontSize: 'Font size',\n            fontBold: 'Font bold',\n            fontItalic: 'Font italic',\n            underline: 'Underline',\n            strike: 'Strike',\n            color: 'Text color',\n            bgcolor: 'Fill color',\n            border: 'Borders',\n            merge: 'Merge cells',\n            align: 'Horizontal align',\n            valign: 'Vertical align',\n            textwrap: 'Text wrapping',\n            freeze: 'Freeze cell',\n            autofilter: 'Filter',\n            formula: 'Functions',\n            more: 'More'\n        },\n        contextmenu: {\n            copy: 'Copy',\n            cut: 'Cut',\n            paste: 'Paste',\n            pasteValue: 'Paste values only',\n            pasteFormat: 'Paste format only',\n            hide: 'Hide',\n            insertRow: 'Insert row',\n            insertColumn: 'Insert column',\n            deleteSheet: 'Delete',\n            deleteRow: 'Delete row',\n            deleteColumn: 'Delete column',\n            deleteCell: 'Delete cell',\n            deleteCellText: 'Delete cell text',\n            validation: 'Data validations',\n            cellprintable: 'Enable export',\n            cellnonprintable: 'Disable export',\n            celleditable: 'Enable editing',\n            cellnoneditable: 'Disable editing'\n        },\n        print: {\n            size: 'Paper size',\n            orientation: 'Page orientation',\n            orientations: [\n                'Landscape',\n                'Portrait'\n            ]\n        },\n        format: {\n            normal: 'Normal',\n            text: 'Plain Text',\n            number: 'Number',\n            percent: 'Percent',\n            rmb: 'RMB',\n            usd: 'USD',\n            eur: 'EUR',\n            date: 'Date',\n            time: 'Time',\n            datetime: 'Date time',\n            duration: 'Duration'\n        },\n        formula: {\n            sum: 'Sum',\n            average: 'Average',\n            max: 'Max',\n            min: 'Min',\n            _if: 'IF',\n            and: 'AND',\n            or: 'OR',\n            concat: 'Concat'\n        },\n        validation: {\n            required: 'it must be required',\n            notMatch: 'it not match its validation rule',\n            between: 'it is between {} and {}',\n            notBetween: 'it is not between {} and {}',\n            notIn: 'it is not in list',\n            equal: 'it equal to {}',\n            notEqual: 'it not equal to {}',\n            lessThan: 'it less than {}',\n            lessThanEqual: 'it less than or equal to {}',\n            greaterThan: 'it greater than {}',\n            greaterThanEqual: 'it greater than or equal to {}'\n        },\n        error: { pasteForMergedCell: 'Unable to do this for merged cells' },\n        calendar: {\n            weeks: [\n                'Sun',\n                'Mon',\n                'Tue',\n                'Wed',\n                'Thu',\n                'Fri',\n                'Sat'\n            ],\n            months: [\n                'January',\n                'February',\n                'March',\n                'April',\n                'May',\n                'June',\n                'July',\n                'August',\n                'September',\n                'October',\n                'November',\n                'December'\n            ]\n        },\n        button: {\n            next: 'Next',\n            cancel: 'Cancel',\n            remove: 'Remove',\n            save: 'Save',\n            ok: 'OK'\n        },\n        sort: {\n            desc: 'Sort Z -> A',\n            asc: 'Sort A -> Z'\n        },\n        filter: { empty: 'empty' },\n        dataValidation: {\n            mode: 'Mode',\n            range: 'Cell Range',\n            criteria: 'Criteria',\n            modeType: {\n                cell: 'Cell',\n                column: 'Colun',\n                row: 'Row'\n            },\n            type: {\n                list: 'List',\n                number: 'Number',\n                date: 'Date',\n                phone: 'Phone',\n                email: 'Email'\n            },\n            operator: {\n                be: 'between',\n                nbe: 'not betwwen',\n                lt: 'less than',\n                lte: 'less than or equal to',\n                gt: 'greater than',\n                gte: 'greater than or equal to',\n                eq: 'equal to',\n                neq: 'not equal to'\n            }\n        }\n    };\n});\ndefine('skylark-xspreadsheet/locale/locale',['./en'], function (en) {\n    'use strict';\n    let $lang = 'en';\n    const $messages = { en };\n    function translate(key, messages) {\n        if (messages && messages[$lang]) {\n            let message = messages[$lang];\n            const keys = key.split('.');\n            for (let i = 0; i < keys.length; i += 1) {\n                const property = keys[i];\n                const value = message[property];\n                if (i === keys.length - 1)\n                    return value;\n                if (!value)\n                    return undefined;\n                message = value;\n            }\n        }\n        return undefined;\n    }\n    function t(key) {\n        let v = translate(key, $messages);\n        if (!v && window && window.x_spreadsheet && window.x_spreadsheet.$messages) {\n            v = translate(key, window.x_spreadsheet.$messages);\n        }\n        return v || '';\n    }\n    function tf(key) {\n        return () => t(key);\n    }\n    function locale(lang, message) {\n        $lang = lang;\n        if (message) {\n            $messages[lang] = message;\n        }\n    }\n    return {\n        locale,\n        t,\n        tf\n    };\n});\ndefine('skylark-xspreadsheet/core/validator',[\n    '../locale/locale',\n    './helper'\n], function (m_locale, helper) {\n    'use strict';\n    const rules = {\n        phone: /^[1-9]\\d{10}$/,\n        email: /w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*/\n    };\n    function returnMessage(flag, key, ...arg) {\n        let message = '';\n        if (!flag) {\n            message = m_locale.t(`validation.${ key }`, ...arg);\n        }\n        return [\n            flag,\n            message\n        ];\n    }\n    class Validator {\n        constructor(type, required, value, operator) {\n            this.required = required;\n            this.value = value;\n            this.type = type;\n            this.operator = operator;\n            this.message = '';\n        }\n        parseValue(v) {\n            const {type} = this;\n            if (type === 'date') {\n                return new Date(v);\n            }\n            if (type === 'number') {\n                return Number(v);\n            }\n            return v;\n        }\n        equals(other) {\n            let flag = this.type === other.type && this.required === other.required && this.operator === other.operator;\n            if (flag) {\n                if (Array.isArray(this.value)) {\n                    flag = helper.arrayEquals(this.value, other.value);\n                } else {\n                    flag = this.value === other.value;\n                }\n            }\n            return flag;\n        }\n        values() {\n            return this.value.split(',');\n        }\n        validate(v) {\n            const {required, operator, value, type} = this;\n            if (required && /^\\s*$/.test(v)) {\n                return returnMessage(false, 'required');\n            }\n            if (/^\\s*$/.test(v))\n                return [true];\n            if (rules[type] && !rules[type].test(v)) {\n                return returnMessage(false, 'notMatch');\n            }\n            if (type === 'list') {\n                return returnMessage(this.values().includes(v), 'notIn');\n            }\n            if (operator) {\n                const v1 = this.parseValue(v);\n                if (operator === 'be') {\n                    const [min, max] = value;\n                    return returnMessage(v1 >= this.parseValue(min) && v1 <= this.parseValue(max), 'between', min, max);\n                }\n                if (operator === 'nbe') {\n                    const [min, max] = value;\n                    return returnMessage(v1 < this.parseValue(min) || v1 > this.parseValue(max), 'notBetween', min, max);\n                }\n                if (operator === 'eq') {\n                    return returnMessage(v1 === this.parseValue(value), 'equal', value);\n                }\n                if (operator === 'neq') {\n                    return returnMessage(v1 !== this.parseValue(value), 'notEqual', value);\n                }\n                if (operator === 'lt') {\n                    return returnMessage(v1 < this.parseValue(value), 'lessThan', value);\n                }\n                if (operator === 'lte') {\n                    return returnMessage(v1 <= this.parseValue(value), 'lessThanEqual', value);\n                }\n                if (operator === 'gt') {\n                    return returnMessage(v1 > this.parseValue(value), 'greaterThan', value);\n                }\n                if (operator === 'gte') {\n                    return returnMessage(v1 >= this.parseValue(value), 'greaterThanEqual', value);\n                }\n            }\n            return [true];\n        }\n    };\n\n    return Validator;\n});\ndefine('skylark-xspreadsheet/core/validation',[\n    './validator',\n    './cell_range'\n], function (Validator, m_cell_range) {\n    'use strict';\n    class Validation {\n        constructor(mode, refs, validator) {\n            this.refs = refs;\n            this.mode = mode;\n            this.validator = validator;\n        }\n        includes(ri, ci) {\n            const {refs} = this;\n            for (let i = 0; i < refs.length; i += 1) {\n                const cr = m_cell_range.CellRange.valueOf(refs[i]);\n                if (cr.includes(ri, ci))\n                    return true;\n            }\n            return false;\n        }\n        addRef(ref) {\n            this.remove(m_cell_range.CellRange.valueOf(ref));\n            this.refs.push(ref);\n        }\n        remove(cellRange) {\n            const nrefs = [];\n            this.refs.forEach(it => {\n                const cr = m_cell_range.CellRange.valueOf(it);\n                if (cr.intersects(cellRange)) {\n                    const crs = cr.difference(cellRange);\n                    crs.forEach(it1 => nrefs.push(it1.toString()));\n                } else {\n                    nrefs.push(it);\n                }\n            });\n            this.refs = nrefs;\n        }\n        getData() {\n            const {refs, mode, validator} = this;\n            const {type, required, operator, value} = validator;\n            return {\n                refs,\n                mode,\n                type,\n                required,\n                operator,\n                value\n            };\n        }\n        static valueOf({refs, mode, type, required, operator, value}) {\n            return new Validation(mode, refs, new Validator(type, required, value, operator));\n        }\n    }\n    class Validations {\n        constructor() {\n            this._ = [];\n            this.errors = new Map();\n        }\n        getError(ri, ci) {\n            return this.errors.get(`${ ri }_${ ci }`);\n        }\n        validate(ri, ci, text) {\n            const v = this.get(ri, ci);\n            const key = `${ ri }_${ ci }`;\n            const {errors} = this;\n            if (v !== null) {\n                const [flag, message] = v.validator.validate(text);\n                if (!flag) {\n                    errors.set(key, message);\n                } else {\n                    errors.delete(key);\n                }\n            } else {\n                errors.delete(key);\n            }\n            return true;\n        }\n        add(mode, ref, {type, required, value, operator}) {\n            const validator = new Validator(type, required, value, operator);\n            const v = this.getByValidator(validator);\n            if (v !== null) {\n                v.addRef(ref);\n            } else {\n                this._.push(new Validation(mode, [ref], validator));\n            }\n        }\n        getByValidator(validator) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const v = this._[i];\n                if (v.validator.equals(validator)) {\n                    return v;\n                }\n            }\n            return null;\n        }\n        get(ri, ci) {\n            for (let i = 0; i < this._.length; i += 1) {\n                const v = this._[i];\n                if (v.includes(ri, ci))\n                    return v;\n            }\n            return null;\n        }\n        remove(cellRange) {\n            this.each(it => {\n                it.remove(cellRange);\n            });\n        }\n        each(cb) {\n            this._.forEach(it => cb(it));\n        }\n        getData() {\n            return this._.filter(it => it.refs.length > 0).map(it => it.getData());\n        }\n        setData(d) {\n            this._ = d.map(it => Validation.valueOf(it));\n        }\n    }\n    return {\n        Validations\n    };\n});\ndefine('skylark-xspreadsheet/core/data_proxy',[\n    './selector',\n    './scroll',\n    './history',\n    './clipboard',\n    './auto_filter',\n    './merge',\n    './helper',\n    './row',\n    './col',\n    './validation',\n    './cell_range',\n    './alphabet',\n    '../locale/locale'\n], function (\n    Selector, \n    Scroll, \n    History, \n    Clipboard, \n    AutoFilter, \n    m_merge, \n    helper, \n    m_row, \n    m_col, \n    m_validation, \n    m_cell_range, \n    m_alphabet, \n    m_locale\n) {\n    'use strict';\n    const defaultSettings = {\n        mode: 'edit',\n        view: {\n            height: () => document.documentElement.clientHeight,\n            width: () => document.documentElement.clientWidth\n        },\n        showGrid: true,\n        showToolbar: true,\n        showContextmenu: true,\n        row: {\n            len: 100,\n            height: 25\n        },\n        col: {\n            len: 26,\n            width: 100,\n            indexWidth: 60,\n            minWidth: 60\n        },\n        style: {\n            bgcolor: '#ffffff',\n            align: 'left',\n            valign: 'middle',\n            textwrap: false,\n            strike: false,\n            underline: false,\n            color: '#0a0a0a',\n            font: {\n                name: 'Arial',\n                size: 10,\n                bold: false,\n                italic: false\n            },\n            format: 'normal'\n        }\n    };\n    const toolbarHeight = 41;\n    const bottombarHeight = 41;\n    function canPaste(src, dst, error = () => {\n    }) {\n        const {merges} = this;\n        const cellRange = dst.clone();\n        const [srn, scn] = src.size();\n        const [drn, dcn] = dst.size();\n        if (srn > drn) {\n            cellRange.eri = dst.sri + srn - 1;\n        }\n        if (scn > dcn) {\n            cellRange.eci = dst.sci + scn - 1;\n        }\n        if (merges.intersects(cellRange)) {\n            error(m_locale.t('error.pasteForMergedCell'));\n            return false;\n        }\n        return true;\n    }\n    function copyPaste(srcCellRange, dstCellRange, what, autofill = false) {\n        const {rows, merges} = this;\n        if (what === 'all' || what === 'format') {\n            rows.deleteCells(dstCellRange, what);\n            merges.deleteWithin(dstCellRange);\n        }\n        rows.copyPaste(srcCellRange, dstCellRange, what, autofill, (ri, ci, cell) => {\n            if (cell && cell.merge) {\n                const [rn, cn] = cell.merge;\n                if (rn <= 0 && cn <= 0)\n                    return;\n                merges.add(new m_cell_range.CellRange(ri, ci, ri + rn, ci + cn));\n            }\n        });\n    }\n    function cutPaste(srcCellRange, dstCellRange) {\n        const {clipboard, rows, merges} = this;\n        rows.cutPaste(srcCellRange, dstCellRange);\n        merges.move(srcCellRange, dstCellRange.sri - srcCellRange.sri, dstCellRange.sci - srcCellRange.sci);\n        clipboard.clear();\n    }\n    function setStyleBorder(ri, ci, bss) {\n        const {styles, rows} = this;\n        const cell = rows.getCellOrNew(ri, ci);\n        let cstyle = {};\n        if (cell.style !== undefined) {\n            cstyle = helper.cloneDeep(styles[cell.style]);\n        }\n        cstyle = helper.merge(cstyle, { border: bss });\n        cell.style = this.addStyle(cstyle);\n    }\n    function setStyleBorders({mode, style, color}) {\n        const {styles, selector, rows} = this;\n        const {sri, sci, eri, eci} = selector.range;\n        const multiple = !this.isSignleSelected();\n        if (!multiple) {\n            if (mode === 'inside' || mode === 'horizontal' || mode === 'vertical') {\n                return;\n            }\n        }\n        if (mode === 'outside' && !multiple) {\n            setStyleBorder.call(this, sri, sci, {\n                top: [\n                    style,\n                    color\n                ],\n                bottom: [\n                    style,\n                    color\n                ],\n                left: [\n                    style,\n                    color\n                ],\n                right: [\n                    style,\n                    color\n                ]\n            });\n        } else if (mode === 'none') {\n            selector.range.each((ri, ci) => {\n                const cell = rows.getCell(ri, ci);\n                if (cell && cell.style !== undefined) {\n                    const ns = helper.cloneDeep(styles[cell.style]);\n                    delete ns.border;\n                    cell.style = this.addStyle(ns);\n                }\n            });\n        } else if (mode === 'all' || mode === 'inside' || mode === 'outside' || mode === 'horizontal' || mode === 'vertical') {\n            const merges = [];\n            for (let ri = sri; ri <= eri; ri += 1) {\n                for (let ci = sci; ci <= eci; ci += 1) {\n                    const mergeIndexes = [];\n                    for (let ii = 0; ii < merges.length; ii += 1) {\n                        const [mri, mci, rn, cn] = merges[ii];\n                        if (ri === mri + rn + 1)\n                            mergeIndexes.push(ii);\n                        if (mri <= ri && ri <= mri + rn) {\n                            if (ci === mci) {\n                                ci += cn + 1;\n                                break;\n                            }\n                        }\n                    }\n                    mergeIndexes.forEach(it => merges.splice(it, 1));\n                    if (ci > eci)\n                        break;\n                    const cell = rows.getCell(ri, ci);\n                    let [rn, cn] = [\n                        0,\n                        0\n                    ];\n                    if (cell && cell.merge) {\n                        [rn, cn] = cell.merge;\n                        merges.push([\n                            ri,\n                            ci,\n                            rn,\n                            cn\n                        ]);\n                    }\n                    const mrl = rn > 0 && ri + rn === eri;\n                    const mcl = cn > 0 && ci + cn === eci;\n                    let bss = {};\n                    if (mode === 'all') {\n                        bss = {\n                            bottom: [\n                                style,\n                                color\n                            ],\n                            top: [\n                                style,\n                                color\n                            ],\n                            left: [\n                                style,\n                                color\n                            ],\n                            right: [\n                                style,\n                                color\n                            ]\n                        };\n                    } else if (mode === 'inside') {\n                        if (!mcl && ci < eci)\n                            bss.right = [\n                                style,\n                                color\n                            ];\n                        if (!mrl && ri < eri)\n                            bss.bottom = [\n                                style,\n                                color\n                            ];\n                    } else if (mode === 'horizontal') {\n                        if (!mrl && ri < eri)\n                            bss.bottom = [\n                                style,\n                                color\n                            ];\n                    } else if (mode === 'vertical') {\n                        if (!mcl && ci < eci)\n                            bss.right = [\n                                style,\n                                color\n                            ];\n                    } else if (mode === 'outside' && multiple) {\n                        if (sri === ri)\n                            bss.top = [\n                                style,\n                                color\n                            ];\n                        if (mrl || eri === ri)\n                            bss.bottom = [\n                                style,\n                                color\n                            ];\n                        if (sci === ci)\n                            bss.left = [\n                                style,\n                                color\n                            ];\n                        if (mcl || eci === ci)\n                            bss.right = [\n                                style,\n                                color\n                            ];\n                    }\n                    if (Object.keys(bss).length > 0) {\n                        setStyleBorder.call(this, ri, ci, bss);\n                    }\n                    ci += cn;\n                }\n            }\n        } else if (mode === 'top' || mode === 'bottom') {\n            for (let ci = sci; ci <= eci; ci += 1) {\n                if (mode === 'top') {\n                    setStyleBorder.call(this, sri, ci, {\n                        top: [\n                            style,\n                            color\n                        ]\n                    });\n                    ci += rows.getCellMerge(sri, ci)[1];\n                }\n                if (mode === 'bottom') {\n                    setStyleBorder.call(this, eri, ci, {\n                        bottom: [\n                            style,\n                            color\n                        ]\n                    });\n                    ci += rows.getCellMerge(eri, ci)[1];\n                }\n            }\n        } else if (mode === 'left' || mode === 'right') {\n            for (let ri = sri; ri <= eri; ri += 1) {\n                if (mode === 'left') {\n                    setStyleBorder.call(this, ri, sci, {\n                        left: [\n                            style,\n                            color\n                        ]\n                    });\n                    ri += rows.getCellMerge(ri, sci)[0];\n                }\n                if (mode === 'right') {\n                    setStyleBorder.call(this, ri, eci, {\n                        right: [\n                            style,\n                            color\n                        ]\n                    });\n                    ri += rows.getCellMerge(ri, eci)[0];\n                }\n            }\n        }\n    }\n    function getCellRowByY(y, scrollOffsety) {\n        const {rows} = this;\n        const fsh = this.freezeTotalHeight();\n        let inits = rows.height;\n        if (fsh + rows.height < y)\n            inits -= scrollOffsety;\n        const frset = this.exceptRowSet;\n        let ri = 0;\n        let top = inits;\n        let {height} = rows;\n        for (; ri < rows.len; ri += 1) {\n            if (top > y)\n                break;\n            if (!frset.has(ri)) {\n                height = rows.getHeight(ri);\n                top += height;\n            }\n        }\n        top -= height;\n        if (top <= 0) {\n            return {\n                ri: -1,\n                top: 0,\n                height\n            };\n        }\n        return {\n            ri: ri - 1,\n            top,\n            height\n        };\n    }\n    function getCellColByX(x, scrollOffsetx) {\n        const {cols} = this;\n        const fsw = this.freezeTotalWidth();\n        let inits = cols.indexWidth;\n        if (fsw + cols.indexWidth < x)\n            inits -= scrollOffsetx;\n        const [ci, left, width] = helper.rangeReduceIf(0, cols.len, inits, cols.indexWidth, x, i => cols.getWidth(i));\n        if (left <= 0) {\n            return {\n                ci: -1,\n                left: 0,\n                width: cols.indexWidth\n            };\n        }\n        return {\n            ci: ci - 1,\n            left,\n            width\n        };\n    }\n    return class DataProxy {\n        constructor(name, settings) {\n            this.settings = helper.merge(defaultSettings, settings || {});\n            this.name = name || 'sheet';\n            this.freeze = [\n                0,\n                0\n            ];\n            this.styles = [];\n            this.merges = new m_merge.Merges();\n            this.rows = new m_row.Rows(this.settings.row);\n            this.cols = new m_col.Cols(this.settings.col);\n            this.validations = new m_validation.Validations();\n            this.hyperlinks = {};\n            this.comments = {};\n            this.selector = new Selector();\n            this.scroll = new Scroll();\n            this.history = new History();\n            this.clipboard = new Clipboard();\n            this.autoFilter = new AutoFilter();\n            this.change = () => {\n            };\n            this.exceptRowSet = new Set();\n            this.sortedRowMap = new Map();\n            this.unsortedRowMap = new Map();\n        }\n        addValidation(mode, ref, validator) {\n            this.changeData(() => {\n                this.validations.add(mode, ref, validator);\n            });\n        }\n        removeValidation() {\n            const {range} = this.selector;\n            this.changeData(() => {\n                this.validations.remove(range);\n            });\n        }\n        getSelectedValidator() {\n            const {ri, ci} = this.selector;\n            const v = this.validations.get(ri, ci);\n            return v ? v.validator : null;\n        }\n        getSelectedValidation() {\n            const {ri, ci, range} = this.selector;\n            const v = this.validations.get(ri, ci);\n            const ret = { ref: range.toString() };\n            if (v !== null) {\n                ret.mode = v.mode;\n                ret.validator = v.validator;\n            }\n            return ret;\n        }\n        canUndo() {\n            return this.history.canUndo();\n        }\n        canRedo() {\n            return this.history.canRedo();\n        }\n        undo() {\n            this.history.undo(this.getData(), d => {\n                this.setData(d);\n            });\n        }\n        redo() {\n            this.history.redo(this.getData(), d => {\n                this.setData(d);\n            });\n        }\n        copy() {\n            this.clipboard.copy(this.selector.range);\n        }\n        cut() {\n            this.clipboard.cut(this.selector.range);\n        }\n        paste(what = 'all', error = () => {\n        }) {\n            const {clipboard, selector} = this;\n            if (clipboard.isClear())\n                return false;\n            if (!canPaste.call(this, clipboard.range, selector.range, error))\n                return false;\n            this.changeData(() => {\n                if (clipboard.isCopy()) {\n                    copyPaste.call(this, clipboard.range, selector.range, what);\n                } else if (clipboard.isCut()) {\n                    cutPaste.call(this, clipboard.range, selector.range);\n                }\n            });\n            return true;\n        }\n        pasteFromText(txt) {\n            const lines = txt.split('\\r\\n').map(it => it.replace(/\"/g, '').split('\\t'));\n            if (lines.length > 0)\n                lines.length -= 1;\n            const {rows, selector} = this;\n            this.changeData(() => {\n                rows.paste(lines, selector.range);\n            });\n        }\n        autofill(cellRange, what, error = () => {\n        }) {\n            const srcRange = this.selector.range;\n            if (!canPaste.call(this, srcRange, cellRange, error))\n                return false;\n            this.changeData(() => {\n                copyPaste.call(this, srcRange, cellRange, what, true);\n            });\n            return true;\n        }\n        clearClipboard() {\n            this.clipboard.clear();\n        }\n        calSelectedRangeByEnd(ri, ci) {\n            const {selector, rows, cols, merges} = this;\n            let {sri, sci, eri, eci} = selector.range;\n            const cri = selector.ri;\n            const cci = selector.ci;\n            let [nri, nci] = [\n                ri,\n                ci\n            ];\n            if (ri < 0)\n                nri = rows.len - 1;\n            if (ci < 0)\n                nci = cols.len - 1;\n            if (nri > cri)\n                [sri, eri] = [\n                    cri,\n                    nri\n                ];\n            else\n                [sri, eri] = [\n                    nri,\n                    cri\n                ];\n            if (nci > cci)\n                [sci, eci] = [\n                    cci,\n                    nci\n                ];\n            else\n                [sci, eci] = [\n                    nci,\n                    cci\n                ];\n            selector.range = merges.union(new m_cell_range.CellRange(sri, sci, eri, eci));\n            selector.range = merges.union(selector.range);\n            return selector.range;\n        }\n        calSelectedRangeByStart(ri, ci) {\n            const {selector, rows, cols, merges} = this;\n            let cellRange = merges.getFirstIncludes(ri, ci);\n            if (cellRange === null) {\n                cellRange = new m_cell_range.CellRange(ri, ci, ri, ci);\n                if (ri === -1) {\n                    cellRange.sri = 0;\n                    cellRange.eri = rows.len - 1;\n                }\n                if (ci === -1) {\n                    cellRange.sci = 0;\n                    cellRange.eci = cols.len - 1;\n                }\n            }\n            selector.range = cellRange;\n            return cellRange;\n        }\n        setSelectedCellAttr(property, value) {\n            this.changeData(() => {\n                const {selector, styles, rows} = this;\n                if (property === 'merge') {\n                    if (value)\n                        this.merge();\n                    else\n                        this.unmerge();\n                } else if (property === 'border') {\n                    setStyleBorders.call(this, value);\n                } else if (property === 'formula') {\n                    const {ri, ci, range} = selector;\n                    if (selector.multiple()) {\n                        const [rn, cn] = selector.size();\n                        const {sri, sci, eri, eci} = range;\n                        if (rn > 1) {\n                            for (let i = sci; i <= eci; i += 1) {\n                                const cell = rows.getCellOrNew(eri + 1, i);\n                                cell.text = `=${ value }(${ m_alphabet.xy2expr(i, sri) }:${ m_alphabet.xy2expr(i, eri) })`;\n                            }\n                        } else if (cn > 1) {\n                            const cell = rows.getCellOrNew(ri, eci + 1);\n                            cell.text = `=${ value }(${ m_alphabet.xy2expr(sci, ri) }:${ m_alphabet.xy2expr(eci, ri) })`;\n                        }\n                    } else {\n                        const cell = rows.getCellOrNew(ri, ci);\n                        cell.text = `=${ value }()`;\n                    }\n                } else {\n                    selector.range.each((ri, ci) => {\n                        const cell = rows.getCellOrNew(ri, ci);\n                        let cstyle = {};\n                        if (cell.style !== undefined) {\n                            cstyle = helper.cloneDeep(styles[cell.style]);\n                        }\n                        if (property === 'format') {\n                            cstyle.format = value;\n                            cell.style = this.addStyle(cstyle);\n                        } else if (property === 'font-bold' || property === 'font-italic' || property === 'font-name' || property === 'font-size') {\n                            const nfont = {};\n                            nfont[property.split('-')[1]] = value;\n                            cstyle.font = Object.assign(cstyle.font || {}, nfont);\n                            cell.style = this.addStyle(cstyle);\n                        } else if (property === 'strike' || property === 'textwrap' || property === 'underline' || property === 'align' || property === 'valign' || property === 'color' || property === 'bgcolor') {\n                            cstyle[property] = value;\n                            cell.style = this.addStyle(cstyle);\n                        } else {\n                            cell[property] = value;\n                        }\n                    });\n                }\n            });\n        }\n        setSelectedCellText(text, state = 'input') {\n            const {autoFilter, selector, rows} = this;\n            const {ri, ci} = selector;\n            let nri = ri;\n            if (this.unsortedRowMap.has(ri)) {\n                nri = this.unsortedRowMap.get(ri);\n            }\n            const oldCell = rows.getCell(nri, ci);\n            const oldText = oldCell ? oldCell.text : '';\n            this.setCellText(nri, ci, text, state);\n            if (autoFilter.active()) {\n                const filter = autoFilter.getFilter(ci);\n                if (filter) {\n                    const vIndex = filter.value.findIndex(v => v === oldText);\n                    if (vIndex >= 0) {\n                        filter.value.splice(vIndex, 1, text);\n                    }\n                }\n            }\n        }\n        getSelectedCell() {\n            const {ri, ci} = this.selector;\n            let nri = ri;\n            if (this.unsortedRowMap.has(ri)) {\n                nri = this.unsortedRowMap.get(ri);\n            }\n            return this.rows.getCell(nri, ci);\n        }\n        xyInSelectedRect(x, y) {\n            const {left, top, width, height} = this.getSelectedRect();\n            const x1 = x - this.cols.indexWidth;\n            const y1 = y - this.rows.height;\n            return x1 > left && x1 < left + width && y1 > top && y1 < top + height;\n        }\n        getSelectedRect() {\n            return this.getRect(this.selector.range);\n        }\n        getClipboardRect() {\n            const {clipboard} = this;\n            if (!clipboard.isClear()) {\n                return this.getRect(clipboard.range);\n            }\n            return {\n                left: -100,\n                top: -100\n            };\n        }\n        getRect(cellRange) {\n            const {scroll, rows, cols, exceptRowSet} = this;\n            const {sri, sci, eri, eci} = cellRange;\n            if (sri < 0 && sci < 0) {\n                return {\n                    left: 0,\n                    l: 0,\n                    top: 0,\n                    t: 0,\n                    scroll\n                };\n            }\n            const left = cols.sumWidth(0, sci);\n            const top = rows.sumHeight(0, sri, exceptRowSet);\n            const height = rows.sumHeight(sri, eri + 1, exceptRowSet);\n            const width = cols.sumWidth(sci, eci + 1);\n            let left0 = left - scroll.x;\n            let top0 = top - scroll.y;\n            const fsh = this.freezeTotalHeight();\n            const fsw = this.freezeTotalWidth();\n            if (fsw > 0 && fsw > left) {\n                left0 = left;\n            }\n            if (fsh > 0 && fsh > top) {\n                top0 = top;\n            }\n            return {\n                l: left,\n                t: top,\n                left: left0,\n                top: top0,\n                height,\n                width,\n                scroll\n            };\n        }\n        getCellRectByXY(x, y) {\n            const {scroll, merges, rows, cols} = this;\n            let {ri, top, height} = getCellRowByY.call(this, y, scroll.y);\n            let {ci, left, width} = getCellColByX.call(this, x, scroll.x);\n            if (ci === -1) {\n                width = cols.totalWidth();\n            }\n            if (ri === -1) {\n                height = rows.totalHeight();\n            }\n            if (ri >= 0 || ci >= 0) {\n                const merge = merges.getFirstIncludes(ri, ci);\n                if (merge) {\n                    ri = merge.sri;\n                    ci = merge.sci;\n                    ({left, top, width, height} = this.cellRect(ri, ci));\n                }\n            }\n            return {\n                ri,\n                ci,\n                left,\n                top,\n                width,\n                height\n            };\n        }\n        isSignleSelected() {\n            const {sri, sci, eri, eci} = this.selector.range;\n            const cell = this.getCell(sri, sci);\n            if (cell && cell.merge) {\n                const [rn, cn] = cell.merge;\n                if (sri + rn === eri && sci + cn === eci)\n                    return true;\n            }\n            return !this.selector.multiple();\n        }\n        canUnmerge() {\n            const {sri, sci, eri, eci} = this.selector.range;\n            const cell = this.getCell(sri, sci);\n            if (cell && cell.merge) {\n                const [rn, cn] = cell.merge;\n                if (sri + rn === eri && sci + cn === eci)\n                    return true;\n            }\n            return false;\n        }\n        merge() {\n            const {selector, rows} = this;\n            if (this.isSignleSelected())\n                return;\n            const [rn, cn] = selector.size();\n            if (rn > 1 || cn > 1) {\n                const {sri, sci} = selector.range;\n                this.changeData(() => {\n                    const cell = rows.getCellOrNew(sri, sci);\n                    cell.merge = [\n                        rn - 1,\n                        cn - 1\n                    ];\n                    this.merges.add(selector.range);\n                    this.rows.deleteCells(selector.range);\n                    this.rows.setCell(sri, sci, cell);\n                });\n            }\n        }\n        unmerge() {\n            const {selector} = this;\n            if (!this.isSignleSelected())\n                return;\n            const {sri, sci} = selector.range;\n            this.changeData(() => {\n                this.rows.deleteCell(sri, sci, 'merge');\n                this.merges.deleteWithin(selector.range);\n            });\n        }\n        canAutofilter() {\n            return !this.autoFilter.active();\n        }\n        autofilter() {\n            const {autoFilter, selector} = this;\n            this.changeData(() => {\n                if (autoFilter.active()) {\n                    autoFilter.clear();\n                    this.exceptRowSet = new Set();\n                    this.sortedRowMap = new Map();\n                    this.unsortedRowMap = new Map();\n                } else {\n                    autoFilter.ref = selector.range.toString();\n                }\n            });\n        }\n        setAutoFilter(ci, order, operator, value) {\n            const {autoFilter} = this;\n            autoFilter.addFilter(ci, operator, value);\n            autoFilter.setSort(ci, order);\n            this.resetAutoFilter();\n        }\n        resetAutoFilter() {\n            const {autoFilter, rows} = this;\n            if (!autoFilter.active())\n                return;\n            const {sort} = autoFilter;\n            const {rset, fset} = autoFilter.filteredRows((r, c) => rows.getCell(r, c));\n            const fary = Array.from(fset);\n            const oldAry = Array.from(fset);\n            if (sort) {\n                fary.sort((a, b) => {\n                    if (sort.order === 'asc')\n                        return a - b;\n                    if (sort.order === 'desc')\n                        return b - a;\n                    return 0;\n                });\n            }\n            this.exceptRowSet = rset;\n            this.sortedRowMap = new Map();\n            this.unsortedRowMap = new Map();\n            fary.forEach((it, index) => {\n                this.sortedRowMap.set(oldAry[index], it);\n                this.unsortedRowMap.set(it, oldAry[index]);\n            });\n        }\n        deleteCell(what = 'all') {\n            const {selector} = this;\n            this.changeData(() => {\n                this.rows.deleteCells(selector.range, what);\n                if (what === 'all' || what === 'format') {\n                    this.merges.deleteWithin(selector.range);\n                }\n            });\n        }\n        insert(type, n = 1) {\n            this.changeData(() => {\n                const {sri, sci} = this.selector.range;\n                const {rows, merges, cols} = this;\n                let si = sri;\n                if (type === 'row') {\n                    rows.insert(sri, n);\n                } else if (type === 'column') {\n                    rows.insertColumn(sci, n);\n                    si = sci;\n                    cols.len += 1;\n                }\n                merges.shift(type, si, n, (ri, ci, rn, cn) => {\n                    const cell = rows.getCell(ri, ci);\n                    cell.merge[0] += rn;\n                    cell.merge[1] += cn;\n                });\n            });\n        }\n        delete(type) {\n            this.changeData(() => {\n                const {rows, merges, selector, cols} = this;\n                const {range} = selector;\n                const {sri, sci, eri, eci} = selector.range;\n                const [rsize, csize] = selector.range.size();\n                let si = sri;\n                let size = rsize;\n                if (type === 'row') {\n                    rows.delete(sri, eri);\n                } else if (type === 'column') {\n                    rows.deleteColumn(sci, eci);\n                    si = range.sci;\n                    size = csize;\n                    cols.len -= 1;\n                }\n                merges.shift(type, si, -size, (ri, ci, rn, cn) => {\n                    const cell = rows.getCell(ri, ci);\n                    cell.merge[0] += rn;\n                    cell.merge[1] += cn;\n                    if (cell.merge[0] === 0 && cell.merge[1] === 0) {\n                        delete cell.merge;\n                    }\n                });\n            });\n        }\n        scrollx(x, cb) {\n            const {scroll, freeze, cols} = this;\n            const [, fci] = freeze;\n            const [ci, left, width] = helper.rangeReduceIf(fci, cols.len, 0, 0, x, i => cols.getWidth(i));\n            let x1 = left;\n            if (x > 0)\n                x1 += width;\n            if (scroll.x !== x1) {\n                scroll.ci = x > 0 ? ci : 0;\n                scroll.x = x1;\n                cb();\n            }\n        }\n        scrolly(y, cb) {\n            const {scroll, freeze, rows} = this;\n            const [fri] = freeze;\n            const [ri, top, height] = helper.rangeReduceIf(fri, rows.len, 0, 0, y, i => rows.getHeight(i));\n            let y1 = top;\n            if (y > 0)\n                y1 += height;\n            if (scroll.y !== y1) {\n                scroll.ri = y > 0 ? ri : 0;\n                scroll.y = y1;\n                cb();\n            }\n        }\n        cellRect(ri, ci) {\n            const {rows, cols} = this;\n            const left = cols.sumWidth(0, ci);\n            const top = rows.sumHeight(0, ri);\n            const cell = rows.getCell(ri, ci);\n            let width = cols.getWidth(ci);\n            let height = rows.getHeight(ri);\n            if (cell !== null) {\n                if (cell.merge) {\n                    const [rn, cn] = cell.merge;\n                    if (rn > 0) {\n                        for (let i = 1; i <= rn; i += 1) {\n                            height += rows.getHeight(ri + i);\n                        }\n                    }\n                    if (cn > 0) {\n                        for (let i = 1; i <= cn; i += 1) {\n                            width += cols.getWidth(ci + i);\n                        }\n                    }\n                }\n            }\n            return {\n                left,\n                top,\n                width,\n                height,\n                cell\n            };\n        }\n        getCell(ri, ci) {\n            return this.rows.getCell(ri, ci);\n        }\n        getCellTextOrDefault(ri, ci) {\n            const cell = this.getCell(ri, ci);\n            return cell && cell.text ? cell.text : '';\n        }\n        getCellStyle(ri, ci) {\n            const cell = this.getCell(ri, ci);\n            if (cell && cell.style !== undefined) {\n                return this.styles[cell.style];\n            }\n            return null;\n        }\n        getCellStyleOrDefault(ri, ci) {\n            const {styles, rows} = this;\n            const cell = rows.getCell(ri, ci);\n            const cellStyle = cell && cell.style !== undefined ? styles[cell.style] : {};\n            return helper.merge(this.defaultStyle(), cellStyle);\n        }\n        getSelectedCellStyle() {\n            const {ri, ci} = this.selector;\n            return this.getCellStyleOrDefault(ri, ci);\n        }\n        setCellText(ri, ci, text, state) {\n            const {rows, history, validations} = this;\n            if (state === 'finished') {\n                rows.setCellText(ri, ci, '');\n                history.add(this.getData());\n                rows.setCellText(ri, ci, text);\n            } else {\n                rows.setCellText(ri, ci, text);\n                this.change(this.getData());\n            }\n            validations.validate(ri, ci, text);\n        }\n        freezeIsActive() {\n            const [ri, ci] = this.freeze;\n            return ri > 0 || ci > 0;\n        }\n        setFreeze(ri, ci) {\n            this.changeData(() => {\n                this.freeze = [\n                    ri,\n                    ci\n                ];\n            });\n        }\n        freezeTotalWidth() {\n            return this.cols.sumWidth(0, this.freeze[1]);\n        }\n        freezeTotalHeight() {\n            return this.rows.sumHeight(0, this.freeze[0]);\n        }\n        setRowHeight(ri, height) {\n            this.changeData(() => {\n                this.rows.setHeight(ri, height);\n            });\n        }\n        setColWidth(ci, width) {\n            this.changeData(() => {\n                this.cols.setWidth(ci, width);\n            });\n        }\n        viewHeight() {\n            const {view, showToolbar} = this.settings;\n            let h = view.height();\n            h -= bottombarHeight;\n            if (showToolbar) {\n                h -= toolbarHeight;\n            }\n            return h;\n        }\n        viewWidth() {\n            return this.settings.view.width();\n        }\n        freezeViewRange() {\n            const [ri, ci] = this.freeze;\n            return new m_cell_range.CellRange(0, 0, ri - 1, ci - 1, this.freezeTotalWidth(), this.freezeTotalHeight());\n        }\n        contentRange() {\n            const {rows, cols} = this;\n            const [ri, ci] = rows.maxCell();\n            const h = rows.sumHeight(0, ri + 1);\n            const w = cols.sumWidth(0, ci + 1);\n            return new m_cell_range.CellRange(0, 0, ri, ci, w, h);\n        }\n        exceptRowTotalHeight(sri, eri) {\n            const {exceptRowSet, rows} = this;\n            const exceptRows = Array.from(exceptRowSet);\n            let exceptRowTH = 0;\n            exceptRows.forEach(ri => {\n                if (ri < sri || ri > eri) {\n                    const height = rows.getHeight(ri);\n                    exceptRowTH += height;\n                }\n            });\n            return exceptRowTH;\n        }\n        viewRange() {\n            const {scroll, rows, cols, freeze, exceptRowSet} = this;\n            let {ri, ci} = scroll;\n            if (ri <= 0)\n                [ri] = freeze;\n            if (ci <= 0)\n                [, ci] = freeze;\n            let [x, y] = [\n                0,\n                0\n            ];\n            let [eri, eci] = [\n                rows.len,\n                cols.len\n            ];\n            for (let i = ri; i < rows.len; i += 1) {\n                if (!exceptRowSet.has(i)) {\n                    y += rows.getHeight(i);\n                    eri = i;\n                }\n                if (y > this.viewHeight())\n                    break;\n            }\n            for (let j = ci; j < cols.len; j += 1) {\n                x += cols.getWidth(j);\n                eci = j;\n                if (x > this.viewWidth())\n                    break;\n            }\n            return new m_cell_range.CellRange(ri, ci, eri, eci, x, y);\n        }\n        eachMergesInView(viewRange, cb) {\n            this.merges.filterIntersects(viewRange).forEach(it => cb(it));\n        }\n        hideRowsOrCols() {\n            const {rows, cols, selector} = this;\n            const [rlen, clen] = selector.size();\n            const {sri, sci, eri, eci} = selector.range;\n            if (rlen === rows.len) {\n                for (let ci = sci; ci <= eci; ci += 1) {\n                    cols.setHide(ci, true);\n                }\n            } else if (clen === cols.len) {\n                for (let ri = sri; ri <= eri; ri += 1) {\n                    rows.setHide(ri, true);\n                }\n            }\n        }\n        unhideRowsOrCols(type, index) {\n            this[`${ type }s`].unhide(index);\n        }\n        rowEach(min, max, cb) {\n            let y = 0;\n            const {rows} = this;\n            const frset = this.exceptRowSet;\n            const frary = [...frset];\n            let offset = 0;\n            for (let i = 0; i < frary.length; i += 1) {\n                if (frary[i] < min) {\n                    offset += 1;\n                }\n            }\n            for (let i = min + offset; i <= max + offset; i += 1) {\n                if (frset.has(i)) {\n                    offset += 1;\n                } else {\n                    const rowHeight = rows.getHeight(i);\n                    if (rowHeight > 0) {\n                        cb(i, y, rowHeight);\n                        y += rowHeight;\n                        if (y > this.viewHeight())\n                            break;\n                    }\n                }\n            }\n        }\n        colEach(min, max, cb) {\n            let x = 0;\n            const {cols} = this;\n            for (let i = min; i <= max; i += 1) {\n                const colWidth = cols.getWidth(i);\n                if (colWidth > 0) {\n                    cb(i, x, colWidth);\n                    x += colWidth;\n                    if (x > this.viewWidth())\n                        break;\n                }\n            }\n        }\n        defaultStyle() {\n            return this.settings.style;\n        }\n        addStyle(nstyle) {\n            const {styles} = this;\n            for (let i = 0; i < styles.length; i += 1) {\n                const style = styles[i];\n                if (helper.equals(style, nstyle))\n                    return i;\n            }\n            styles.push(nstyle);\n            return styles.length - 1;\n        }\n        changeData(cb) {\n            this.history.add(this.getData());\n            cb();\n            this.change(this.getData());\n        }\n        setData(d) {\n            Object.keys(d).forEach(property => {\n                if (property === 'merges' || property === 'rows' || property === 'cols' || property === 'validations') {\n                    this[property].setData(d[property]);\n                } else if (property === 'freeze') {\n                    const [x, y] = m_alphabet.expr2xy(d[property]);\n                    this.freeze = [\n                        y,\n                        x\n                    ];\n                } else if (property === 'autofilter') {\n                    this.autoFilter.setData(d[property]);\n                } else if (d[property] !== undefined) {\n                    this[property] = d[property];\n                }\n            });\n            return this;\n        }\n        getData() {\n            const {name, freeze, styles, merges, rows, cols, validations, autoFilter} = this;\n            return {\n                name,\n                freeze: m_alphabet.xy2expr(freeze[1], freeze[0]),\n                styles,\n                merges: merges.getData(),\n                rows: rows.getData(),\n                cols: cols.getData(),\n                validations: validations.getData(),\n                autofilter: autoFilter.getData()\n            };\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/event',[],function () {\n    'use strict';\n    function bind(target, name, fn) {\n        target.addEventListener(name, fn);\n    }\n    function unbind(target, name, fn) {\n        target.removeEventListener(name, fn);\n    }\n    function unbindClickoutside(el) {\n        if (el.xclickoutside) {\n            unbind(window.document.body, 'click', el.xclickoutside);\n            delete el.xclickoutside;\n        }\n    }\n    function bindClickoutside(el, cb) {\n        el.xclickoutside = evt => {\n            if (evt.detail === 2 || el.contains(evt.target))\n                return;\n            if (cb)\n                cb(el);\n            else {\n                el.hide();\n                unbindClickoutside(el);\n            }\n        };\n        bind(window.document.body, 'click', el.xclickoutside);\n    }\n    function mouseMoveUp(target, movefunc, upfunc) {\n        bind(target, 'mousemove', movefunc);\n        const t = target;\n        t.xEvtUp = evt => {\n            unbind(target, 'mousemove', movefunc);\n            unbind(target, 'mouseup', target.xEvtUp);\n            upfunc(evt);\n        };\n        bind(target, 'mouseup', target.xEvtUp);\n    }\n    function calTouchDirection(spanx, spany, evt, cb) {\n        let direction = '';\n        if (Math.abs(spanx) > Math.abs(spany)) {\n            direction = spanx > 0 ? 'right' : 'left';\n            cb(direction, spanx, evt);\n        } else {\n            direction = spany > 0 ? 'down' : 'up';\n            cb(direction, spany, evt);\n        }\n    }\n    function bindTouch(target, {move, end}) {\n        let startx = 0;\n        let starty = 0;\n        bind(target, 'touchstart', evt => {\n            const {pageX, pageY} = evt.touches[0];\n            startx = pageX;\n            starty = pageY;\n        });\n        bind(target, 'touchmove', evt => {\n            if (!move)\n                return;\n            const {pageX, pageY} = evt.changedTouches[0];\n            const spanx = pageX - startx;\n            const spany = pageY - starty;\n            if (Math.abs(spanx) > 10 || Math.abs(spany) > 10) {\n                calTouchDirection(spanx, spany, evt, move);\n                startx = pageX;\n                starty = pageY;\n            }\n            evt.preventDefault();\n        });\n        bind(target, 'touchend', evt => {\n            if (!end)\n                return;\n            const {pageX, pageY} = evt.changedTouches[0];\n            const spanx = pageX - startx;\n            const spany = pageY - starty;\n            calTouchDirection(spanx, spany, evt, end);\n        });\n    }\n    return {\n        bind: bind,\n        unbind: unbind,\n        unbindClickoutside: unbindClickoutside,\n        bindClickoutside: bindClickoutside,\n        mouseMoveUp: mouseMoveUp,\n        bindTouch: bindTouch\n    };\n});\ndefine('skylark-xspreadsheet/config',[],function () {\n    'use strict';\n    const cssPrefix = 'x-spreadsheet';\n    const dpr = window.devicePixelRatio || 1;\n    return {\n        cssPrefix,\n        dpr\n    };\n});\ndefine('skylark-xspreadsheet/component/resizer',[\n    './element',\n    './event',\n    '../config'\n], function (m_element, m_event, m_config) {\n    'use strict';\n    return class Resizer {\n        constructor(vertical = false, minDistance) {\n            this.moving = false;\n            this.vertical = vertical;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-resizer ${ vertical ? 'vertical' : 'horizontal' }`).children(this.unhideHoverEl = m_element.h('div', `${ m_config.cssPrefix }-resizer-hover`).on('dblclick.stop', evt => this.mousedblclickHandler(evt)).css('position', 'absolute').hide(), this.hoverEl = m_element.h('div', `${ m_config.cssPrefix }-resizer-hover`).on('mousedown.stop', evt => this.mousedownHandler(evt)), this.lineEl = m_element.h('div', `${ m_config.cssPrefix }-resizer-line`).hide()).hide();\n            this.cRect = null;\n            this.finishedFn = null;\n            this.minDistance = minDistance;\n            this.unhideFn = () => {\n            };\n        }\n        showUnhide(index) {\n            this.unhideIndex = index;\n            this.unhideHoverEl.show();\n        }\n        hideUnhide() {\n            this.unhideHoverEl.hide();\n        }\n        show(rect, line) {\n            const {moving, vertical, hoverEl, lineEl, el, unhideHoverEl} = this;\n            if (moving)\n                return;\n            this.cRect = rect;\n            const {left, top, width, height} = rect;\n            el.offset({\n                left: vertical ? left + width - 5 : left,\n                top: vertical ? top : top + height - 5\n            }).show();\n            hoverEl.offset({\n                width: vertical ? 5 : width,\n                height: vertical ? height : 5\n            });\n            lineEl.offset({\n                width: vertical ? 0 : line.width,\n                height: vertical ? line.height : 0\n            });\n            unhideHoverEl.offset({\n                left: vertical ? 5 - width : left,\n                top: vertical ? top : 5 - height,\n                width: vertical ? 5 : width,\n                height: vertical ? height : 5\n            });\n        }\n        hide() {\n            this.el.offset({\n                left: 0,\n                top: 0\n            }).hide();\n            this.hideUnhide();\n        }\n        mousedblclickHandler() {\n            if (this.unhideIndex)\n                this.unhideFn(this.unhideIndex);\n        }\n        mousedownHandler(evt) {\n            let startEvt = evt;\n            const {el, lineEl, cRect, vertical, minDistance} = this;\n            let distance = vertical ? cRect.width : cRect.height;\n            lineEl.show();\n            m_event.mouseMoveUp(window, e => {\n                this.moving = true;\n                if (startEvt !== null && e.buttons === 1) {\n                    if (vertical) {\n                        distance += e.movementX;\n                        if (distance > minDistance) {\n                            el.css('left', `${ cRect.left + distance }px`);\n                        }\n                    } else {\n                        distance += e.movementY;\n                        if (distance > minDistance) {\n                            el.css('top', `${ cRect.top + distance }px`);\n                        }\n                    }\n                    startEvt = e;\n                }\n            }, () => {\n                startEvt = null;\n                lineEl.hide();\n                this.moving = false;\n                this.hide();\n                if (this.finishedFn) {\n                    if (distance < minDistance)\n                        distance = minDistance;\n                    this.finishedFn(cRect, distance);\n                }\n            });\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/scrollbar',[\n    './element',\n    '../config'\n], function (m_element, m_config) {\n    'use strict';\n    return class Scrollbar {\n        constructor(vertical) {\n            this.vertical = vertical;\n            this.moveFn = null;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-scrollbar ${ vertical ? 'vertical' : 'horizontal' }`).child(this.contentEl = m_element.h('div', '')).on('mousemove.stop', () => {\n            }).on('scroll.stop', evt => {\n                const {scrollTop, scrollLeft} = evt.target;\n                if (this.moveFn) {\n                    this.moveFn(this.vertical ? scrollTop : scrollLeft, evt);\n                }\n            });\n        }\n        move(v) {\n            this.el.scroll(v);\n            return this;\n        }\n        scroll() {\n            return this.el.scroll();\n        }\n        set(distance, contentDistance) {\n            const d = distance - 1;\n            if (contentDistance > d) {\n                const cssKey = this.vertical ? 'height' : 'width';\n                this.el.css(cssKey, `${ d - 15 }px`).show();\n                this.contentEl.css(this.vertical ? 'width' : 'height', '1px').css(cssKey, `${ contentDistance }px`);\n            } else {\n                this.el.hide();\n            }\n            return this;\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/selector',[\n    './element',\n    '../config',\n    '../core/cell_range'\n], function (m_element, m_config, m_cell_range) {\n    'use strict';\n    const selectorHeightBorderWidth = 2 * 2 - 1;\n    let startZIndex = 10;\n    class SelectorElement {\n        constructor(useHideInput = false) {\n            this.useHideInput = useHideInput;\n            this.inputChange = () => {\n            };\n            this.cornerEl = m_element.h('div', `${ m_config.cssPrefix }-selector-corner`);\n            this.areaEl = m_element.h('div', `${ m_config.cssPrefix }-selector-area`).child(this.cornerEl).hide();\n            this.clipboardEl = m_element.h('div', `${ m_config.cssPrefix }-selector-clipboard`).hide();\n            this.autofillEl = m_element.h('div', `${ m_config.cssPrefix }-selector-autofill`).hide();\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-selector`).css('z-index', `${ startZIndex }`).children(this.areaEl, this.clipboardEl, this.autofillEl).hide();\n            if (useHideInput) {\n                this.hideInput = m_element.h('input', '').on('compositionend', evt => {\n                    this.inputChange(evt.target.value);\n                });\n                this.el.child(this.hideInputDiv = m_element.h('div', 'hide-input').child(this.hideInput));\n                this.el.child(this.hideInputDiv = m_element.h('div', 'hide-input').child(this.hideInput));\n            }\n            startZIndex += 1;\n        }\n        setOffset(v) {\n            this.el.offset(v).show();\n            return this;\n        }\n        hide() {\n            this.el.hide();\n            return this;\n        }\n        setAreaOffset(v) {\n            const {left, top, width, height} = v;\n            const of = {\n                width: width - selectorHeightBorderWidth + 0.8,\n                height: height - selectorHeightBorderWidth + 0.8,\n                left: left - 0.8,\n                top: top - 0.8\n            };\n            this.areaEl.offset(of).show();\n            if (this.useHideInput) {\n                this.hideInputDiv.offset(of);\n                this.hideInput.val('').focus();\n            }\n        }\n        setClipboardOffset(v) {\n            const {left, top, width, height} = v;\n            this.clipboardEl.offset({\n                left,\n                top,\n                width: width - 5,\n                height: height - 5\n            });\n        }\n        showAutofill(v) {\n            const {left, top, width, height} = v;\n            this.autofillEl.offset({\n                width: width - selectorHeightBorderWidth,\n                height: height - selectorHeightBorderWidth,\n                left,\n                top\n            }).show();\n        }\n        hideAutofill() {\n            this.autofillEl.hide();\n        }\n        showClipboard() {\n            this.clipboardEl.show();\n        }\n        hideClipboard() {\n            this.clipboardEl.hide();\n        }\n    }\n    function calBRAreaOffset(offset) {\n        const {data} = this;\n        const {left, top, width, height, scroll, l, t} = offset;\n        const ftwidth = data.freezeTotalWidth();\n        const ftheight = data.freezeTotalHeight();\n        let left0 = left - ftwidth;\n        if (ftwidth > l)\n            left0 -= scroll.x;\n        let top0 = top - ftheight;\n        if (ftheight > t)\n            top0 -= scroll.y;\n        return {\n            left: left0,\n            top: top0,\n            width,\n            height\n        };\n    }\n    function calTAreaOffset(offset) {\n        const {data} = this;\n        const {left, width, height, l, t, scroll} = offset;\n        const ftwidth = data.freezeTotalWidth();\n        let left0 = left - ftwidth;\n        if (ftwidth > l)\n            left0 -= scroll.x;\n        return {\n            left: left0,\n            top: t,\n            width,\n            height\n        };\n    }\n    function calLAreaOffset(offset) {\n        const {data} = this;\n        const {top, width, height, l, t, scroll} = offset;\n        const ftheight = data.freezeTotalHeight();\n        let top0 = top - ftheight;\n        if (ftheight > t)\n            top0 -= scroll.y;\n        return {\n            left: l,\n            top: top0,\n            width,\n            height\n        };\n    }\n    function setBRAreaOffset(offset) {\n        const {br} = this;\n        br.setAreaOffset(calBRAreaOffset.call(this, offset));\n    }\n    function setTLAreaOffset(offset) {\n        const {tl} = this;\n        tl.setAreaOffset(offset);\n    }\n    function setTAreaOffset(offset) {\n        const {t} = this;\n        t.setAreaOffset(calTAreaOffset.call(this, offset));\n    }\n    function setLAreaOffset(offset) {\n        const {l} = this;\n        l.setAreaOffset(calLAreaOffset.call(this, offset));\n    }\n    function setLClipboardOffset(offset) {\n        const {l} = this;\n        l.setClipboardOffset(calLAreaOffset.call(this, offset));\n    }\n    function setBRClipboardOffset(offset) {\n        const {br} = this;\n        br.setClipboardOffset(calBRAreaOffset.call(this, offset));\n    }\n    function setTLClipboardOffset(offset) {\n        const {tl} = this;\n        tl.setClipboardOffset(offset);\n    }\n    function setTClipboardOffset(offset) {\n        const {t} = this;\n        t.setClipboardOffset(calTAreaOffset.call(this, offset));\n    }\n    function setAllAreaOffset(offset) {\n        setBRAreaOffset.call(this, offset);\n        setTLAreaOffset.call(this, offset);\n        setTAreaOffset.call(this, offset);\n        setLAreaOffset.call(this, offset);\n    }\n    function setAllClipboardOffset(offset) {\n        setBRClipboardOffset.call(this, offset);\n        setTLClipboardOffset.call(this, offset);\n        setTClipboardOffset.call(this, offset);\n        setLClipboardOffset.call(this, offset);\n    }\n    return class Selector {\n        constructor(data) {\n            this.inputChange = () => {\n            };\n            this.data = data;\n            this.br = new SelectorElement(true);\n            this.t = new SelectorElement();\n            this.l = new SelectorElement();\n            this.tl = new SelectorElement();\n            this.br.inputChange = v => {\n                this.inputChange(v);\n            };\n            this.br.el.show();\n            this.offset = null;\n            this.areaOffset = null;\n            this.indexes = null;\n            this.range = null;\n            this.arange = null;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-selectors`).children(this.tl.el, this.t.el, this.l.el, this.br.el).hide();\n            this.lastri = -1;\n            this.lastci = -1;\n            startZIndex += 1;\n        }\n        resetData(data) {\n            this.data = data;\n            this.range = data.selector.range;\n            this.resetAreaOffset();\n        }\n        hide() {\n            this.el.hide();\n        }\n        resetOffset() {\n            const {data, tl, t, l, br} = this;\n            const freezeHeight = data.freezeTotalHeight();\n            const freezeWidth = data.freezeTotalWidth();\n            if (freezeHeight > 0 || freezeWidth > 0) {\n                tl.setOffset({\n                    width: freezeWidth,\n                    height: freezeHeight\n                });\n                t.setOffset({\n                    left: freezeWidth,\n                    height: freezeHeight\n                });\n                l.setOffset({\n                    top: freezeHeight,\n                    width: freezeWidth\n                });\n                br.setOffset({\n                    left: freezeWidth,\n                    top: freezeHeight\n                });\n            } else {\n                tl.hide();\n                t.hide();\n                l.hide();\n                br.setOffset({\n                    left: 0,\n                    top: 0\n                });\n            }\n        }\n        resetAreaOffset() {\n            const offset = this.data.getSelectedRect();\n            const coffset = this.data.getClipboardRect();\n            setAllAreaOffset.call(this, offset);\n            setAllClipboardOffset.call(this, coffset);\n            this.resetOffset();\n        }\n        resetBRTAreaOffset() {\n            const offset = this.data.getSelectedRect();\n            const coffset = this.data.getClipboardRect();\n            setBRAreaOffset.call(this, offset);\n            setTAreaOffset.call(this, offset);\n            setBRClipboardOffset.call(this, coffset);\n            setTClipboardOffset.call(this, coffset);\n            this.resetOffset();\n        }\n        resetBRLAreaOffset() {\n            const offset = this.data.getSelectedRect();\n            const coffset = this.data.getClipboardRect();\n            setBRAreaOffset.call(this, offset);\n            setLAreaOffset.call(this, offset);\n            setBRClipboardOffset.call(this, coffset);\n            setLClipboardOffset.call(this, coffset);\n            this.resetOffset();\n        }\n        set(ri, ci, indexesUpdated = true) {\n            const {data} = this;\n            const cellRange = data.calSelectedRangeByStart(ri, ci);\n            const {sri, sci} = cellRange;\n            if (indexesUpdated) {\n                let [cri, cci] = [\n                    ri,\n                    ci\n                ];\n                if (ri < 0)\n                    cri = 0;\n                if (ci < 0)\n                    cci = 0;\n                data.selector.setIndexes(cri, cci);\n                this.indexes = [\n                    cri,\n                    cci\n                ];\n            }\n            this.moveIndexes = [\n                sri,\n                sci\n            ];\n            this.range = cellRange;\n            this.resetAreaOffset();\n            this.el.show();\n        }\n        setEnd(ri, ci, moving = true) {\n            const {data, lastri, lastci} = this;\n            if (moving) {\n                if (ri === lastri && ci === lastci)\n                    return;\n                this.lastri = ri;\n                this.lastci = ci;\n            }\n            this.range = data.calSelectedRangeByEnd(ri, ci);\n            setAllAreaOffset.call(this, this.data.getSelectedRect());\n        }\n        reset() {\n            const {eri, eci} = this.data.selector.range;\n            this.setEnd(eri, eci);\n        }\n        showAutofill(ri, ci) {\n            if (ri === -1 && ci === -1)\n                return;\n            const {sri, sci, eri, eci} = this.range;\n            const [nri, nci] = [\n                ri,\n                ci\n            ];\n            const srn = sri - ri;\n            const scn = sci - ci;\n            const ern = eri - ri;\n            const ecn = eci - ci;\n            if (scn > 0) {\n                this.arange = new m_cell_range.CellRange(sri, nci, eri, sci - 1);\n            } else if (srn > 0) {\n                this.arange = new m_cell_range.CellRange(nri, sci, sri - 1, eci);\n            } else if (ecn < 0) {\n                this.arange = new m_cell_range.CellRange(sri, eci + 1, eri, nci);\n            } else if (ern < 0) {\n                this.arange = new m_cell_range.CellRange(eri + 1, sci, nri, eci);\n            } else {\n                this.arange = null;\n                return;\n            }\n            if (this.arange !== null) {\n                const offset = this.data.getRect(this.arange);\n                offset.width += 2;\n                offset.height += 2;\n                const {br, l, t, tl} = this;\n                br.showAutofill(calBRAreaOffset.call(this, offset));\n                l.showAutofill(calLAreaOffset.call(this, offset));\n                t.showAutofill(calTAreaOffset.call(this, offset));\n                tl.showAutofill(offset);\n            }\n        }\n        hideAutofill() {\n            [\n                'br',\n                'l',\n                't',\n                'tl'\n            ].forEach(property => {\n                this[property].hideAutofill();\n            });\n        }\n        showClipboard() {\n            const coffset = this.data.getClipboardRect();\n            setAllClipboardOffset.call(this, coffset);\n            [\n                'br',\n                'l',\n                't',\n                'tl'\n            ].forEach(property => {\n                this[property].showClipboard();\n            });\n        }\n        hideClipboard() {\n            [\n                'br',\n                'l',\n                't',\n                'tl'\n            ].forEach(property => {\n                this[property].hideClipboard();\n            });\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/suggest',[\n    './element',\n    './event',\n    '../config'\n], function (m_element, m_event, m_config) {\n    'use strict';\n    function inputMovePrev(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        const {filterItems} = this;\n        if (filterItems.length <= 0)\n            return;\n        if (this.itemIndex >= 0)\n            filterItems[this.itemIndex].toggle();\n        this.itemIndex -= 1;\n        if (this.itemIndex < 0) {\n            this.itemIndex = filterItems.length - 1;\n        }\n        filterItems[this.itemIndex].toggle();\n    }\n    function inputMoveNext(evt) {\n        evt.stopPropagation();\n        const {filterItems} = this;\n        if (filterItems.length <= 0)\n            return;\n        if (this.itemIndex >= 0)\n            filterItems[this.itemIndex].toggle();\n        this.itemIndex += 1;\n        if (this.itemIndex > filterItems.length - 1) {\n            this.itemIndex = 0;\n        }\n        filterItems[this.itemIndex].toggle();\n    }\n    function inputEnter(evt) {\n        evt.preventDefault();\n        const {filterItems} = this;\n        if (filterItems.length <= 0)\n            return;\n        evt.stopPropagation();\n        if (this.itemIndex < 0)\n            this.itemIndex = 0;\n        filterItems[this.itemIndex].el.click();\n        this.hide();\n    }\n    function inputKeydownHandler(evt) {\n        const {keyCode} = evt;\n        if (evt.ctrlKey) {\n            evt.stopPropagation();\n        }\n        switch (keyCode) {\n        case 37: // left\n            evt.stopPropagation();\n            break;\n        case 38: // up\n          inputMovePrev.call(this, evt);\n          break;\n        case 39: // right\n          evt.stopPropagation();\n          break;\n        case 40: // down\n          inputMoveNext.call(this, evt);\n          break;\n        case 13: // enter\n          inputEnter.call(this, evt);\n          break;\n        case 9:\n          inputEnter.call(this, evt);\n            break;\n        default:\n            evt.stopPropagation();\n            break;\n        }\n    }\n    class Suggest {\n        constructor(items, itemClick, width = '200px') {\n            this.filterItems = [];\n            this.items = items;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-suggest`).css('width', width).hide();\n            this.itemClick = itemClick;\n            this.itemIndex = -1;\n        }\n        setOffset(v) {\n            this.el.cssRemoveKeys('top', 'bottom').offset(v);\n        }\n        hide() {\n            const {el} = this;\n            this.filterItems = [];\n            this.itemIndex = -1;\n            el.hide();\n            m_event.unbindClickoutside(this.el.parent());\n        }\n        setItems(items) {\n            this.items = items;\n        }\n        search(word) {\n            let {items} = this;\n            if (!/^\\s*$/.test(word)) {\n                items = items.filter(it => (it.key || it).startsWith(word.toUpperCase()));\n            }\n            items = items.map(it => {\n                let {title} = it;\n                if (title) {\n                    if (typeof title === 'function') {\n                        title = title();\n                    }\n                } else {\n                    title = it;\n                }\n                const item = m_element.h('div', `${ m_config.cssPrefix }-item`).child(title).on('click.stop', () => {\n                    this.itemClick(it);\n                    this.hide();\n                });\n                if (it.label) {\n                    item.child(m_element.h('div', 'label').html(it.label));\n                }\n                return item;\n            });\n            this.filterItems = items;\n            if (items.length <= 0) {\n                return;\n            }\n            const {el} = this;\n            el.html('').children(...items).show();\n            m_event.bindClickoutside(el.parent(), () => {\n                this.hide();\n            });\n        }\n        bindInputEvents(input) {\n            input.on('keydown', evt => inputKeydownHandler.call(this, evt));\n        }\n    }\n\n    return Suggest;\n});\ndefine('skylark-xspreadsheet/component/icon',[\n    './element',\n    '../config'\n], function (m_element, m_config) {\n    'use strict';\n    return class Icon extends m_element.Element {\n        constructor(name) {\n            super('div', `${ m_config.cssPrefix }-icon`);\n            this.iconNameEl = m_element.h('div', `${ m_config.cssPrefix }-icon-img ${ name }`);\n            this.child(this.iconNameEl);\n        }\n        setName(name) {\n            this.iconNameEl.className(`${ m_config.cssPrefix }-icon-img ${ name }`);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/calendar',[\n    './element',\n    './icon',\n    '../locale/locale'\n], function (m_element, Icon, m_locale) {\n    'use strict';\n    function addMonth(date, step) {\n        date.setMonth(date.getMonth() + step);\n    }\n    function weekday(date, index) {\n        const d = new Date(date);\n        d.setDate(index - date.getDay() + 1);\n        return d;\n    }\n    function monthDays(year, month, cdate) {\n        const startDate = new Date(year, month, 1, 23, 59, 59);\n        const datess = [\n            [],\n            [],\n            [],\n            [],\n            [],\n            []\n        ];\n        for (let i = 0; i < 6; i += 1) {\n            for (let j = 0; j < 7; j += 1) {\n                const index = i * 7 + j;\n                const d = weekday(startDate, index);\n                const disabled = d.getMonth() !== month;\n                const active = d.getMonth() === cdate.getMonth() && d.getDate() === cdate.getDate();\n                datess[i][j] = {\n                    d,\n                    disabled,\n                    active\n                };\n            }\n        }\n        return datess;\n    }\n    \n\n    class Calendar {\n        constructor(value) {\n            this.value = value;\n            this.cvalue = new Date(value);\n            this.headerLeftEl = m_element.h('div', 'calendar-header-left');\n            this.bodyEl = m_element.h('tbody', '');\n            this.buildAll();\n            this.el = m_element.h('div', 'x-spreadsheet-calendar').children(m_element.h('div', 'calendar-header').children(this.headerLeftEl, m_element.h('div', 'calendar-header-right').children(m_element.h('m_element', 'calendar-prev').on('click.stop', () => this.prev()).child(new Icon('chevron-left')), m_element.h('m_element', 'calendar-next').on('click.stop', () => this.next()).child(new Icon('chevron-right')))), m_element.h('table', 'calendar-body').children(m_element.h('thead', '').child(m_element.h('tr', '').children(...m_locale.t('calendar.weeks').map(week => m_element.h('th', 'cell').child(week)))), this.bodyEl));\n            this.selectChange = () => {\n            };\n        }\n        setValue(value) {\n            this.value = value;\n            this.cvalue = new Date(value);\n            this.buildAll();\n        }\n        prev() {\n            const {value} = this;\n            addMonth(value, -1);\n            this.buildAll();\n        }\n        next() {\n            const {value} = this;\n            addMonth(value, 1);\n            this.buildAll();\n        }\n        buildAll() {\n            this.buildHeaderLeft();\n            this.buildBody();\n        }\n        buildHeaderLeft() {\n            const {value} = this;\n            this.headerLeftEl.html(`${ m_locale.t('calendar.months')[value.getMonth()] } ${ value.getFullYear() }`);\n        }\n        buildBody() {\n            const {value, cvalue, bodyEl} = this;\n            const mDays = monthDays(value.getFullYear(), value.getMonth(), cvalue);\n            const trs = mDays.map(it => {\n                const tds = it.map(it1 => {\n                    let cls = 'cell';\n                    if (it1.disabled)\n                        cls += ' disabled';\n                    if (it1.active)\n                        cls += ' active';\n                    return m_element.h('td', '').child(m_element.h('div', cls).on('click.stop', () => {\n                        this.selectChange(it1.d);\n                    }).child(it1.d.getDate().toString()));\n                });\n                return m_element.h('tr', '').children(...tds);\n            });\n            bodyEl.html('').children(...trs);\n        }\n    }\n\n    return Calendar;\n});\ndefine('skylark-xspreadsheet/component/datepicker',[\n    './calendar',\n    './element',\n    '../config'\n], function (Calendar, m_element, m_config) {\n    'use strict';\n    return class Datepicker {\n        constructor() {\n            this.calendar = new Calendar(new Date());\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-datepicker`).child(this.calendar.el).hide();\n        }\n        setValue(date) {\n            const {calendar} = this;\n            if (typeof date === 'string') {\n                if (/^\\d{4}-\\d{1,2}-\\d{1,2}$/.test(date)) {\n                    calendar.setValue(new Date(date.replace(new RegExp('-', 'g'), '/')));\n                }\n            } else if (date instanceof Date) {\n                calendar.setValue(date);\n            }\n            return this;\n        }\n        change(cb) {\n            this.calendar.selectChange = d => {\n                cb(d);\n                this.hide();\n            };\n        }\n        show() {\n            this.el.show();\n        }\n        hide() {\n            this.el.hide();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/editor',[\n    './element',\n    './suggest',\n    './datepicker',\n    '../config'\n], function (m_element, Suggest, Datepicker, m_config) {\n    'use strict';\n    function resetTextareaSize() {\n        const {inputText} = this;\n        if (!/^\\s*$/.test(inputText)) {\n            const {textlineEl, textEl, areaOffset} = this;\n            const txts = inputText.split('\\n');\n            const maxTxtSize = Math.max(...txts.map(it => it.length));\n            const tlOffset = textlineEl.offset();\n            const fontWidth = tlOffset.width / inputText.length;\n            const tlineWidth = (maxTxtSize + 1) * fontWidth + 5;\n            const maxWidth = this.viewFn().width - areaOffset.left - fontWidth;\n            let h1 = txts.length;\n            if (tlineWidth > areaOffset.width) {\n                let twidth = tlineWidth;\n                if (tlineWidth > maxWidth) {\n                    twidth = maxWidth;\n                    h1 += parseInt(tlineWidth / maxWidth, 10);\n                    h1 += tlineWidth % maxWidth > 0 ? 1 : 0;\n                }\n                textEl.css('width', `${ twidth }px`);\n            }\n            h1 *= this.rowHeight;\n            if (h1 > areaOffset.height) {\n                textEl.css('height', `${ h1 }px`);\n            }\n        }\n    }\n    function insertText({target}, itxt) {\n        const {value, selectionEnd} = target;\n        const ntxt = `${ value.slice(0, selectionEnd) }${ itxt }${ value.slice(selectionEnd) }`;\n        target.value = ntxt;\n        target.setSelectionRange(selectionEnd + 1, selectionEnd + 1);\n        this.inputText = ntxt;\n        this.textlineEl.html(ntxt);\n        resetTextareaSize.call(this);\n    }\n    function keydownEventHandler(evt) {\n        const {keyCode, altKey} = evt;\n        if (keyCode !== 13 && keyCode !== 9)\n            evt.stopPropagation();\n        if (keyCode === 13 && altKey) {\n            insertText.call(this, evt, '\\n');\n            evt.stopPropagation();\n        }\n        if (keyCode === 13 && !altKey)\n            evt.preventDefault();\n    }\n    function inputEventHandler(evt) {\n        const v = evt.target.value;\n        const {suggest, textlineEl, validator} = this;\n        const {cell} = this;\n        if (cell !== null) {\n            if ('editable' in cell && cell.editable === true || cell.editable === undefined) {\n                this.inputText = v;\n                if (validator) {\n                    if (validator.type === 'list') {\n                        suggest.search(v);\n                    } else {\n                        suggest.hide();\n                    }\n                } else {\n                    const start = v.lastIndexOf('=');\n                    if (start !== -1) {\n                        suggest.search(v.substring(start + 1));\n                    } else {\n                        suggest.hide();\n                    }\n                }\n                textlineEl.html(v);\n                resetTextareaSize.call(this);\n                this.change('input', v);\n            } else {\n                evt.target.value = '';\n            }\n        } else {\n            this.inputText = v;\n            if (validator) {\n                if (validator.type === 'list') {\n                    suggest.search(v);\n                } else {\n                    suggest.hide();\n                }\n            } else {\n                const start = v.lastIndexOf('=');\n                if (start !== -1) {\n                    suggest.search(v.substring(start + 1));\n                } else {\n                    suggest.hide();\n                }\n            }\n            textlineEl.html(v);\n            resetTextareaSize.call(this);\n            this.change('input', v);\n        }\n    }\n    function setTextareaRange(position) {\n        const {el} = this.textEl;\n        setTimeout(() => {\n            el.focus();\n            el.setSelectionRange(position, position);\n        }, 0);\n    }\n    function setText(text, position) {\n        const {textEl, textlineEl} = this;\n        textEl.el.blur();\n        textEl.val(text);\n        textlineEl.html(text);\n        setTextareaRange.call(this, position);\n    }\n    function suggestItemClick(it) {\n        const {inputText, validator} = this;\n        let position = 0;\n        if (validator && validator.type === 'list') {\n            this.inputText = it;\n            position = this.inputText.length;\n        } else {\n            const start = inputText.lastIndexOf('=');\n            const sit = inputText.substring(0, start + 1);\n            let eit = inputText.substring(start + 1);\n            if (eit.indexOf(')') !== -1) {\n                eit = eit.substring(eit.indexOf(')'));\n            } else {\n                eit = '';\n            }\n            this.inputText = `${ sit + it.key }(`;\n            position = this.inputText.length;\n            this.inputText += `)${ eit }`;\n        }\n        setText.call(this, this.inputText, position);\n    }\n    function resetSuggestItems() {\n        this.suggest.setItems(this.formulas);\n    }\n    function dateFormat(d) {\n        let month = d.getMonth() + 1;\n        let date = d.getDate();\n        if (month < 10)\n            month = `0${ month }`;\n        if (date < 10)\n            date = `0${ date }`;\n        return `${ d.getFullYear() }-${ month }-${ date }`;\n    }\n    return class Editor {\n        constructor(formulas, viewFn, rowHeight) {\n            this.viewFn = viewFn;\n            this.rowHeight = rowHeight;\n            this.formulas = formulas;\n            this.suggest = new Suggest(formulas, it => {\n                suggestItemClick.call(this, it);\n            });\n            this.datepicker = new Datepicker();\n            this.datepicker.change(d => {\n                this.setText(dateFormat(d));\n                this.clear();\n            });\n            this.areaEl = m_element.h('div', `${ m_config.cssPrefix }-editor-area`).children(this.textEl = m_element.h('textarea', '').on('input', evt => inputEventHandler.call(this, evt)).on('paste.stop', () => {\n            }).on('keydown', evt => keydownEventHandler.call(this, evt)), this.textlineEl = m_element.h('div', 'textline'), this.suggest.el, this.datepicker.el).on('mousemove.stop', () => {\n            }).on('mousedown.stop', () => {\n            });\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-editor`).child(this.areaEl).hide();\n            this.suggest.bindInputEvents(this.textEl);\n            this.areaOffset = null;\n            this.freeze = {\n                w: 0,\n                h: 0\n            };\n            this.cell = null;\n            this.inputText = '';\n            this.change = () => {\n            };\n        }\n        setFreezeLengths(width, height) {\n            this.freeze.w = width;\n            this.freeze.undefined = height;\n        }\n        clear() {\n            if (this.inputText !== '') {\n                this.change('finished', this.inputText);\n            }\n            this.cell = null;\n            this.areaOffset = null;\n            this.inputText = '';\n            this.el.hide();\n            this.textEl.val('');\n            this.textlineEl.html('');\n            resetSuggestItems.call(this);\n            this.datepicker.hide();\n        }\n        setOffset(offset, suggestPosition = 'top') {\n            const {textEl, areaEl, suggest, freeze, el} = this;\n            if (offset) {\n                this.areaOffset = offset;\n                const {left, top, width, height, l, t} = offset;\n                const elOffset = {\n                    left: 0,\n                    top: 0\n                };\n                if (freeze.w > l && freeze.undefined > t) {\n                } else if (freeze.w < l && freeze.undefined < t) {\n                    elOffset.left = freeze.w;\n                    elOffset.top = freeze.undefined;\n                } else if (freeze.w > l) {\n                    elOffset.top = freeze.undefined;\n                } else if (freeze.undefined > t) {\n                    elOffset.left = freeze.w;\n                }\n                el.offset(elOffset);\n                areaEl.offset({\n                    left: left - elOffset.left - 0.8,\n                    top: top - elOffset.top - 0.8\n                });\n                textEl.offset({\n                    width: width - 9 + 0.8,\n                    height: height - 3 + 0.8\n                });\n                const sOffset = { left: 0 };\n                sOffset[suggestPosition] = height;\n                suggest.setOffset(sOffset);\n                suggest.hide();\n            }\n        }\n        setCell(cell, validator) {\n            const {el, datepicker, suggest} = this;\n            el.show();\n            this.cell = cell;\n            const text = cell && cell.text || '';\n            this.setText(text);\n            this.validator = validator;\n            if (validator) {\n                const {type} = validator;\n                if (type === 'date') {\n                    datepicker.show();\n                    if (!/^\\s*$/.test(text)) {\n                        datepicker.setValue(text);\n                    }\n                }\n                if (type === 'list') {\n                    suggest.setItems(validator.values());\n                    suggest.search('');\n                }\n            }\n        }\n        setText(text) {\n            this.inputText = text;\n            setText.call(this, text, text.length);\n            resetTextareaSize.call(this);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/button',[\n    './element',\n    '../config',\n    '../locale/locale'\n], function (m_element, m_config, m_locale) {\n    'use strict';\n    return class Button extends m_element.Element {\n        constructor(title, type = '') {\n            super('div', `${ m_config.cssPrefix }-button ${ type }`);\n            this.child(m_locale.t(`button.${ title }`));\n        }\n    };\n});\ndefine('skylark-xspreadsheet/canvas/draw',[],function () {\n    'use strict';\n    function dpr() {\n        return window.devicePixelRatio || 1;\n    }\n    function thinLineWidth() {\n        return dpr() - 0.5;\n    }\n    function npx(px) {\n        return parseInt(px * dpr(), 10);\n    }\n    function npxLine(px) {\n        const n = npx(px);\n        return n > 0 ? n - 0.5 : 0.5;\n    }\n    class DrawBox {\n        constructor(x, y, w, h, padding = 0) {\n            this.x = x;\n            this.y = y;\n            this.width = w;\n            this.height = h;\n            this.padding = padding;\n            this.bgcolor = '#ffffff';\n            this.borderTop = null;\n            this.borderRight = null;\n            this.borderBottom = null;\n            this.borderLeft = null;\n        }\n        setBorders({top, bottom, left, right}) {\n            if (top)\n                this.borderTop = top;\n            if (right)\n                this.borderRight = right;\n            if (bottom)\n                this.borderBottom = bottom;\n            if (left)\n                this.borderLeft = left;\n        }\n        innerWidth() {\n            return this.width - this.padding * 2 - 2;\n        }\n        innerHeight() {\n            return this.height - this.padding * 2 - 2;\n        }\n        textx(align) {\n            const {width, padding} = this;\n            let {x} = this;\n            if (align === 'left') {\n                x += padding;\n            } else if (align === 'center') {\n                x += width / 2;\n            } else if (align === 'right') {\n                x += width - padding;\n            }\n            return x;\n        }\n        texty(align, h) {\n            const {height, padding} = this;\n            let {y} = this;\n            if (align === 'top') {\n                y += padding;\n            } else if (align === 'middle') {\n                y += height / 2 - h / 2;\n            } else if (align === 'bottom') {\n                y += height - padding - h;\n            }\n            return y;\n        }\n        topxys() {\n            const {x, y, width} = this;\n            return [\n                [\n                    x,\n                    y\n                ],\n                [\n                    x + width,\n                    y\n                ]\n            ];\n        }\n        rightxys() {\n            const {x, y, width, height} = this;\n            return [\n                [\n                    x + width,\n                    y\n                ],\n                [\n                    x + width,\n                    y + height\n                ]\n            ];\n        }\n        bottomxys() {\n            const {x, y, width, height} = this;\n            return [\n                [\n                    x,\n                    y + height\n                ],\n                [\n                    x + width,\n                    y + height\n                ]\n            ];\n        }\n        leftxys() {\n            const {x, y, height} = this;\n            return [\n                [\n                    x,\n                    y\n                ],\n                [\n                    x,\n                    y + height\n                ]\n            ];\n        }\n    }\n    function drawFontLine(type, tx, ty, align, valign, blheight, blwidth) {\n        const floffset = {\n            x: 0,\n            y: 0\n        };\n        if (type === 'underline') {\n            if (valign === 'bottom') {\n                floffset.y = 0;\n            } else if (valign === 'top') {\n                floffset.y = -(blheight + 2);\n            } else {\n                floffset.y = -blheight / 2;\n            }\n        } else if (type === 'strike') {\n            if (valign === 'bottom') {\n                floffset.y = blheight / 2;\n            } else if (valign === 'top') {\n                floffset.y = -(blheight / 2 + 2);\n            }\n        }\n        if (align === 'center') {\n            floffset.x = blwidth / 2;\n        } else if (align === 'right') {\n            floffset.x = blwidth;\n        }\n        this.line([\n            tx - floffset.x,\n            ty - floffset.y\n        ], [\n            tx - floffset.x + blwidth,\n            ty - floffset.y\n        ]);\n    }\n    class Draw {\n        constructor(el, width, height) {\n            this.el = el;\n            this.ctx = el.getContext('2d');\n            this.resize(width, height);\n            this.ctx.scale(dpr(), dpr());\n        }\n        resize(width, height) {\n            this.el.style.width = `${ width }px`;\n            this.el.style.height = `${ height }px`;\n            this.el.width = npx(width);\n            this.el.height = npx(height);\n        }\n        clear() {\n            const {width, height} = this.el;\n            this.ctx.clearRect(0, 0, width, height);\n            return this;\n        }\n        attr(options) {\n            Object.assign(this.ctx, options);\n            return this;\n        }\n        save() {\n            this.ctx.save();\n            this.ctx.beginPath();\n            return this;\n        }\n        restore() {\n            this.ctx.restore();\n            return this;\n        }\n        beginPath() {\n            this.ctx.beginPath();\n            return this;\n        }\n        translate(x, y) {\n            this.ctx.translate(npx(x), npx(y));\n            return this;\n        }\n        scale(x, y) {\n            this.ctx.scale(x, y);\n            return this;\n        }\n        clearRect(x, y, w, h) {\n            this.ctx.clearRect(x, y, w, h);\n            return this;\n        }\n        fillRect(x, y, w, h) {\n            this.ctx.fillRect(npx(x) - 0.5, npx(y) - 0.5, npx(w), npx(h));\n            return this;\n        }\n        fillText(text, x, y) {\n            this.ctx.fillText(text, npx(x), npx(y));\n            return this;\n        }\n        text(mtxt, box, attr = {}, textWrap = true) {\n            const {ctx} = this;\n            const {align, valign, font, color, strike, underline} = attr;\n            const tx = box.textx(align);\n            ctx.save();\n            ctx.beginPath();\n            this.attr({\n                textAlign: align,\n                textBaseline: valign,\n                font: `${ font.italic ? 'italic' : '' } ${ font.bold ? 'bold' : '' } ${ npx(font.size) }px ${ font.name }`,\n                fillStyle: color,\n                strokeStyle: color\n            });\n            const txts = `${ mtxt }`.split('\\n');\n            const biw = box.innerWidth();\n            const ntxts = [];\n            txts.forEach(it => {\n                const txtWidth = ctx.measureText(it).width;\n                if (textWrap && txtWidth > npx(biw)) {\n                    let textLine = {\n                        w: 0,\n                        len: 0,\n                        start: 0\n                    };\n                    for (let i = 0; i < it.length; i += 1) {\n                        if (textLine.w >= npx(biw)) {\n                            ntxts.push(it.substr(textLine.start, textLine.len));\n                            textLine = {\n                                w: 0,\n                                len: 0,\n                                start: i\n                            };\n                        }\n                        textLine.len += 1;\n                        textLine.w += ctx.measureText(it[i]).width + 1;\n                    }\n                    if (textLine.len > 0) {\n                        ntxts.push(it.substr(textLine.start, textLine.len));\n                    }\n                } else {\n                    ntxts.push(it);\n                }\n            });\n            const txtHeight = (ntxts.length - 1) * (font.size + 2);\n            let ty = box.texty(valign, txtHeight);\n            ntxts.forEach(txt => {\n                const txtWidth = ctx.measureText(txt).width;\n                this.fillText(txt, tx, ty);\n                if (strike) {\n                    drawFontLine.call(this, 'strike', tx, ty, align, valign, font.size, txtWidth);\n                }\n                if (underline) {\n                    drawFontLine.call(this, 'underline', tx, ty, align, valign, font.size, txtWidth);\n                }\n                ty += font.size + 2;\n            });\n            ctx.restore();\n            return this;\n        }\n        border(style, color) {\n            const {ctx} = this;\n            ctx.lineWidth = thinLineWidth;\n            ctx.strokeStyle = color;\n            if (style === 'medium') {\n                ctx.lineWidth = npx(2) - 0.5;\n            } else if (style === 'thick') {\n                ctx.lineWidth = npx(3);\n            } else if (style === 'dashed') {\n                ctx.setLineDash([\n                    npx(3),\n                    npx(2)\n                ]);\n            } else if (style === 'dotted') {\n                ctx.setLineDash([\n                    npx(1),\n                    npx(1)\n                ]);\n            } else if (style === 'double') {\n                ctx.setLineDash([\n                    npx(2),\n                    0\n                ]);\n            }\n            return this;\n        }\n        line(...xys) {\n            const {ctx} = this;\n            if (xys.length > 1) {\n                ctx.beginPath();\n                const [x, y] = xys[0];\n                ctx.moveTo(npxLine(x), npxLine(y));\n                for (let i = 1; i < xys.length; i += 1) {\n                    const [x1, y1] = xys[i];\n                    ctx.lineTo(npxLine(x1), npxLine(y1));\n                }\n                ctx.stroke();\n            }\n            return this;\n        }\n        strokeBorders(box) {\n            const {ctx} = this;\n            ctx.save();\n            const {borderTop, borderRight, borderBottom, borderLeft} = box;\n            if (borderTop) {\n                this.border(...borderTop);\n                this.line(...box.topxys());\n            }\n            if (borderRight) {\n                this.border(...borderRight);\n                this.line(...box.rightxys());\n            }\n            if (borderBottom) {\n                this.border(...borderBottom);\n                this.line(...box.bottomxys());\n            }\n            if (borderLeft) {\n                this.border(...borderLeft);\n                this.line(...box.leftxys());\n            }\n            ctx.restore();\n        }\n        dropdown(box) {\n            const {ctx} = this;\n            const {x, y, width, height} = box;\n            const sx = x + width - 15;\n            const sy = y + height - 15;\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(npx(sx), npx(sy));\n            ctx.lineTo(npx(sx + 8), npx(sy));\n            ctx.lineTo(npx(sx + 4), npx(sy + 6));\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(0, 0, 0, .45)';\n            ctx.fill();\n            ctx.restore();\n        }\n        error(box) {\n            const {ctx} = this;\n            const {x, y, width} = box;\n            const sx = x + width - 1;\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(npx(sx - 8), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y + 8));\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(255, 0, 0, .65)';\n            ctx.fill();\n            ctx.restore();\n        }\n        frozen(box) {\n            const {ctx} = this;\n            const {x, y, width} = box;\n            const sx = x + width - 1;\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(npx(sx - 8), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y - 1));\n            ctx.lineTo(npx(sx), npx(y + 8));\n            ctx.closePath();\n            ctx.fillStyle = 'rgba(0, 255, 0, .85)';\n            ctx.fill();\n            ctx.restore();\n        }\n        rect(box, dtextcb) {\n            const {ctx} = this;\n            const {x, y, width, height, bgcolor} = box;\n            ctx.save();\n            ctx.beginPath();\n            ctx.fillStyle = bgcolor || '#fff';\n            ctx.rect(npxLine(x + 1), npxLine(y + 1), npx(width - 2), npx(height - 2));\n            ctx.clip();\n            ctx.fill();\n            dtextcb();\n            ctx.restore();\n        }\n    }\n\n    return {\n        Draw,\n        DrawBox,\n        thinLineWidth,\n        npx\n    };\n});\ndefine('skylark-xspreadsheet/core/font',[],function () {\n    'use strict';\n    const baseFonts = [\n        {\n            key: 'Arial',\n            title: 'Arial'\n        },\n        {\n            key: 'Helvetica',\n            title: 'Helvetica'\n        },\n        {\n            key: 'Source Sans Pro',\n            title: 'Source Sans Pro'\n        },\n        {\n            key: 'Comic Sans MS',\n            title: 'Comic Sans MS'\n        },\n        {\n            key: 'Courier New',\n            title: 'Courier New'\n        },\n        {\n            key: 'Verdana',\n            title: 'Verdana'\n        },\n        {\n            key: 'Lato',\n            title: 'Lato'\n        }\n    ];\n    const fontSizes = [\n        {\n            pt: 7.5,\n            px: 10\n        },\n        {\n            pt: 8,\n            px: 11\n        },\n        {\n            pt: 9,\n            px: 12\n        },\n        {\n            pt: 10,\n            px: 13\n        },\n        {\n            pt: 10.5,\n            px: 14\n        },\n        {\n            pt: 11,\n            px: 15\n        },\n        {\n            pt: 12,\n            px: 16\n        },\n        {\n            pt: 14,\n            px: 18.7\n        },\n        {\n            pt: 15,\n            px: 20\n        },\n        {\n            pt: 16,\n            px: 21.3\n        },\n        {\n            pt: 18,\n            px: 24\n        },\n        {\n            pt: 22,\n            px: 29.3\n        },\n        {\n            pt: 24,\n            px: 32\n        },\n        {\n            pt: 26,\n            px: 34.7\n        },\n        {\n            pt: 36,\n            px: 48\n        },\n        {\n            pt: 42,\n            px: 56\n        }\n    ];\n    function getFontSizePxByPt(pt) {\n        for (let i = 0; i < fontSizes.length; i += 1) {\n            const fontSize = fontSizes[i];\n            if (fontSize.pt === pt) {\n                return fontSize.px;\n            }\n        }\n        return pt;\n    }\n    function fonts(ary = []) {\n        const map = {};\n        baseFonts.concat(ary).forEach(f => {\n            map[f.key] = f;\n        });\n        return map;\n    }\n\n    return {\n        fontSizes,\n        fonts,\n        baseFonts,\n        getFontSizePxByPt\n    };\n});\ndefine('skylark-xspreadsheet/core/cell',[\n    './alphabet',\n    './helper'\n], function (m_alphabet, m_helper) {\n    'use strict';\n\n// Converting infix expression to a suffix expression\n// src: AVERAGE(SUM(A1,A2), B1) + 50 + B20\n// return: [A1, A2], SUM[, B1],AVERAGE,50,+,B20,+\n\n    const infixExprToSuffixExpr = src => {\n        const operatorStack = [];\n        const stack = [];\n        let subStrs = [];\n        let fnArgType = 0;\n        let fnArgOperator = '';\n        let fnArgsLen = 1;\n        let oldc = '';\n        for (let i = 0; i < src.length; i += 1) {\n            const c = src.charAt(i);\n            if (c !== ' ') {\n                if (c >= 'a' && c <= 'z') {\n                    subStrs.push(c.toUpperCase());\n                } else if (c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c === '.') {\n                    subStrs.push(c);\n                } else if (c === '\"') {\n                    i += 1;\n                    while (src.charAt(i) !== '\"') {\n                        subStrs.push(src.charAt(i));\n                        i += 1;\n                    }\n                    stack.push(`\"${ subStrs.join('') }`);\n                    subStrs = [];\n                } else if (c === '-' && /[+\\-*/,(]/.test(oldc)) {\n                    subStrs.push(c);\n                } else {\n                    if (c !== '(' && subStrs.length > 0) {\n                        stack.push(subStrs.join(''));\n                    }\n                    if (c === ')') {\n                        let c1 = operatorStack.pop();\n                        if (fnArgType === 2) {\n                            try {\n                                const [ex, ey] = m_alphabet.expr2xy(stack.pop());\n                                const [sx, sy] = m_alphabet.expr2xy(stack.pop());\n                                let rangelen = 0;\n                                for (let x = sx; x <= ex; x += 1) {\n                                    for (let y = sy; y <= ey; y += 1) {\n                                        stack.push(m_alphabet.xy2expr(x, y));\n                                        rangelen += 1;\n                                    }\n                                }\n                                stack.push([\n                                    c1,\n                                    rangelen\n                                ]);\n                            } catch (e) {\n                            }\n                        } else if (fnArgType === 1 || fnArgType === 3) {\n                            if (fnArgType === 3)\n                                stack.push(fnArgOperator);\n                            stack.push([\n                                c1,\n                                fnArgsLen\n                            ]);\n                            fnArgsLen = 1;\n                        } else {\n                            while (c1 !== '(') {\n                                stack.push(c1);\n                                if (operatorStack.length <= 0)\n                                    break;\n                                c1 = operatorStack.pop();\n                            }\n                        }\n                        fnArgType = 0;\n                    } else if (c === '=' || c === '>' || c === '<') {\n                        const nc = src.charAt(i + 1);\n                        fnArgOperator = c;\n                        if (nc === '=' || nc === '-') {\n                            fnArgOperator += nc;\n                            i += 1;\n                        }\n                        fnArgType = 3;\n                    } else if (c === ':') {\n                        fnArgType = 2;\n                    } else if (c === ',') {\n                        if (fnArgType === 3) {\n                            stack.push(fnArgOperator);\n                        }\n                        fnArgType = 1;\n                        fnArgsLen += 1;\n                    } else if (c === '(' && subStrs.length > 0) {\n                        operatorStack.push(subStrs.join(''));\n                    } else {\n                        if (operatorStack.length > 0 && (c === '+' || c === '-')) {\n                            let top = operatorStack[operatorStack.length - 1];\n                            if (top !== '(')\n                                stack.push(operatorStack.pop());\n                            if (top === '*' || top === '/') {\n                                while (operatorStack.length > 0) {\n                                    top = operatorStack[operatorStack.length - 1];\n                                    if (top !== '(')\n                                        stack.push(operatorStack.pop());\n                                    else\n                                        break;\n                                }\n                            }\n                        } else if (operatorStack.length > 0) {\n                            const top = operatorStack[operatorStack.length - 1];\n                            if (top === '*' || top === '/')\n                                stack.push(operatorStack.pop());\n                        }\n                        operatorStack.push(c);\n                    }\n                    subStrs = [];\n                }\n                oldc = c;\n            }\n        }\n        if (subStrs.length > 0) {\n            stack.push(subStrs.join(''));\n        }\n        while (operatorStack.length > 0) {\n            stack.push(operatorStack.pop());\n        }\n        return stack;\n    };\n    const evalSubExpr = (subExpr, cellRender) => {\n        const [fl] = subExpr;\n        let expr = subExpr;\n        if (fl === '\"') {\n            return subExpr.substring(1);\n        }\n        let ret = 1;\n        if (fl === '-') {\n            expr = subExpr.substring(1);\n            ret = -1;\n        }\n        if (expr[0] >= '0' && expr[0] <= '9') {\n            return ret * Number(expr);\n        }\n        const [x, y] = m_alphabet.expr2xy(expr);\n        return ret * cellRender(x, y);\n    };\n\n// evaluate the suffix expression\n// srcStack: <= infixExprToSufixExpr\n// formulaMap: {'SUM': {}, ...}\n// cellRender: (x, y) => {}\n    const evalSuffixExpr = (srcStack, formulaMap, cellRender, cellList) => {\n        const stack = [];\n        for (let i = 0; i < srcStack.length; i += 1) {\n            const expr = srcStack[i];\n            const fc = expr[0];\n            if (expr === '+') {\n                const top = stack.pop();\n                stack.push(m_helper.numberCalc('+', stack.pop(), top));\n            } else if (expr === '-') {\n                if (stack.length === 1) {\n                    const top = stack.pop();\n                    stack.push(m_helper.numberCalc('*', top, -1));\n                } else {\n                    const top = stack.pop();\n                    stack.push(m_helper.numberCalc('-', stack.pop(), top));\n                }\n            } else if (expr === '*') {\n                stack.push(m_helper.numberCalc('*', stack.pop(), stack.pop()));\n            } else if (expr === '/') {\n                const top = stack.pop();\n                stack.push(m_helper.numberCalc('/', stack.pop(), top));\n            } else if (fc === '=' || fc === '>' || fc === '<') {\n                let top = stack.pop();\n                if (!Number.isNaN(top))\n                    top = Number(top);\n                let left = stack.pop();\n                if (!Number.isNaN(left))\n                    left = Number(left);\n                let ret = false;\n                if (fc === '=') {\n                    ret = left === top;\n                } else if (expr === '>') {\n                    ret = left > top;\n                } else if (expr === '>=') {\n                    ret = left >= top;\n                } else if (expr === '<') {\n                    ret = left < top;\n                } else if (expr === '<=') {\n                    ret = left <= top;\n                }\n                stack.push(ret);\n            } else if (Array.isArray(expr)) {\n                const [formula, len] = expr;\n                const params = [];\n                for (let j = 0; j < len; j += 1) {\n                    params.push(stack.pop());\n                }\n                stack.push(formulaMap[formula].render(params.reverse()));\n            } else {\n                if (cellList.includes(expr)) {\n                    return 0;\n                }\n                if (fc >= 'a' && fc <= 'z' || fc >= 'A' && fc <= 'Z') {\n                    cellList.push(expr);\n                }\n                stack.push(evalSubExpr(expr, cellRender));\n                cellList.pop();\n            }\n        }\n        return stack[0];\n    };\n    const cellRender = (src, formulaMap, getCellText, cellList = []) => {\n        if (src[0] === '=') {\n            const stack = infixExprToSuffixExpr(src.substring(1));\n            if (stack.length <= 0)\n                return src;\n            return evalSuffixExpr(stack, formulaMap, (x, y) => cellRender(getCellText(x, y), formulaMap, getCellText, cellList), cellList);\n        }\n        return src;\n    };\n\n    return {\n        render: cellRender ,\n        infixExprToSuffixExpr\n    };\n});\ndefine('skylark-xspreadsheet/core/formula',[\n    '../locale/locale',\n    './helper'\n], function (m_locale, m_helper) {\n    'use strict';\n    const baseFormulas = [\n        {\n            key: 'SUM',\n            title: m_locale.tf('formula.sum'),\n            render: ary => ary.reduce((a, b) => m_helper.numberCalc('+', a, b), 0)\n        },\n        {\n            key: 'AVERAGE',\n            title: m_locale.tf('formula.average'),\n            render: ary => ary.reduce((a, b) => Number(a) + Number(b), 0) / ary.length\n        },\n        {\n            key: 'MAX',\n            title: m_locale.tf('formula.max'),\n            render: ary => Math.max(...ary.map(v => Number(v)))\n        },\n        {\n            key: 'MIN',\n            title: m_locale.tf('formula.min'),\n            render: ary => Math.min(...ary.map(v => Number(v)))\n        },\n        {\n            key: 'IF',\n            title: m_locale.tf('formula._if'),\n            render: ([b, t, f]) => b ? t : f\n        },\n        {\n            key: 'AND',\n            title: m_locale.tf('formula.and'),\n            render: ary => ary.every(it => it)\n        },\n        {\n            key: 'OR',\n            title: m_locale.tf('formula.or'),\n            render: ary => ary.some(it => it)\n        },\n        {\n            key: 'CONCAT',\n            title: m_locale.tf('formula.concat'),\n            render: ary => ary.join('')\n        }\n    ];\n    const formulas = baseFormulas;\n    const formulam = {};\n    baseFormulas.forEach(f => {\n        formulam[f.key] = f;\n    });\n    \n    return  {\n        formulam,\n        formulas,\n        baseFormulas\n    };\n});\ndefine('skylark-xspreadsheet/core/format',['../locale/locale'], function (m_locale) {\n    'use strict';\n    const formatStringRender = v => v;\n    const formatNumberRender = v => {\n        if (/^(-?\\d*.?\\d*)$/.test(v)) {\n            const v1 = Number(v).toFixed(2).toString();\n            const [first, ...parts] = v1.split('\\\\.');\n            return [\n                first.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1,'),\n                ...parts\n            ];\n        }\n        return v;\n    };\n    const baseFormats = [\n        {\n            key: 'normal',\n            title: m_locale.tf('format.normal'),\n            type: 'string',\n            render: formatStringRender\n        },\n        {\n            key: 'text',\n            title: m_locale.tf('format.text'),\n            type: 'string',\n            render: formatStringRender\n        },\n        {\n            key: 'number',\n            title: m_locale.tf('format.number'),\n            type: 'number',\n            label: '1,000.12',\n            render: formatNumberRender\n        },\n        {\n            key: 'percent',\n            title: m_locale.tf('format.percent'),\n            type: 'number',\n            label: '10.12%',\n            render: v => `${ v }%`\n        },\n        {\n            key: 'rmb',\n            title: m_locale.tf('format.rmb'),\n            type: 'number',\n            label: '\\uFFE510.00',\n            render: v => `￥${ formatNumberRender(v) }`\n        },\n        {\n            key: 'usd',\n            title: m_locale.tf('format.usd'),\n            type: 'number',\n            label: '$10.00',\n            render: v => `$${ formatNumberRender(v) }`\n        },\n        {\n            key: 'eur',\n            title: m_locale.tf('format.eur'),\n            type: 'number',\n            label: '\\u20AC10.00',\n            render: v => `€${ formatNumberRender(v) }`\n        },\n        {\n            key: 'date',\n            title: m_locale.tf('format.date'),\n            type: 'date',\n            label: '26/09/2008',\n            render: formatStringRender\n        },\n        {\n            key: 'time',\n            title: m_locale.tf('format.time'),\n            type: 'date',\n            label: '15:59:00',\n            render: formatStringRender\n        },\n        {\n            key: 'datetime',\n            title: m_locale.tf('format.datetime'),\n            type: 'date',\n            label: '26/09/2008 15:59:00',\n            render: formatStringRender\n        },\n        {\n            key: 'duration',\n            title: m_locale.tf('format.duration'),\n            type: 'date',\n            label: '24:01:00',\n            render: formatStringRender\n        }\n    ];\n    const formatm = {};\n    baseFormats.forEach(f => {\n        formatm[f.key] = f;\n    });\n\n    return {\n        formatm,\n        baseFormats\n    };\n});\ndefine('skylark-xspreadsheet/component/table',[\n    '../core/alphabet',\n    '../core/font',\n    '../core/cell',\n    '../core/formula',\n    '../core/format',\n    '../canvas/draw'\n], function (m_alphabet, m_font, m_cell, m_formula, m_format, m_draw) {\n    'use strict';\n    const cellPaddingWidth = 5;\n    const tableFixedHeaderCleanStyle = { fillStyle: '#f4f5f8' };\n    const tableGridStyle = {\n        fillStyle: '#fff',\n        lineWidth: m_draw.thinLineWidth,\n        strokeStyle: '#e6e6e6'\n    };\n    function tableFixedHeaderStyle() {\n        return {\n            textAlign: 'center',\n            textBaseline: 'middle',\n            font: `500 ${ m_draw.npx(12) }px Source Sans Pro`,\n            fillStyle: '#585757',\n            lineWidth: m_draw.thinLineWidth(),\n            strokeStyle: '#e6e6e6'\n        };\n    }\n    function getDrawBox(data, rindex, cindex, yoffset = 0) {\n        const {left, top, width, height} = data.cellRect(rindex, cindex);\n        return new m_draw.DrawBox(left, top + yoffset, width, height, cellPaddingWidth);\n    }\n    \n    function renderCell(draw, data, rindex, cindex, yoffset = 0) {\n        const {sortedRowMap, rows, cols} = data;\n        if (rows.isHide(rindex) || cols.isHide(cindex))\n            return;\n        let nrindex = rindex;\n        if (sortedRowMap.has(rindex)) {\n            nrindex = sortedRowMap.get(rindex);\n        }\n        const cell = data.getCell(nrindex, cindex);\n        if (cell === null)\n            return;\n        let frozen = false;\n        if ('editable' in cell && cell.editable === false) {\n            frozen = true;\n        }\n        const style = data.getCellStyleOrDefault(nrindex, cindex);\n        const dbox = getDrawBox(data, rindex, cindex, yoffset);\n        dbox.bgcolor = style.bgcolor;\n        if (style.border !== undefined) {\n            dbox.setBorders(style.border);\n            draw.strokeBorders(dbox);\n        }\n        draw.rect(dbox, () => {\n            let cellText = m_cell.render(cell.text || '', m_formula.formulam, (y, x) => data.getCellTextOrDefault(x, y));\n            if (style.format) {\n                cellText = m_format.formatm[style.format].render(cellText);\n            }\n            const font = Object.assign({}, style.font);\n            font.size = m_font.getFontSizePxByPt(font.size);\n            draw.text(cellText, dbox, {\n                align: style.align,\n                valign: style.valign,\n                font,\n                color: style.color,\n                strike: style.strike,\n                underline: style.underline\n            }, style.textwrap);\n            const error = data.validations.getError(rindex, cindex);\n            if (error) {\n                draw.error(dbox);\n            }\n            if (frozen) {\n                draw.frozen(dbox);\n            }\n        });\n    }\n    function renderAutofilter(viewRange) {\n        const {data, draw} = this;\n        if (viewRange) {\n            const {autoFilter} = data;\n            if (!autoFilter.active())\n                return;\n            const afRange = autoFilter.hrange();\n            if (viewRange.intersects(afRange)) {\n                afRange.each((ri, ci) => {\n                    const dbox = getDrawBox(data, ri, ci);\n                    draw.dropdown(dbox);\n                });\n            }\n        }\n    }\n    function renderContent(viewRange, fw, fh, tx, ty) {\n        const {draw, data} = this;\n        draw.save();\n        draw.translate(fw, fh).translate(tx, ty);\n        const {exceptRowSet} = data;\n        const filteredTranslateFunc = ri => {\n            const ret = exceptRowSet.has(ri);\n            if (ret) {\n                const height = data.rows.getHeight(ri);\n                draw.translate(0, -height);\n            }\n            return !ret;\n        };\n        const exceptRowTotalHeight = data.exceptRowTotalHeight(viewRange.sri, viewRange.eri);\n        draw.save();\n        draw.translate(0, -exceptRowTotalHeight);\n        viewRange.each((ri, ci) => {\n            renderCell(draw, data, ri, ci);\n        }, ri => filteredTranslateFunc(ri));\n        draw.restore();\n        const rset = new Set();\n        draw.save();\n        draw.translate(0, -exceptRowTotalHeight);\n        data.eachMergesInView(viewRange, ({sri, sci, eri}) => {\n            if (!exceptRowSet.has(sri)) {\n                renderCell(draw, data, sri, sci);\n            } else if (!rset.has(sri)) {\n                rset.add(sri);\n                const height = data.rows.sumHeight(sri, eri + 1);\n                draw.translate(0, -height);\n            }\n        });\n        draw.restore();\n        renderAutofilter.call(this, viewRange);\n        draw.restore();\n    }\n    function renderSelectedHeaderCell(x, y, w, h) {\n        const {draw} = this;\n        draw.save();\n        draw.attr({ fillStyle: 'rgba(75, 137, 255, 0.08)' }).fillRect(x, y, w, h);\n        draw.restore();\n    }\n    function renderFixedHeaders(type, viewRange, w, h, tx, ty) {\n        const {draw, data} = this;\n        const sumHeight = viewRange.h;\n        const sumWidth = viewRange.w;\n        const nty = ty + h;\n        const ntx = tx + w;\n        draw.save();\n        draw.attr(tableFixedHeaderCleanStyle);\n        if (type === 'all' || type === 'left')\n            draw.fillRect(0, nty, w, sumHeight);\n        if (type === 'all' || type === 'top')\n            draw.fillRect(ntx, 0, sumWidth, h);\n        const {sri, sci, eri, eci} = data.selector.range;\n        draw.attr(tableFixedHeaderStyle());\n        if (type === 'all' || type === 'left') {\n            data.rowEach(viewRange.sri, viewRange.eri, (i, y1, rowHeight) => {\n                const y = nty + y1;\n                const ii = i;\n                draw.line([\n                    0,\n                    y\n                ], [\n                    w,\n                    y\n                ]);\n                if (sri <= ii && ii < eri + 1) {\n                    renderSelectedHeaderCell.call(this, 0, y, w, rowHeight);\n                }\n                draw.fillText(ii + 1, w / 2, y + rowHeight / 2);\n                if (i > 0 && data.rows.isHide(i - 1)) {\n                    draw.save();\n                    draw.attr({ strokeStyle: '#c6c6c6' });\n                    draw.line([\n                        5,\n                        y + 5\n                    ], [\n                        w - 5,\n                        y + 5\n                    ]);\n                    draw.restore();\n                }\n            });\n            draw.line([\n                0,\n                sumHeight + nty\n            ], [\n                w,\n                sumHeight + nty\n            ]);\n            draw.line([\n                w,\n                nty\n            ], [\n                w,\n                sumHeight + nty\n            ]);\n        }\n        if (type === 'all' || type === 'top') {\n            data.colEach(viewRange.sci, viewRange.eci, (i, x1, colWidth) => {\n                const x = ntx + x1;\n                const ii = i;\n                draw.line([\n                    x,\n                    0\n                ], [\n                    x,\n                    h\n                ]);\n                if (sci <= ii && ii < eci + 1) {\n                    renderSelectedHeaderCell.call(this, x, 0, colWidth, h);\n                }\n                draw.fillText(m_alphabet.stringAt(ii), x + colWidth / 2, h / 2);\n                if (i > 0 && data.cols.isHide(i - 1)) {\n                    draw.save();\n                    draw.attr({ strokeStyle: '#c6c6c6' });\n                    draw.line([\n                        x + 5,\n                        5\n                    ], [\n                        x + 5,\n                        h - 5\n                    ]);\n                    draw.restore();\n                }\n            });\n            draw.line([\n                sumWidth + ntx,\n                0\n            ], [\n                sumWidth + ntx,\n                h\n            ]);\n            draw.line([\n                0,\n                h\n            ], [\n                sumWidth + ntx,\n                h\n            ]);\n        }\n        draw.restore();\n    }\n    function renderFixedLeftTopCell(fw, fh) {\n        const {draw} = this;\n        draw.save();\n        draw.attr({ fillStyle: '#f4f5f8' }).fillRect(0, 0, fw, fh);\n        draw.restore();\n    }\n    function renderContentGrid({sri, sci, eri, eci, w, h}, fw, fh, tx, ty) {\n        const {draw, data} = this;\n        const {settings} = data;\n        draw.save();\n        draw.attr(tableGridStyle).translate(fw + tx, fh + ty);\n        draw.clearRect(0, 0, w, h);\n        if (!settings.showGrid) {\n            draw.restore();\n            return;\n        }\n        data.rowEach(sri, eri, (i, y, ch) => {\n            if (i !== sri)\n                draw.line([\n                    0,\n                    y\n                ], [\n                    w,\n                    y\n                ]);\n            if (i === eri)\n                draw.line([\n                    0,\n                    y + ch\n                ], [\n                    w,\n                    y + ch\n                ]);\n        });\n        data.colEach(sci, eci, (i, x, cw) => {\n            if (i !== sci)\n                draw.line([\n                    x,\n                    0\n                ], [\n                    x,\n                    h\n                ]);\n            if (i === eci)\n                draw.line([\n                    x + cw,\n                    0\n                ], [\n                    x + cw,\n                    h\n                ]);\n        });\n        draw.restore();\n    }\n    function renderFreezeHighlightLine(fw, fh, ftw, fth) {\n        const {draw, data} = this;\n        const twidth = data.viewWidth() - fw;\n        const theight = data.viewHeight() - fh;\n        draw.save().translate(fw, fh).attr({ strokeStyle: 'rgba(75, 137, 255, .6)' });\n        draw.line([\n            0,\n            fth\n        ], [\n            twidth,\n            fth\n        ]);\n        draw.line([\n            ftw,\n            0\n        ], [\n            ftw,\n            theight\n        ]);\n        draw.restore();\n    }\n    class Table {\n        constructor(el, data) {\n            this.el = el;\n            this.draw = new m_draw.Draw(el, data.viewWidth(), data.viewHeight());\n            this.data = data;\n        }\n        resetData(data) {\n            this.data = data;\n            this.render();\n        }\n        render() {\n            const {data} = this;\n            const {rows, cols} = data;\n            const fw = cols.indexWidth;\n            const fh = rows.height;\n            this.draw.resize(data.viewWidth(), data.viewHeight());\n            this.clear();\n            const viewRange = data.viewRange();\n            const tx = data.freezeTotalWidth();\n            const ty = data.freezeTotalHeight();\n            const {x, y} = data.scroll;\n            renderContentGrid.call(this, viewRange, fw, fh, tx, ty);\n            renderContent.call(this, viewRange, fw, fh, -x, -y);\n            renderFixedHeaders.call(this, 'all', viewRange, fw, fh, tx, ty);\n            renderFixedLeftTopCell.call(this, fw, fh);\n            const [fri, fci] = data.freeze;\n            if (fri > 0 || fci > 0) {\n                if (fri > 0) {\n                    const vr = viewRange.clone();\n                    vr.sri = 0;\n                    vr.eri = fri - 1;\n                    vr.h = ty;\n                    renderContentGrid.call(this, vr, fw, fh, tx, 0);\n                    renderContent.call(this, vr, fw, fh, -x, 0);\n                    renderFixedHeaders.call(this, 'top', vr, fw, fh, tx, 0);\n                }\n                if (fci > 0) {\n                    const vr = viewRange.clone();\n                    vr.sci = 0;\n                    vr.eci = fci - 1;\n                    vr.w = tx;\n                    renderContentGrid.call(this, vr, fw, fh, 0, ty);\n                    renderFixedHeaders.call(this, 'left', vr, fw, fh, 0, ty);\n                    renderContent.call(this, vr, fw, fh, 0, -y);\n                }\n                const freezeViewRange = data.freezeViewRange();\n                renderContentGrid.call(this, freezeViewRange, fw, fh, 0, 0);\n                renderFixedHeaders.call(this, 'all', freezeViewRange, fw, fh, 0, 0);\n                renderContent.call(this, freezeViewRange, fw, fh, 0, 0);\n                renderFreezeHighlightLine.call(this, fw, fh, tx, ty);\n            }\n        }\n        clear() {\n            this.draw.clear();\n        }\n    }\n    return {\n        renderCell,\n        Table\n    };\n});\ndefine('skylark-xspreadsheet/component/print',[\n    './element',\n    '../config',\n    './button',\n    '../canvas/draw',\n    './table',\n    '../locale/locale'\n], function (m_element, m_config, Button, m_draw, m_table, m_locale) {\n    'use strict';\n    const PAGER_SIZES = [\n        [\n            'A3',\n            11.69,\n            16.54\n        ],\n        [\n            'A4',\n            8.27,\n            11.69\n        ],\n        [\n            'A5',\n            5.83,\n            8.27\n        ],\n        [\n            'B4',\n            9.84,\n            13.9\n        ],\n        [\n            'B5',\n            6.93,\n            9.84\n        ]\n    ];\n    const PAGER_ORIENTATIONS = [\n        'landscape',\n        'portrait'\n    ];\n    function inches2px(inc) {\n        return parseInt(96 * inc, 10);\n    }\n    function btnClick(type) {\n        if (type === 'cancel') {\n            this.el.hide();\n        } else {\n            this.toPrint();\n        }\n    }\n    function pagerSizeChange(evt) {\n        const {paper} = this;\n        const {value} = evt.target;\n        const ps = PAGER_SIZES[value];\n        paper.w = inches2px(ps[1]);\n        paper.undefined = inches2px(ps[2]);\n        this.preview();\n    }\n    function pagerOrientationChange(evt) {\n        const {paper} = this;\n        const {value} = evt.target;\n        const v = PAGER_ORIENTATIONS[value];\n        paper.orientation = v;\n        this.preview();\n    }\n    return class Print {\n        constructor(data) {\n            this.paper = {\n                w: inches2px(PAGER_SIZES[0][1]),\n                h: inches2px(PAGER_SIZES[0][2]),\n                padding: 50,\n                orientation: PAGER_ORIENTATIONS[0],\n                get width() {\n                    return this.orientation === 'landscape' ? this.undefined : this.w;\n                },\n                get height() {\n                    return this.orientation === 'landscape' ? this.w : this.undefined;\n                }\n            };\n            this.data = data;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-print`).children(m_element.h('div', `${ m_config.cssPrefix }-print-bar`).children(m_element.h('div', '-title').child('Print settings'), m_element.h('div', '-right').children(m_element.h('div', `${ m_config.cssPrefix }-buttons`).children(new Button('cancel').on('click', btnClick.bind(this, 'cancel')), new Button('next', 'primary').on('click', btnClick.bind(this, 'next'))))), m_element.h('div', `${ m_config.cssPrefix }-print-content`).children(this.contentEl = m_element.h('div', '-content'), m_element.h('div', '-sider').child(m_element.h('form', '').children(m_element.h('fieldset', '').children(m_element.h('label', '').child(`${ m_locale.t('print.size') }`), m_element.h('select', '').children(...PAGER_SIZES.map((it, index) => m_element.h('option', '').attr('value', index).child(`${ it[0] } ( ${ it[1] }''x${ it[2] }'' )`))).on('change', pagerSizeChange.bind(this))), m_element.h('fieldset', '').children(m_element.h('label', '').child(`${ m_locale.t('print.orientation') }`), m_element.h('select', '').children(...PAGER_ORIENTATIONS.map((it, index) => m_element.h('option', '').attr('value', index).child(`${ m_locale.t('print.orientations')[index] }`))).on('change', pagerOrientationChange.bind(this))))))).hide();\n        }\n        resetData(data) {\n            this.data = data;\n        }\n        preview() {\n            const {data, paper} = this;\n            const {width, height, padding} = paper;\n            const iwidth = width - padding * 2;\n            const iheight = height - padding * 2;\n            const cr = data.contentRange();\n            const pages = parseInt(cr.undefined / iheight, 10) + 1;\n            const scale = iwidth / cr.w;\n            let left = padding;\n            const top = padding;\n            if (scale > 1) {\n                left += (iwidth - cr.w) / 2;\n            }\n            let ri = 0;\n            let yoffset = 0;\n            this.contentEl.html('');\n            this.canvases = [];\n            const mViewRange = {\n                sri: 0,\n                sci: 0,\n                eri: 0,\n                eci: 0\n            };\n            for (let i = 0; i < pages; i += 1) {\n                let th = 0;\n                let yo = 0;\n                const wrap = m_element.h('div', `${ m_config.cssPrefix }-canvas-card`);\n                const canvas = m_element.h('canvas', `${ m_config.cssPrefix }-canvas`);\n                this.canvases.push(canvas.el);\n                const draw = new m_draw.Draw(canvas.el, width, height);\n                draw.save();\n                draw.translate(left, top);\n                if (scale < 1)\n                    draw.scale(scale, scale);\n                for (; ri <= cr.eri; ri += 1) {\n                    const rh = data.rows.getHeight(ri);\n                    th += rh;\n                    if (th < iheight) {\n                        for (let ci = 0; ci <= cr.eci; ci += 1) {\n                            m_table.renderCell(draw, data, ri, ci, yoffset);\n                            mViewRange.eci = ci;\n                        }\n                    } else {\n                        yo = -(th - rh);\n                        break;\n                    }\n                }\n                mViewRange.eri = ri;\n                draw.restore();\n                draw.save();\n                draw.translate(left, top);\n                if (scale < 1)\n                    draw.scale(scale, scale);\n                const yof = yoffset;\n                data.eachMergesInView(mViewRange, ({sri, sci}) => {\n                    m_table.renderCell(draw, data, sri, sci, yof);\n                });\n                draw.restore();\n                mViewRange.sri = mViewRange.eri;\n                mViewRange.sci = mViewRange.eci;\n                yoffset += yo;\n                this.contentEl.child(m_element.h('div', `${ m_config.cssPrefix }-canvas-card-wraper`).child(wrap.child(canvas)));\n            }\n            this.el.show();\n        }\n        toPrint() {\n            this.el.hide();\n            const {paper} = this;\n            const iframe = m_element.h('iframe', '').hide();\n            const {el} = iframe;\n            window.document.body.appendChild(el);\n            const {contentWindow} = el;\n            const idoc = contentWindow.document;\n            const style = document.createElement('style');\n            style.innerHTML = `\n      @page { size: ${ paper.width }px ${ paper.height }px; };\n      canvas {\n        page-break-before: auto;        \n        page-break-after: always;\n        image-rendering: pixelated;\n      };\n    `;\n            idoc.head.appendChild(style);\n            this.canvases.forEach(it => {\n                const cn = it.cloneNode(false);\n                const ctx = cn.getContext('2d');\n                ctx.drawImage(it, 0, 0);\n                idoc.body.appendChild(cn);\n            });\n            contentWindow.print();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/contextmenu',[\n    './element',\n    './event',\n    '../config',\n    '../locale/locale'\n], function (m_element, m_event, m_config, m_locale) {\n    'use strict';\n    const menuItems = [\n        {\n            key: 'copy',\n            title: m_locale.tf('contextmenu.copy'),\n            label: 'Ctrl+C'\n        },\n        {\n            key: 'cut',\n            title: m_locale.tf('contextmenu.cut'),\n            label: 'Ctrl+X'\n        },\n        {\n            key: 'paste',\n            title: m_locale.tf('contextmenu.paste'),\n            label: 'Ctrl+V'\n        },\n        {\n            key: 'paste-value',\n            title: m_locale.tf('contextmenu.pasteValue'),\n            label: 'Ctrl+Shift+V'\n        },\n        {\n            key: 'paste-format',\n            title: m_locale.tf('contextmenu.pasteFormat'),\n            label: 'Ctrl+Alt+V'\n        },\n        { key: 'divider' },\n        {\n            key: 'insert-row',\n            title: m_locale.tf('contextmenu.insertRow')\n        },\n        {\n            key: 'insert-column',\n            title: m_locale.tf('contextmenu.insertColumn')\n        },\n        { key: 'divider' },\n        {\n            key: 'delete-row',\n            title: m_locale.tf('contextmenu.deleteRow')\n        },\n        {\n            key: 'delete-column',\n            title: m_locale.tf('contextmenu.deleteColumn')\n        },\n        {\n            key: 'delete-cell-text',\n            title: m_locale.tf('contextmenu.deleteCellText')\n        },\n        {\n            key: 'hide',\n            title: m_locale.tf('contextmenu.hide')\n        },\n        { key: 'divider' },\n        {\n            key: 'validation',\n            title: m_locale.tf('contextmenu.validation')\n        },\n        { key: 'divider' },\n        {\n            key: 'cell-printable',\n            title: m_locale.tf('contextmenu.cellprintable')\n        },\n        {\n            key: 'cell-non-printable',\n            title: m_locale.tf('contextmenu.cellnonprintable')\n        },\n        { key: 'divider' },\n        {\n            key: 'cell-editable',\n            title: m_locale.tf('contextmenu.celleditable')\n        },\n        {\n            key: 'cell-non-editable',\n            title: m_locale.tf('contextmenu.cellnoneditable')\n        }\n    ];\n    function buildMenuItem(item) {\n        if (item.key === 'divider') {\n            return m_element.h('div', `${ m_config.cssPrefix }-item divider`);\n        }\n        return m_element.h('div', `${ m_config.cssPrefix }-item`).on('click', () => {\n            this.itemClick(item.key);\n            this.hide();\n        }).children(item.title(), m_element.h('div', 'label').child(item.label || ''));\n    }\n    function buildMenu() {\n        return menuItems.map(it => buildMenuItem.call(this, it));\n    }\n\n    class ContextMenu {\n        constructor(viewFn, isHide = false) {\n            this.menuItems = buildMenu.call(this);\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-contextmenu`).children(...this.menuItems).hide();\n            this.viewFn = viewFn;\n            this.itemClick = () => {\n            };\n            this.isHide = isHide;\n            this.setMode('range');\n        }\n        setMode(mode) {\n            const hideEl = this.menuItems[12];\n            if (mode === 'row-col') {\n                hideEl.show();\n            } else {\n                hideEl.hide();\n            }\n        }\n        hide() {\n            const {el} = this;\n            el.hide();\n            m_event.unbindClickoutside(el);\n        }\n        setPosition(x, y) {\n            if (this.isHide)\n                return;\n            const {el} = this;\n            const {width} = el.show().offset();\n            const view = this.viewFn();\n            const vhf = view.height / 2;\n            let left = x;\n            if (view.width - x <= width) {\n                left -= width;\n            }\n            el.css('left', `${ left }px`);\n            if (y > vhf) {\n                el.css('bottom', `${ view.height - y }px`).css('max-height', `${ y }px`).css('top', 'auto');\n            } else {\n                el.css('top', `${ y }px`).css('max-height', `${ view.height - y }px`).css('bottom', 'auto');\n            }\n            m_event.bindClickoutside(el);\n        }\n    }\n\n    return ContextMenu;\n});\ndefine('skylark-xspreadsheet/component/tooltip',[\n    './element',\n    './event',\n    '../config'\n], function (m_element, m_event, m_config) {\n    'use strict';\n    function tooltip(html, target) {\n        if (target.classList.contains('active')) {\n            return;\n        }\n        const {left, top, width, height} = target.getBoundingClientRect();\n        const el = m_element.h('div', `${ m_config.cssPrefix }-tooltip`).html(html).show();\n        document.body.appendChild(el.el);\n        const elBox = el.box();\n        el.css('left', `${ left + width / 2 - elBox.width / 2 }px`).css('top', `${ top + height + 2 }px`);\n        m_event.bind(target, 'mouseleave', () => {\n            if (document.body.contains(el.el)) {\n                document.body.removeChild(el.el);\n            }\n        });\n        m_event.bind(target, 'click', () => {\n            if (document.body.contains(el.el)) {\n                document.body.removeChild(el.el);\n            }\n        });\n    }\n\n    return tooltip;\n});\ndefine('skylark-xspreadsheet/component/toolbar/item',[\n    '../../config',\n    '../tooltip',\n    '../element',\n    '../../locale/locale'\n], function (a, tooltip, b, c) {\n    'use strict';\n    return class Item {\n        constructor(tag, shortcut, value) {\n            this.tip = c.t(`toolbar.${ tag.replace(/-[a-z]/g, c => c[1].toUpperCase()) }`);\n            if (shortcut)\n                this.tip += ` (${ shortcut })`;\n            this.tag = tag;\n            this.shortcut = shortcut;\n            this.value = value;\n            this.el = this.element();\n            this.change = () => {\n            };\n        }\n        element() {\n            const {tip} = this;\n            return b.h('div', `${ a.cssPrefix }-toolbar-btn`).on('mouseenter', evt => {\n                tooltip(tip, evt.target);\n            }).attr('data-tooltip', tip);\n        }\n        setState() {\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/dropdown_item',['./item'], function (Item) {\n    'use strict';\n    return class DropdownItem extends Item {\n        dropdown() {\n        }\n        getValue(v) {\n            return v;\n        }\n        element() {\n            const {tag} = this;\n            this.dd = this.dropdown();\n            this.dd.change = it => this.change(tag, this.getValue(it));\n            return super.element().child(this.dd);\n        }\n        setState(v) {\n            if (v) {\n                this.value = v;\n                this.dd.setTitle(v);\n            }\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown',[\n    './element',\n    './event',\n    '../config'\n], function (m_element, m_event, m_config) {\n    'use strict';\n    return class Dropdown extends m_element.Element {\n        constructor(title, width, showArrow, placement, ...children) {\n            super('div', `${ m_config.cssPrefix }-dropdown ${ placement }`);\n            this.title = title;\n            this.change = () => {\n            };\n            this.headerClick = () => {\n            };\n            if (typeof title === 'string') {\n                this.title = m_element.h('div', `${ m_config.cssPrefix }-dropdown-title`).child(title);\n            } else if (showArrow) {\n                this.title.addClass('arrow-left');\n            }\n            this.contentEl = m_element.h('div', `${ m_config.cssPrefix }-dropdown-content`).css('width', width).hide();\n            this.setContentChildren(...children);\n            this.headerEl = m_element.h('div', `${ m_config.cssPrefix }-dropdown-header`);\n            this.headerEl.on('click', () => {\n                if (this.contentEl.css('display') !== 'block') {\n                    this.show();\n                } else {\n                    this.hide();\n                }\n            }).children(this.title, showArrow ? m_element.h('div', `${ m_config.cssPrefix }-icon arrow-right`).child(m_element.h('div', `${ m_config.cssPrefix }-icon-img arrow-down`)) : '');\n            this.children(this.headerEl, this.contentEl);\n        }\n        setContentChildren(...children) {\n            this.contentEl.html('');\n            if (children.length > 0) {\n                this.contentEl.children(...children);\n            }\n        }\n        setTitle(title) {\n            this.title.html(title);\n            this.hide();\n        }\n        show() {\n            const {contentEl} = this;\n            contentEl.show();\n            this.parent().active();\n            m_event.bindClickoutside(this.parent(), () => {\n                this.hide();\n            });\n        }\n        hide() {\n            this.parent().active(false);\n            this.contentEl.hide();\n            m_event.unbindClickoutside(this.parent());\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_align',[\n    './dropdown',\n    './element',\n    './icon',\n    '../config'\n], function (Dropdown, m_element, Icon, m_config) {\n    'use strict';\n    function buildItemWithIcon(iconName) {\n        return m_element.h('div', `${ m_config.cssPrefix }-item`).child(new Icon(iconName));\n    }\n    return class DropdownAlign extends Dropdown {\n        constructor(aligns, align) {\n            const icon = new Icon(`align-${ align }`);\n            const naligns = aligns.map(it => buildItemWithIcon(`align-${ it }`).on('click', () => {\n                this.setTitle(it);\n                this.change(it);\n            }));\n            super(icon, 'auto', true, 'bottom-left', ...naligns);\n        }\n        setTitle(align) {\n            this.title.setName(`align-${ align }`);\n            this.hide();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/align',[\n    './dropdown_item',\n    '../dropdown_align'\n], function (DropdownItem, DropdownAlign) {\n    'use strict';\n    \n    class Align extends DropdownItem {\n        constructor(value) {\n            super('align', '', value);\n        }\n        dropdown() {\n            const {value} = this;\n            return new DropdownAlign([\n                'left',\n                'center',\n                'right'\n            ], value);\n        }\n    };\n\n    return Align;\n});\ndefine('skylark-xspreadsheet/component/toolbar/valign',[\n    './dropdown_item',\n    '../dropdown_align'\n], function (DropdownItem, DropdownAlign) {\n    'use strict';\n    return class Valign extends DropdownItem {\n        constructor(value) {\n            super('valign', '', value);\n        }\n        dropdown() {\n            const {value} = this;\n            return new DropdownAlign([\n                'top',\n                'middle',\n                'bottom'\n            ], value);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/toggle_item',[\n    './item',\n    '../icon'\n], function (Item, Icon) {\n    'use strict';\n    return class ToggleItem extends Item {\n        element() {\n            const {tag} = this;\n            return super.element().child(new Icon(tag)).on('click', () => this.click());\n        }\n        click() {\n            this.change(this.tag, this.toggle());\n        }\n        setState(active) {\n            this.el.active(active);\n        }\n        toggle() {\n            return this.el.toggle();\n        }\n        active() {\n            return this.el.hasClass('active');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/autofilter',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Autofilter extends ToggleItem {\n        constructor() {\n            super('autofilter');\n        }\n        setState() {\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/bold',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Bold extends ToggleItem {\n        constructor() {\n            super('font-bold', 'Ctrl+B');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/italic',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Italic extends ToggleItem {\n        constructor() {\n            super('font-italic', 'Ctrl+I');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/strike',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Strike extends ToggleItem {\n        constructor() {\n            super('strike', 'Ctrl+U');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/underline',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Underline extends ToggleItem {\n        constructor() {\n            super('underline', 'Ctrl+U');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/color_palette',[\n    './element',\n    '../config'\n], function (m_element, m_config) {\n    'use strict';\n    const themeColorPlaceHolders = [\n        '#ffffff',\n        '#000100',\n        '#e7e5e6',\n        '#445569',\n        '#5b9cd6',\n        '#ed7d31',\n        '#a5a5a5',\n        '#ffc001',\n        '#4371c6',\n        '#71ae47'\n    ];\n    const themeColors = [\n        [\n            '#f2f2f2',\n            '#7f7f7f',\n            '#d0cecf',\n            '#d5dce4',\n            '#deeaf6',\n            '#fce5d5',\n            '#ededed',\n            '#fff2cd',\n            '#d9e2f3',\n            '#e3efd9'\n        ],\n        [\n            '#d8d8d8',\n            '#595959',\n            '#afabac',\n            '#adb8ca',\n            '#bdd7ee',\n            '#f7ccac',\n            '#dbdbdb',\n            '#ffe59a',\n            '#b3c6e7',\n            '#c5e0b3'\n        ],\n        [\n            '#bfbfbf',\n            '#3f3f3f',\n            '#756f6f',\n            '#8596b0',\n            '#9cc2e6',\n            '#f4b184',\n            '#c9c9c9',\n            '#fed964',\n            '#8eaada',\n            '#a7d08c'\n        ],\n        [\n            '#a5a5a5',\n            '#262626',\n            '#3a3839',\n            '#333f4f',\n            '#2e75b5',\n            '#c45a10',\n            '#7b7b7b',\n            '#bf8e01',\n            '#2f5596',\n            '#538136'\n        ],\n        [\n            '#7f7f7f',\n            '#0c0c0c',\n            '#171516',\n            '#222a35',\n            '#1f4e7a',\n            '#843c0a',\n            '#525252',\n            '#7e6000',\n            '#203864',\n            '#365624'\n        ]\n    ];\n    const standardColors = [\n        '#c00000',\n        '#fe0000',\n        '#fdc101',\n        '#ffff01',\n        '#93d051',\n        '#00b04e',\n        '#01b0f1',\n        '#0170c1',\n        '#012060',\n        '#7030a0'\n    ];\n    function buildTd(bgcolor) {\n        return m_element.h('td', '').child(m_element.h('div', `${ m_config.cssPrefix }-color-palette-cell`).on('click.stop', () => this.change(bgcolor)).css('background-color', bgcolor));\n    }\n    \n    class ColorPalette {\n        constructor() {\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-color-palette`);\n            this.change = () => {\n            };\n            const table = m_element.h('table', '').children(m_element.h('tbody', '').children(m_element.h('tr', `${ m_config.cssPrefix }-theme-color-placeholders`).children(...themeColorPlaceHolders.map(color => buildTd.call(this, color))), ...themeColors.map(it => m_element.h('tr', `${ m_config.cssPrefix }-theme-colors`).children(...it.map(color => buildTd.call(this, color)))), m_element.h('tr', `${ m_config.cssPrefix }-standard-colors`).children(...standardColors.map(color => buildTd.call(this, color)))));\n            this.el.child(table);\n        }\n    }\n\n    return ColorPalette;\n});\ndefine('skylark-xspreadsheet/component/dropdown_color',[\n    './dropdown',\n    './icon',\n    './color_palette'\n], function (Dropdown, Icon, ColorPalette) {\n    'use strict';\n    return class DropdownColor extends Dropdown {\n        constructor(iconName, color) {\n            const icon = new Icon(iconName).css('height', '16px').css('border-bottom', `3px solid ${ color }`);\n            const colorPalette = new ColorPalette();\n            colorPalette.change = v => {\n                this.setTitle(v);\n                this.change(v);\n            };\n            super(icon, 'auto', false, 'bottom-left', colorPalette.el);\n        }\n        setTitle(color) {\n            this.title.css('border-color', color);\n            this.hide();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_linetype',[\n    './dropdown',\n    './element',\n    './icon',\n    '../config'\n], function (Dropdown, m_element, Icon, m_config) {\n    'use strict';\n    const lineTypes = [\n        [\n            'thin',\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"1\" style=\"user-select: none;\"><line x1=\"0\" y1=\"0.5\" x2=\"50\" y2=\"0.5\" stroke-width=\"1\" stroke=\"black\" style=\"user-select: none;\"></line></svg>'\n        ],\n        [\n            'medium',\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"2\" style=\"user-select: none;\"><line x1=\"0\" y1=\"1.0\" x2=\"50\" y2=\"1.0\" stroke-width=\"2\" stroke=\"black\" style=\"user-select: none;\"></line></svg>'\n        ],\n        [\n            'thick',\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"3\" style=\"user-select: none;\"><line x1=\"0\" y1=\"1.5\" x2=\"50\" y2=\"1.5\" stroke-width=\"3\" stroke=\"black\" style=\"user-select: none;\"></line></svg>'\n        ],\n        [\n            'dashed',\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"1\" style=\"user-select: none;\"><line x1=\"0\" y1=\"0.5\" x2=\"50\" y2=\"0.5\" stroke-width=\"1\" stroke=\"black\" stroke-dasharray=\"2\" style=\"user-select: none;\"></line></svg>'\n        ],\n        [\n            'dotted',\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"1\" style=\"user-select: none;\"><line x1=\"0\" y1=\"0.5\" x2=\"50\" y2=\"0.5\" stroke-width=\"1\" stroke=\"black\" stroke-dasharray=\"1\" style=\"user-select: none;\"></line></svg>'\n        ]\n    ];\n    return class DropdownLineType extends Dropdown {\n        constructor(type) {\n            const icon = new Icon('line-type');\n            let beforei = 0;\n            const lineTypeEls = lineTypes.map((it, iti) => m_element.h('div', `${ m_config.cssPrefix }-item state ${ type === it[0] ? 'checked' : '' }`).on('click', () => {\n                lineTypeEls[beforei].toggle('checked');\n                lineTypeEls[iti].toggle('checked');\n                beforei = iti;\n                this.hide();\n                this.change(it);\n            }).child(m_element.h('div', `${ m_config.cssPrefix }-line-type`).html(it[1])));\n            super(icon, 'auto', false, 'bottom-left', ...lineTypeEls);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/border_palette',[\n    './element',\n    './icon',\n    './dropdown_color',\n    './dropdown_linetype',\n    '../config'\n], function (m_element, Icon, DropdownColor, DropdownLineType, m_config) {\n    'use strict';\n    function buildTable(...trs) {\n        return m_element.h('table', '').child(m_element.h('tbody', '').children(...trs));\n    }\n    function buildTd(iconName) {\n        return m_element.h('td', '').child(m_element.h('div', `${ m_config.cssPrefix }-border-palette-cell`).child(new Icon(`border-${ iconName }`)).on('click', () => {\n            this.mode = iconName;\n            const {mode, style, color} = this;\n            this.change({\n                mode,\n                style,\n                color\n            });\n        }));\n    }\n    return class BorderPalette {\n        constructor() {\n            this.color = '#000';\n            this.style = 'thin';\n            this.mode = 'all';\n            this.change = () => {\n            };\n            this.ddColor = new DropdownColor('line-color', this.color);\n            this.ddColor.change = color => {\n                this.color = color;\n            };\n            this.ddType = new DropdownLineType(this.style);\n            this.ddType.change = ([s]) => {\n                this.style = s;\n            };\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-border-palette`);\n            const table = buildTable(m_element.h('tr', '').children(m_element.h('td', `${ m_config.cssPrefix }-border-palette-left`).child(buildTable(m_element.h('tr', '').children(...[\n                'all',\n                'inside',\n                'horizontal',\n                'vertical',\n                'outside'\n            ].map(it => buildTd.call(this, it))), m_element.h('tr', '').children(...[\n                'left',\n                'top',\n                'right',\n                'bottom',\n                'none'\n            ].map(it => buildTd.call(this, it))))), m_element.h('td', `${ m_config.cssPrefix }-border-palette-right`).children(m_element.h('div', `${ m_config.cssPrefix }-toolbar-btn`).child(this.ddColor.el), m_element.h('div', `${ m_config.cssPrefix }-toolbar-btn`).child(this.ddType.el))));\n            this.el.child(table);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_border',[\n    './dropdown',\n    './icon',\n    './border_palette'\n], function (Dropdown, Icon, BorderPalette) {\n    'use strict';\n    return class DropdownBorder extends Dropdown {\n        constructor() {\n            const icon = new Icon('border-all');\n            const borderPalette = new BorderPalette();\n            borderPalette.change = v => {\n                this.change(v);\n                this.hide();\n            };\n            super(icon, 'auto', false, 'bottom-left', borderPalette.el);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/border',[\n    './dropdown_item',\n    '../dropdown_border'\n], function (DropdownItem, DropdownBorder) {\n    'use strict';\n    class Border extends DropdownItem {\n        constructor() {\n            super('border');\n        }\n        dropdown() {\n            return new DropdownBorder();\n        }\n    }\n\n    return Border;\n});\ndefine('skylark-xspreadsheet/component/toolbar/icon_item',[\n    './item',\n    '../icon'\n], function (Item, Icon) {\n    'use strict';\n    return class IconItem extends Item {\n        element() {\n            return super.element().child(new Icon(this.tag)).on('click', () => this.change(this.tag));\n        }\n        setState(disabled) {\n            this.el.disabled(disabled);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/clearformat',['./icon_item'], function (IconItem) {\n    'use strict';\n    return class Clearformat extends IconItem {\n        constructor() {\n            super('clearformat');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/paintformat',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Paintformat extends ToggleItem {\n        constructor() {\n            super('paintformat');\n        }\n        setState() {\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/text_color',[\n    './dropdown_item',\n    '../dropdown_color'\n], function (DropdownItem, DropdownColor) {\n    'use strict';\n    return class TextColor extends DropdownItem {\n        constructor(color) {\n            super('color', undefined, color);\n        }\n        dropdown() {\n            const {tag, value} = this;\n            return new DropdownColor(tag, value);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/fill_color',[\n    './dropdown_item',\n    '../dropdown_color'\n], function (DropdownItem, DropdownColor) {\n    'use strict';\n    return class FillColor extends DropdownItem {\n        constructor(color) {\n            super('bgcolor', undefined, color);\n        }\n        dropdown() {\n            const {tag, value} = this;\n            return new DropdownColor(tag, value);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_fontsize',[\n    './dropdown',\n    './element',\n    '../core/font',\n    '../config'\n], function (Dropdown, m_element, m_font, m_config) {\n    'use strict';\n    return class DropdownFontSize extends Dropdown {\n        constructor() {\n            const nfontSizes = m_font.fontSizes.map(it => m_element.h('div', `${ m_config.cssPrefix }-item`).on('click', () => {\n                this.setTitle(`${ it.pt }`);\n                this.change(it);\n            }).child(`${ it.pt }`));\n            super('10', '60px', true, 'bottom-left', ...nfontSizes);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/font_size',[\n    './dropdown_item',\n    '../dropdown_fontsize'\n], function (DropdownItem, DropdownFontsize) {\n    'use strict';\n    return class Format extends DropdownItem {\n        constructor() {\n            super('font-size');\n        }\n        getValue(it) {\n            return it.pt;\n        }\n        dropdown() {\n            return new DropdownFontsize();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_font',[\n    './dropdown',\n    './element',\n    '../core/font',\n    '../config'\n], function (Dropdown, m_element, m_font, m_config) {\n    'use strict';\n    return class DropdownFont extends Dropdown {\n        constructor() {\n            const nfonts = m_font.baseFonts.map(it => m_element.h('div', `${ m_config.cssPrefix }-item`).on('click', () => {\n                this.setTitle(it.title);\n                this.change(it);\n            }).child(it.title));\n            super(m_font.baseFonts[0].title, '160px', true, 'bottom-left', ...nfonts);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/font',[\n    './dropdown_item',\n    '../dropdown_font'\n], function (DropdownItem, DropdownFont) {\n    'use strict';\n    return class Font extends DropdownItem {\n        constructor() {\n            super('font-name');\n        }\n        getValue(it) {\n            return it.key;\n        }\n        dropdown() {\n            return new DropdownFont();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_format',[\n    './dropdown',\n    './element',\n    '../core/format',\n    '../config'\n], function (Dropdown, m_element, m_format, m_config) {\n    'use strict';\n    return class DropdownFormat extends Dropdown {\n        constructor() {\n            let nformats = m_format.baseFormats.slice(0);\n            nformats.splice(2, 0, { key: 'divider' });\n            nformats.splice(8, 0, { key: 'divider' });\n            nformats = nformats.map(it => {\n                const item = m_element.h('div', `${ m_config.cssPrefix }-item`);\n                if (it.key === 'divider') {\n                    item.addClass('divider');\n                } else {\n                    item.child(it.title()).on('click', () => {\n                        this.setTitle(it.title());\n                        this.change(it);\n                    });\n                    if (it.label)\n                        item.child(m_element.h('div', 'label').html(it.label));\n                }\n                return item;\n            });\n            super('Normal', '220px', true, 'bottom-left', ...nformats);\n        }\n        setTitle(key) {\n            for (let i = 0; i < m_format.baseFormats.length; i += 1) {\n                if (m_format.baseFormats[i].key === key) {\n                    this.title.html(m_format.baseFormats[i].title());\n                }\n            }\n            this.hide();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/format',[\n    './dropdown_item',\n    '../dropdown_format'\n], function (DropdownItem, DropdownFormat) {\n    'use strict';\n    return class Format extends DropdownItem {\n        constructor() {\n            super('format');\n        }\n        getValue(it) {\n            return it.key;\n        }\n        dropdown() {\n            return new DropdownFormat();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/dropdown_formula',[\n    './dropdown',\n    './icon',\n    './element',\n    '../core/formula',\n    '../config'\n], function (Dropdown, Icon, m_element, m_formula, m_config) {\n    'use strict';\n    return class DropdownFormula extends Dropdown {\n        constructor() {\n            const nformulas = m_formula.baseFormulas.map(it => m_element.h('div', `${ m_config.cssPrefix }-item`).on('click', () => {\n                this.hide();\n                this.change(it);\n            }).child(it.key));\n            super(new Icon('formula'), '180px', true, 'bottom-left', ...nformulas);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/formula',[\n    './dropdown_item',\n    '../dropdown_formula'\n], function (DropdownItem, DropdownFormula) {\n    'use strict';\n    return class Format extends DropdownItem {\n        constructor() {\n            super('formula');\n        }\n        getValue(it) {\n            return it.key;\n        }\n        dropdown() {\n            return new DropdownFormula();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/freeze',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Freeze extends ToggleItem {\n        constructor() {\n            super('freeze');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/merge',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Merge extends ToggleItem {\n        constructor() {\n            super('merge');\n        }\n        setState(active, disabled) {\n            this.el.active(active).disabled(disabled);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/redo',['./icon_item'], function (IconItem) {\n    'use strict';\n    return class Redo extends IconItem {\n        constructor() {\n            super('redo', 'Ctrl+Y');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/undo',['./icon_item'], function (IconItem) {\n    'use strict';\n    return class Undo extends IconItem {\n        constructor() {\n            super('undo', 'Ctrl+Z');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/print',['./icon_item'], function (IconItem) {\n    'use strict';\n    return class Print extends IconItem {\n        constructor() {\n            super('print', 'Ctrl+P');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/textwrap',['./toggle_item'], function (ToggleItem) {\n    'use strict';\n    return class Textwrap extends ToggleItem {\n        constructor() {\n            super('textwrap');\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/more',[\n    '../dropdown',\n    './dropdown_item',\n    '../../config',\n    '../element',\n    '../icon'\n], function (Dropdown, DropdownItem, a, b, Icon) {\n    'use strict';\n    class DropdownMore extends Dropdown {\n        constructor() {\n            const icon = new Icon('ellipsis');\n            const moreBtns = b.h('div', `${ a.cssPrefix }-toolbar-more`);\n            super(icon, 'auto', false, 'bottom-right', moreBtns);\n            this.moreBtns = moreBtns;\n            this.contentEl.css('max-width', '420px');\n        }\n    }\n    return class More extends DropdownItem {\n        constructor() {\n            super('more');\n            this.el.hide();\n        }\n        dropdown() {\n            return new DropdownMore();\n        }\n        show() {\n            this.el.show();\n        }\n        hide() {\n            this.el.hide();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/toolbar/index',[\n    './align',\n    './valign',\n    './autofilter',\n    './bold',\n    './italic',\n    './strike',\n    './underline',\n    './border',\n    './clearformat',\n    './paintformat',\n    './text_color',\n    './fill_color',\n    './font_size',\n    './font',\n    './format',\n    './formula',\n    './freeze',\n    './merge',\n    './redo',\n    './undo',\n    './print',\n    './textwrap',\n    './more',\n    '../element',\n    '../../config',\n    '../event'\n], function (Align, Valign, Autofilter, Bold, Italic, Strike, Underline, Border, Clearformat, Paintformat, TextColor, FillColor, FontSize, Font, Format, Formula, Freeze, Merge, Redo, Undo, Print, Textwrap, More, a, b, c) {\n    'use strict';\n    function buildDivider() {\n        return a.h('div', `${ b.cssPrefix }-toolbar-divider`);\n    }\n    function initBtns2() {\n        this.btns2 = [];\n        this.items.forEach(it => {\n            if (Array.isArray(it)) {\n                it.forEach(({el}) => {\n                    const rect = el.box();\n                    const {marginLeft, marginRight} = el.computedStyle();\n                    this.btns2.push([\n                        el,\n                        rect.width + parseInt(marginLeft, 10) + parseInt(marginRight, 10)\n                    ]);\n                });\n            } else {\n                const rect = it.box();\n                const {marginLeft, marginRight} = it.computedStyle();\n                this.btns2.push([\n                    it,\n                    rect.width + parseInt(marginLeft, 10) + parseInt(marginRight, 10)\n                ]);\n            }\n        });\n    }\n    function moreResize() {\n        const {el, btns, moreEl, btns2} = this;\n        const {moreBtns, contentEl} = moreEl.dd;\n        el.css('width', `${ this.widthFn() - 60 }px`);\n        const elBox = el.box();\n        let sumWidth = 160;\n        let sumWidth2 = 12;\n        const list1 = [];\n        const list2 = [];\n        btns2.forEach(([it, w], index) => {\n            sumWidth += w;\n            if (index === btns2.length - 1 || sumWidth < elBox.width) {\n                list1.push(it);\n            } else {\n                sumWidth2 += w;\n                list2.push(it);\n            }\n        });\n        btns.html('').children(...list1);\n        moreBtns.html('').children(...list2);\n        contentEl.css('width', `${ sumWidth2 }px`);\n        if (list2.length > 0) {\n            moreEl.show();\n        } else {\n            moreEl.hide();\n        }\n    }\n    return class Toolbar {\n        constructor(data, widthFn, isHide = false) {\n            this.data = data;\n            this.change = () => {\n            };\n            this.widthFn = widthFn;\n            this.isHide = isHide;\n            const style = data.defaultStyle();\n            this.items = [\n                [\n                    this.undoEl = new Undo(),\n                    this.redoEl = new Redo(),\n                    new Print(),\n                    this.paintformatEl = new Paintformat(),\n                    this.clearformatEl = new Clearformat()\n                ],\n                buildDivider(),\n                [this.formatEl = new Format()],\n                buildDivider(),\n                [\n                    this.fontEl = new Font(),\n                    this.fontSizeEl = new FontSize()\n                ],\n                buildDivider(),\n                [\n                    this.boldEl = new Bold(),\n                    this.italicEl = new Italic(),\n                    this.underlineEl = new Underline(),\n                    this.strikeEl = new Strike(),\n                    this.textColorEl = new TextColor(style.color)\n                ],\n                buildDivider(),\n                [\n                    this.fillColorEl = new FillColor(style.bgcolor),\n                    this.borderEl = new Border(),\n                    this.mergeEl = new Merge()\n                ],\n                buildDivider(),\n                [\n                    this.alignEl = new Align(style.align),\n                    this.valignEl = new Valign(style.valign),\n                    this.textwrapEl = new Textwrap()\n                ],\n                buildDivider(),\n                [\n                    this.freezeEl = new Freeze(),\n                    this.autofilterEl = new Autofilter(),\n                    this.formulaEl = new Formula(),\n                    this.moreEl = new More()\n                ]\n            ];\n            this.el = a.h('div', `${ b.cssPrefix }-toolbar`);\n            this.btns = a.h('div', `${ b.cssPrefix }-toolbar-btns`);\n            this.items.forEach(it => {\n                if (Array.isArray(it)) {\n                    it.forEach(i => {\n                        this.btns.child(i.el);\n                        i.change = (...args) => {\n                            this.change(...args);\n                        };\n                    });\n                } else {\n                    this.btns.child(it.el);\n                }\n            });\n            this.el.child(this.btns);\n            if (isHide) {\n                this.el.hide();\n            } else {\n                this.reset();\n                setTimeout(() => {\n                    initBtns2.call(this);\n                    moreResize.call(this);\n                }, 0);\n                c.bind(window, 'resize', () => {\n                    moreResize.call(this);\n                });\n            }\n        }\n        paintformatActive() {\n            return this.paintformatEl.active();\n        }\n        paintformatToggle() {\n            this.paintformatEl.toggle();\n        }\n        trigger(type) {\n            this[`${ type }El`].click();\n        }\n        resetData(data) {\n            this.data = data;\n            this.reset();\n        }\n        reset() {\n            if (this.isHide)\n                return;\n            const {data} = this;\n            const style = data.getSelectedCellStyle();\n            this.undoEl.setState(!data.canUndo());\n            this.redoEl.setState(!data.canRedo());\n            this.mergeEl.setState(data.canUnmerge(), !data.selector.multiple());\n            this.autofilterEl.setState(!data.canAutofilter());\n            const {font, format} = style;\n            this.formatEl.setState(format);\n            this.fontEl.setState(font.name);\n            this.fontSizeEl.setState(font.size);\n            this.boldEl.setState(font.bold);\n            this.italicEl.setState(font.italic);\n            this.underlineEl.setState(style.underline);\n            this.strikeEl.setState(style.strike);\n            this.textColorEl.setState(style.color);\n            this.fillColorEl.setState(style.bgcolor);\n            this.alignEl.setState(style.align);\n            this.valignEl.setState(style.valign);\n            this.textwrapEl.setState(style.textwrap);\n            this.freezeEl.setState(data.freezeIsActive());\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/modal',[\n    './element',\n    './icon',\n    '../config',\n    './event'\n], function (m_element, Icon, m_config, m_event) {\n    'use strict';\n    return class Modal {\n        constructor(title, content, width = '600px') {\n            this.title = title;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-modal`).css('width', width).children(m_element.h('div', `${ m_config.cssPrefix }-modal-header`).children(new Icon('close').on('click.stop', () => this.hide()), this.title), m_element.h('div', `${ m_config.cssPrefix }-modal-content`).children(...content)).hide();\n        }\n        show() {\n            this.dimmer = m_element.h('div', `${ m_config.cssPrefix }-dimmer active`);\n            document.body.appendChild(this.dimmer.el);\n            const {width, height} = this.el.show().box();\n            const {clientHeight, clientWidth} = document.documentElement;\n            this.el.offset({\n                left: (clientWidth - width) / 2,\n                top: (clientHeight - height) / 3\n            });\n            window.xkeydownEsc = evt => {\n                if (evt.keyCode === 27) {\n                    this.hide();\n                }\n            };\n            m_event.bind(window, 'keydown', window.xkeydownEsc);\n        }\n        hide() {\n            this.el.hide();\n            document.body.removeChild(this.dimmer.el);\n            m_event.unbind(window, 'keydown', window.xkeydownEsc);\n            delete window.xkeydownEsc;\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/form_input',[\n    './element',\n    '../config'\n], function (m_element, m_config) {\n    'use strict';\n    return class FormInput {\n        constructor(width, hint) {\n            this.vchange = () => {\n            };\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-form-input`);\n            this.input = m_element.h('input', '').css('width', width).on('input', evt => this.vchange(evt)).attr('placeholder', hint);\n            this.el.child(this.input);\n        }\n        focus() {\n            setTimeout(() => {\n                this.input.el.focus();\n            }, 10);\n        }\n        hint(v) {\n            this.input.attr('placeholder', v);\n        }\n        val(v) {\n            return this.input.val(v);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/form_select',[\n    './element',\n    './suggest',\n    '../config'\n], function (m_element, Suggest, m_config) {\n    'use strict';\n    return class FormSelect {\n        constructor(key, items, width, getTitle = it => it, change = () => {\n        }) {\n            this.key = key;\n            this.getTitle = getTitle;\n            this.vchange = () => {\n            };\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-form-select`);\n            this.suggest = new Suggest(items.map(it => ({\n                key: it,\n                title: this.getTitle(it)\n            })), it => {\n                this.itemClick(it.key);\n                change(it.key);\n                this.vchange(it.key);\n            }, width, this.el);\n            this.el.children(this.itemEl = m_element.h('div', 'input-text').html(this.getTitle(key)), this.suggest.el).on('click', () => this.show());\n        }\n        show() {\n            this.suggest.search('');\n        }\n        itemClick(it) {\n            this.key = it;\n            this.itemEl.html(this.getTitle(it));\n        }\n        val(v) {\n            if (v !== undefined) {\n                this.key = v;\n                this.itemEl.html(this.getTitle(v));\n                return this;\n            }\n            return this.key;\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/form_field',[\n    './element',\n    '../config',\n    '../locale/locale'\n], function (m_element, m_config, m_locale) {\n    'use strict';\n    const patterns = {\n        number: /(^\\d+$)|(^\\d+(\\.\\d{0,4})?$)/,\n        date: /^\\d{4}-\\d{1,2}-\\d{1,2}$/\n    };\n    return class FormField {\n        constructor(input, rule, label, labelWidth) {\n            this.label = '';\n            this.rule = rule;\n            if (label) {\n                this.label = m_element.h('label', 'label').css('width', `${ labelWidth }px`).html(label);\n            }\n            this.tip = m_element.h('div', 'tip').child('tip').hide();\n            this.input = input;\n            this.input.vchange = () => this.validate();\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-form-field`).children(this.label, input.el, this.tip);\n        }\n        isShow() {\n            return this.el.css('display') !== 'none';\n        }\n        show() {\n            this.el.show();\n        }\n        hide() {\n            this.el.hide();\n            return this;\n        }\n        val(v) {\n            return this.input.val(v);\n        }\n        hint(hint) {\n            this.input.hint(hint);\n        }\n        validate() {\n            const {input, rule, tip, el} = this;\n            const v = input.val();\n            if (rule.required) {\n                if (/^\\s*$/.test(v)) {\n                    tip.html(m_locale.t('validation.required'));\n                    el.addClass('error');\n                    return false;\n                }\n            }\n            if (rule.type || rule.pattern) {\n                const pattern = rule.pattern || patterns[rule.type];\n                if (!pattern.test(v)) {\n                    tip.html(m_locale.t('validation.notMatch'));\n                    el.addClass('error');\n                    return false;\n                }\n            }\n            el.removeClass('error');\n            return true;\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/modal_validation',[\n    './modal',\n    './form_input',\n    './form_select',\n    './form_field',\n    './button',\n    '../locale/locale',\n    './element',\n    '../config'\n], function (Modal, FormInput, FormSelect, FormField, Button, m_locale, m_element, m_config) {\n    'use strict';\n    const fieldLabelWidth = 100;\n    return class ModalValidation extends Modal {\n        constructor() {\n            const mf = new FormField(new FormSelect('cell', ['cell'], '100%', it => m_locale.t(`dataValidation.modeType.${ it }`)), { required: true }, `${ m_locale.t('dataValidation.range') }:`, fieldLabelWidth);\n            const rf = new FormField(new FormInput('120px', 'E3 or E3:F12'), {\n                required: true,\n                pattern: /^([A-Z]{1,2}[1-9]\\d*)(:[A-Z]{1,2}[1-9]\\d*)?$/\n            });\n            const cf = new FormField(new FormSelect('list', [\n                'list',\n                'number',\n                'date',\n                'phone',\n                'email'\n            ], '100%', it => m_locale.t(`dataValidation.type.${ it }`), it => this.criteriaSelected(it)), { required: true }, `${ m_locale.t('dataValidation.criteria') }:`, fieldLabelWidth);\n            const of = new FormField(new FormSelect('be', [\n                'be',\n                'nbe',\n                'eq',\n                'neq',\n                'lt',\n                'lte',\n                'gt',\n                'gte'\n            ], '160px', it => m_locale.t(`dataValidation.operator.${ it }`), it => this.criteriaOperatorSelected(it)), { required: true }).hide();\n            const minvf = new FormField(new FormInput('70px', '10'), { required: true }).hide();\n            const maxvf = new FormField(new FormInput('70px', '100'), {\n                required: true,\n                type: 'number'\n            }).hide();\n            const svf = new FormField(new FormInput('120px', 'a,b,m_config'), { required: true });\n            const vf = new FormField(new FormInput('70px', '10'), {\n                required: true,\n                type: 'number'\n            }).hide();\n            super(m_locale.t('contextmenu.validation'), [\n                m_element.h('div', `${ m_config.cssPrefix }-form-fields`).children(mf.el, rf.el),\n                m_element.h('div', `${ m_config.cssPrefix }-form-fields`).children(cf.el, of.el, minvf.el, maxvf.el, vf.el, svf.el),\n                m_element.h('div', `${ m_config.cssPrefix }-buttons`).children(new Button('cancel').on('click', () => this.btnClick('cancel')), new Button('remove').on('click', () => this.btnClick('remove')), new Button('save', 'primary').on('click', () => this.btnClick('save')))\n            ]);\n            this.mf = mf;\n            this.rf = rf;\n            this.cf = cf;\n            this.of = of;\n            this.minvf = minvf;\n            this.maxvf = maxvf;\n            this.vf = vf;\n            this.svf = svf;\n            this.change = () => {\n            };\n        }\n        showVf(it) {\n            const hint = it === 'date' ? '2018-11-12' : '10';\n            const {vf} = this;\n            vf.input.hint(hint);\n            vf.show();\n        }\n        criteriaSelected(it) {\n            const {of, minvf, maxvf, vf, svf} = this;\n            if (it === 'date' || it === 'number') {\n                of.show();\n                minvf.rule.type = it;\n                maxvf.rule.type = it;\n                if (it === 'date') {\n                    minvf.hint('2018-11-12');\n                    maxvf.hint('2019-11-12');\n                } else {\n                    minvf.hint('10');\n                    maxvf.hint('100');\n                }\n                minvf.show();\n                maxvf.show();\n                vf.hide();\n                svf.hide();\n            } else {\n                if (it === 'list') {\n                    svf.show();\n                } else {\n                    svf.hide();\n                }\n                vf.hide();\n                of.hide();\n                minvf.hide();\n                maxvf.hide();\n            }\n        }\n        criteriaOperatorSelected(it) {\n            if (!it)\n                return;\n            const {minvf, maxvf, vf} = this;\n            if (it === 'be' || it === 'nbe') {\n                minvf.show();\n                maxvf.show();\n                vf.hide();\n            } else {\n                const type = this.cf.val();\n                vf.rule.type = type;\n                if (type === 'date') {\n                    vf.hint('2018-11-12');\n                } else {\n                    vf.hint('10');\n                }\n                vf.show();\n                minvf.hide();\n                maxvf.hide();\n            }\n        }\n        btnClick(action) {\n            if (action === 'cancel') {\n                this.hide();\n            } else if (action === 'remove') {\n                this.change('remove');\n                this.hide();\n            } else if (action === 'save') {\n                const attrs = [\n                    'mf',\n                    'rf',\n                    'cf',\n                    'of',\n                    'svf',\n                    'vf',\n                    'minvf',\n                    'maxvf'\n                ];\n                for (let i = 0; i < attrs.length; i += 1) {\n                    const field = this[attrs[i]];\n                    if (field.isShow()) {\n                        if (!field.validate())\n                            return;\n                    }\n                }\n                const mode = this.mf.val();\n                const ref = this.rf.val();\n                const type = this.cf.val();\n                const operator = this.of.val();\n                let value = this.svf.val();\n                if (type === 'number' || type === 'date') {\n                    if (operator === 'be' || operator === 'nbe') {\n                        value = [\n                            this.minvf.val(),\n                            this.maxvf.val()\n                        ];\n                    } else {\n                        value = this.vf.val();\n                    }\n                }\n                this.change('save', mode, ref, {\n                    type,\n                    operator,\n                    required: false,\n                    value\n                });\n                this.hide();\n            }\n        }\n        setValue(v) {\n            if (v) {\n                const {mf, rf, cf, of, svf, vf, minvf, maxvf} = this;\n                const {mode, ref, validator} = v;\n                const {type, operator, value} = validator || { type: 'list' };\n                mf.val(mode || 'cell');\n                rf.val(ref);\n                cf.val(type);\n                of.val(operator);\n                if (Array.isArray(value)) {\n                    minvf.val(value[0]);\n                    maxvf.val(value[1]);\n                } else {\n                    svf.val(value || '');\n                    vf.val(value || '');\n                }\n                this.criteriaSelected(type);\n                this.criteriaOperatorSelected(operator);\n            }\n            this.show();\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/sort_filter',[\n    './element',\n    './button',\n    './event',\n    '../config',\n    '../locale/locale'\n], function (m_element, Button, m_event, m_config, m_locale) {\n    'use strict';\n    function buildMenu(clsName) {\n        return m_element.h('div', `${ m_config.cssPrefix }-item ${ clsName }`);\n    }\n    function buildSortItem(it) {\n        return buildMenu('state').child(m_locale.t(`sort.${ it }`)).on('click.stop', () => this.itemClick(it));\n    }\n    function buildFilterBody(items) {\n        const {filterbEl, filterValues} = this;\n        filterbEl.html('');\n        const itemKeys = Object.keys(items);\n        itemKeys.forEach((it, index) => {\n            const cnt = items[it];\n            const active = filterValues.includes(it) ? 'checked' : '';\n            filterbEl.child(m_element.h('div', `${ m_config.cssPrefix }-item state ${ active }`).on('click.stop', () => this.filterClick(index, it)).children(it === '' ? m_locale.t('filter.empty') : it, m_element.h('div', 'label').html(`(${ cnt })`)));\n        });\n    }\n    function resetFilterHeader() {\n        const {filterhEl, filterValues, values} = this;\n        filterhEl.html(`${ filterValues.length } / ${ values.length }`);\n        filterhEl.checked(filterValues.length === values.length);\n    }\n    return class SortFilter {\n        constructor() {\n            this.filterbEl = m_element.h('div', `${ m_config.cssPrefix }-body`);\n            this.filterhEl = m_element.h('div', `${ m_config.cssPrefix }-header state`).on('click.stop', () => this.filterClick(0, 'all'));\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-sort-filter`).children(this.sortAscEl = buildSortItem.call(this, 'asc'), this.sortDescEl = buildSortItem.call(this, 'desc'), buildMenu('divider'), m_element.h('div', `${ m_config.cssPrefix }-filter`).children(this.filterhEl, this.filterbEl), m_element.h('div', `${ m_config.cssPrefix }-buttons`).children(new Button('cancel').on('click', () => this.btnClick('cancel')), new Button('ok', 'primary').on('click', () => this.btnClick('ok')))).hide();\n            this.ci = null;\n            this.sortDesc = null;\n            this.values = null;\n            this.filterValues = [];\n        }\n        btnClick(it) {\n            if (it === 'ok') {\n                const {ci, sort, filterValues} = this;\n                if (this.ok) {\n                    this.ok(ci, sort, 'in', filterValues);\n                }\n            }\n            this.hide();\n        }\n        itemClick(it) {\n            this.sort = it;\n            const {sortAscEl, sortDescEl} = this;\n            sortAscEl.checked(it === 'asc');\n            sortDescEl.checked(it === 'desc');\n        }\n        filterClick(index, it) {\n            const {filterbEl, filterValues, values} = this;\n            const children = filterbEl.children();\n            if (it === 'all') {\n                if (children.length === filterValues.length) {\n                    this.filterValues = [];\n                    children.forEach(i => m_element.h(i).checked(false));\n                } else {\n                    this.filterValues = Array.from(values);\n                    children.forEach(i => m_element.h(i).checked(true));\n                }\n            } else {\n                const checked = m_element.h(children[index]).toggle('checked');\n                if (checked) {\n                    filterValues.push(it);\n                } else {\n                    filterValues.splice(filterValues.findIndex(i => i === it), 1);\n                }\n            }\n            resetFilterHeader.call(this);\n        }\n        set(ci, items, filter, sort) {\n            this.ci = ci;\n            const {sortAscEl, sortDescEl} = this;\n            if (sort !== null) {\n                this.sort = sort.order;\n                sortAscEl.checked(sort.asc());\n                sortDescEl.checked(sort.desc());\n            } else {\n                this.sortDesc = null;\n                sortAscEl.checked(false);\n                sortDescEl.checked(false);\n            }\n            this.values = Object.keys(items);\n            this.filterValues = filter ? Array.from(filter.value) : Object.keys(items);\n            buildFilterBody.call(this, items, filter);\n            resetFilterHeader.call(this);\n        }\n        setOffset(v) {\n            this.el.offset(v).show();\n            let tindex = 1;\n            m_event.bindClickoutside(this.el, () => {\n                if (tindex <= 0) {\n                    this.hide();\n                }\n                tindex -= 1;\n            });\n        }\n        show() {\n            this.el.show();\n        }\n        hide() {\n            this.el.hide();\n            m_event.unbindClickoutside(this.el);\n        }\n    };\n});\ndefine('skylark-xspreadsheet/component/message',[\n    './element',\n    './icon',\n    '../config'\n], function (m_element, Icon, m_config) {\n    'use strict';\n    function xtoast(title, content) {\n        const el = m_element.h('div', `${ m_config.cssPrefix }-toast`);\n        const dimmer = m_element.h('div', `${ m_config.cssPrefix }-dimmer active`);\n        const remove = () => {\n            document.body.removeChild(el.el);\n            document.body.removeChild(dimmer.el);\n        };\n        el.children(m_element.h('div', `${ m_config.cssPrefix }-toast-header`).children(new Icon('close').on('click.stop', () => remove()), title), m_element.h('div', `${ m_config.cssPrefix }-toast-content`).html(content));\n        document.body.appendChild(el.el);\n        document.body.appendChild(dimmer.el);\n        const {width, height} = el.box();\n        const {clientHeight, clientWidth} = document.documentElement;\n        el.offset({\n            left: (clientWidth - width) / 2,\n            top: (clientHeight - height) / 3\n        });\n    }\n    return {\n        xtoast\n    };\n});\ndefine('skylark-xspreadsheet/component/sheet',[\n    './element',\n    './event',\n    './resizer',\n    './scrollbar',\n    './selector',\n    './editor',\n    './print',\n    './contextmenu',\n    './table',\n    './toolbar/index',\n    './modal_validation',\n    './sort_filter',\n    './message',\n    '../config',\n    '../core/formula'\n], function (m_element, m_event, Resizer, Scrollbar, Selector, Editor, Print, ContextMenu, m_table, Toolbar, ModalValidation, SortFilter, m_message, m_config, m_formula) {\n    'use strict';\n\n/**\n * @desc throttle fn\n * @param func function\n * @param wait Delay in milliseconds\n */\n    function throttle(func, wait) {\n        let timeout;\n        return (...arg) => {\n            const that = this;\n            const args = arg;\n            if (!timeout) {\n                timeout = setTimeout(() => {\n                    timeout = null;\n                    func.apply(that, args);\n                }, wait);\n            }\n        };\n    }\n    function scrollbarMove() {\n        const {data, verticalScrollbar, horizontalScrollbar} = this;\n        const {l, t, left, top, width, height} = data.getSelectedRect();\n        const tableOffset = this.getTableOffset();\n        if (Math.abs(left) + width > tableOffset.width) {\n            horizontalScrollbar.move({ left: l + width - tableOffset.width });\n        } else {\n            const fsw = data.freezeTotalWidth();\n            if (left < fsw) {\n                horizontalScrollbar.move({ left: l - 1 - fsw });\n            }\n        }\n        if (Math.abs(top) + height > tableOffset.height) {\n            verticalScrollbar.move({ top: t + height - tableOffset.height - 1 });\n        } else {\n            const fsh = data.freezeTotalHeight();\n            if (top < fsh) {\n                verticalScrollbar.move({ top: t - 1 - fsh });\n            }\n        }\n    }\n    function selectorSet(multiple, ri, ci, indexesUpdated = true, moving = false) {\n        if (ri === -1 && ci === -1)\n            return;\n        const {table, selector, toolbar, data, contextMenu} = this;\n        contextMenu.setMode(ri === -1 || ci === -1 ? 'row-col' : 'range');\n        const cell = data.getCell(ri, ci);\n        if (multiple) {\n            selector.setEnd(ri, ci, moving);\n            this.trigger('cells-selected', cell, selector.range);\n        } else {\n            selector.set(ri, ci, indexesUpdated);\n            this.trigger('cell-selected', cell, ri, ci);\n        }\n        toolbar.reset();\n        table.render();\n    }\n\n// multiple: boolean\n// direction: left | right | up | down | row-first | row-last | col-first | col-last\n    function selectorMove(multiple, direction) {\n        const {selector, data} = this;\n        const {rows, cols} = data;\n        let [ri, ci] = selector.indexes;\n        const {eri, eci} = selector.range;\n        if (multiple) {\n            [ri, ci] = selector.moveIndexes;\n        }\n        if (direction === 'left') {\n            if (ci > 0)\n                ci -= 1;\n        } else if (direction === 'right') {\n            if (eci !== ci)\n                ci = eci;\n            if (ci < cols.len - 1)\n                ci += 1;\n        } else if (direction === 'up') {\n            if (ri > 0)\n                ri -= 1;\n        } else if (direction === 'down') {\n            if (eri !== ri)\n                ri = eri;\n            if (ri < rows.len - 1)\n                ri += 1;\n        } else if (direction === 'row-first') {\n            ci = 0;\n        } else if (direction === 'row-last') {\n            ci = cols.len - 1;\n        } else if (direction === 'col-first') {\n            ri = 0;\n        } else if (direction === 'col-last') {\n            ri = rows.len - 1;\n        }\n        if (multiple) {\n            selector.moveIndexes = [\n                ri,\n                ci\n            ];\n        }\n        selectorSet.call(this, multiple, ri, ci);\n        scrollbarMove.call(this);\n    }\n\n// private methods\n    function overlayerMousemove(evt) {\n        if (evt.buttons !== 0)\n            return;\n        if (evt.target.className === `${ m_config.cssPrefix }-resizer-hover`)\n            return;\n        const {offsetX, offsetY} = evt;\n        const {rowResizer, colResizer, tableEl, data} = this;\n        const {rows, cols} = data;\n        if (offsetX > cols.indexWidth && offsetY > rows.height) {\n            rowResizer.hide();\n            colResizer.hide();\n            return;\n        }\n        const tRect = tableEl.box();\n        const cRect = data.getCellRectByXY(evt.offsetX, evt.offsetY);\n        if (cRect.ri >= 0 && cRect.ci === -1) {\n            cRect.width = cols.indexWidth;\n            rowResizer.show(cRect, { width: tRect.width });\n            if (rows.isHide(cRect.ri - 1)) {\n                rowResizer.showUnhide(cRect.ri);\n            } else {\n                rowResizer.hideUnhide();\n            }\n        } else {\n            rowResizer.hide();\n        }\n        if (cRect.ri === -1 && cRect.ci >= 0) {\n            cRect.height = rows.height;\n            colResizer.show(cRect, { height: tRect.height });\n            if (cols.isHide(cRect.ci - 1)) {\n                colResizer.showUnhide(cRect.ci);\n            } else {\n                colResizer.hideUnhide();\n            }\n        } else {\n            colResizer.hide();\n        }\n    }\n    function overlayerMousescroll(evt) {\n        const {verticalScrollbar, horizontalScrollbar, data} = this;\n        const {top} = verticalScrollbar.scroll();\n        const {left} = horizontalScrollbar.scroll();\n        const {rows, cols} = data;\n        const {deltaY, deltaX} = evt;\n        const loopValue = (ii, vFunc) => {\n            let i = ii;\n            let v = 0;\n            do {\n                v = vFunc(i);\n                i += 1;\n            } while (v <= 0);\n            return v;\n        };\n        const moveY = vertical => {\n            if (vertical > 0) {\n                const ri = data.scroll.ri + 1;\n                if (ri < rows.len) {\n                    const rh = loopValue(ri, i => rows.getHeight(i));\n                    verticalScrollbar.move({ top: top + rh - 1 });\n                }\n            } else {\n                const ri = data.scroll.ri - 1;\n                if (ri >= 0) {\n                    const rh = loopValue(ri, i => rows.getHeight(i));\n                    verticalScrollbar.move({ top: ri === 0 ? 0 : top - rh });\n                }\n            }\n        };\n        const moveX = horizontal => {\n            if (horizontal > 0) {\n                const ci = data.scroll.ci + 1;\n                if (ci < cols.len) {\n                    const cw = loopValue(ci, i => cols.getWidth(i));\n                    horizontalScrollbar.move({ left: left + cw - 1 });\n                }\n            } else {\n                const ci = data.scroll.ci - 1;\n                if (ci >= 0) {\n                    const cw = loopValue(ci, i => cols.getWidth(i));\n                    horizontalScrollbar.move({ left: ci === 0 ? 0 : left - cw });\n                }\n            }\n        };\n        const tempY = Math.abs(deltaY);\n        const tempX = Math.abs(deltaX);\n        const temp = Math.max(tempY, tempX);\n        if (/Firefox/i.test(window.navigator.userAgent))\n            throttle(moveY(evt.detail), 50);\n        if (temp === tempX)\n            throttle(moveX(deltaX), 50);\n        if (temp === tempY)\n            throttle(moveY(deltaY), 50);\n    }\n    function overlayerTouch(direction, distance) {\n        const {verticalScrollbar, horizontalScrollbar} = this;\n        const {top} = verticalScrollbar.scroll();\n        const {left} = horizontalScrollbar.scroll();\n        if (direction === 'left' || direction === 'right') {\n            horizontalScrollbar.move({ left: left - distance });\n        } else if (direction === 'up' || direction === 'down') {\n            verticalScrollbar.move({ top: top - distance });\n        }\n    }\n    function verticalScrollbarSet() {\n        const {data, verticalScrollbar} = this;\n        const {height} = this.getTableOffset();\n        const erth = data.exceptRowTotalHeight(0, -1);\n        verticalScrollbar.set(height, data.rows.totalHeight() - erth);\n    }\n    function horizontalScrollbarSet() {\n        const {data, horizontalScrollbar} = this;\n        const {width} = this.getTableOffset();\n        if (data) {\n            horizontalScrollbar.set(width, data.cols.totalWidth());\n        }\n    }\n    function sheetFreeze() {\n        const {selector, data, editor} = this;\n        const [ri, ci] = data.freeze;\n        if (ri > 0 || ci > 0) {\n            const fwidth = data.freezeTotalWidth();\n            const fheight = data.freezeTotalHeight();\n            editor.setFreezeLengths(fwidth, fheight);\n        }\n        selector.resetAreaOffset();\n    }\n    function sheetReset() {\n        const {tableEl, overlayerEl, overlayerCEl, table, toolbar, selector, el} = this;\n        const tOffset = this.getTableOffset();\n        const vRect = this.getRect();\n        tableEl.attr(vRect);\n        overlayerEl.offset(vRect);\n        overlayerCEl.offset(tOffset);\n        el.css('width', `${ vRect.width }px`);\n        verticalScrollbarSet.call(this);\n        horizontalScrollbarSet.call(this);\n        sheetFreeze.call(this);\n        table.render();\n        toolbar.reset();\n        selector.reset();\n    }\n    function clearClipboard() {\n        const {data, selector} = this;\n        data.clearClipboard();\n        selector.hideClipboard();\n    }\n    function copy() {\n        const {data, selector} = this;\n        data.copy();\n        selector.showClipboard();\n    }\n    function cut() {\n        const {data, selector} = this;\n        data.cut();\n        selector.showClipboard();\n    }\n    function paste(what, evt) {\n        const {data} = this;\n        if (data.settings.mode === 'read')\n            return;\n        if (data.paste(what, msg => m_message.xtoast('Tip', msg))) {\n            sheetReset.call(this);\n        } else if (evt) {\n            const cdata = evt.clipboardData.getData('text/plain');\n            this.data.pasteFromText(cdata);\n            sheetReset.call(this);\n        }\n    }\n    function hideRowsOrCols() {\n        this.data.hideRowsOrCols();\n        sheetReset.call(this);\n    }\n    function unhideRowsOrCols(type, index) {\n        this.data.unhideRowsOrCols(type, index);\n        sheetReset.call(this);\n    }\n    function autofilter() {\n        const {data} = this;\n        data.autofilter();\n        sheetReset.call(this);\n    }\n    function toolbarChangePaintformatPaste() {\n        const {toolbar} = this;\n        if (toolbar.paintformatActive()) {\n            paste.call(this, 'format');\n            clearClipboard.call(this);\n            toolbar.paintformatToggle();\n        }\n    }\n    function overlayerMousedown(evt) {\n        const {selector, data, table, sortFilter} = this;\n        const {offsetX, offsetY} = evt;\n        const isAutofillEl = evt.target.className === `${ m_config.cssPrefix }-selector-corner`;\n        const cellRect = data.getCellRectByXY(offsetX, offsetY);\n        const {left, top, width, height} = cellRect;\n        let {ri, ci} = cellRect;\n        const {autoFilter} = data;\n        if (autoFilter.includes(ri, ci)) {\n            if (left + width - 20 < offsetX && top + height - 20 < offsetY) {\n                const items = autoFilter.items(ci, (r, c) => data.rows.getCell(r, c));\n                sortFilter.hide();\n                sortFilter.set(ci, items, autoFilter.getFilter(ci), autoFilter.getSort(ci));\n                sortFilter.setOffset({\n                    left,\n                    top: top + height + 2\n                });\n                return;\n            }\n        }\n        if (!evt.shiftKey) {\n            if (isAutofillEl) {\n                selector.showAutofill(ri, ci);\n            } else {\n                selectorSet.call(this, false, ri, ci);\n            }\n            m_event.mouseMoveUp(window, e => {\n                ({ri, ci} = data.getCellRectByXY(e.offsetX, e.offsetY));\n                if (isAutofillEl) {\n                    selector.showAutofill(ri, ci);\n                } else if (e.buttons === 1 && !e.shiftKey) {\n                    selectorSet.call(this, true, ri, ci, true, true);\n                }\n            }, () => {\n                if (isAutofillEl && selector.arange && data.settings.mode !== 'read') {\n                    if (data.autofill(selector.arange, 'all', msg => m_message.xtoast('Tip', msg))) {\n                        table.render();\n                    }\n                }\n                selector.hideAutofill();\n                toolbarChangePaintformatPaste.call(this);\n            });\n        }\n        if (!isAutofillEl && evt.buttons === 1) {\n            if (evt.shiftKey) {\n                selectorSet.call(this, true, ri, ci);\n            }\n        }\n    }\n    function editorSetOffset() {\n        const {editor, data} = this;\n        const sOffset = data.getSelectedRect();\n        const tOffset = this.getTableOffset();\n        let sPosition = 'top';\n        if (sOffset.top > tOffset.height / 2) {\n            sPosition = 'bottom';\n        }\n        editor.setOffset(sOffset, sPosition);\n    }\n    function editorSet() {\n        const {editor, data} = this;\n        if (data.settings.mode === 'read')\n            return;\n        editorSetOffset.call(this);\n        editor.setCell(data.getSelectedCell(), data.getSelectedValidator());\n        clearClipboard.call(this);\n    }\n    function verticalScrollbarMove(distance) {\n        const {data, table, selector} = this;\n        data.scrolly(distance, () => {\n            selector.resetBRLAreaOffset();\n            editorSetOffset.call(this);\n            table.render();\n        });\n    }\n    function horizontalScrollbarMove(distance) {\n        const {data, table, selector} = this;\n        data.scrollx(distance, () => {\n            selector.resetBRTAreaOffset();\n            editorSetOffset.call(this);\n            table.render();\n        });\n    }\n    function rowResizerFinished(cRect, distance) {\n        const {ri} = cRect;\n        const {table, selector, data} = this;\n        data.rows.setHeight(ri, distance);\n        table.render();\n        selector.resetAreaOffset();\n        verticalScrollbarSet.call(this);\n        editorSetOffset.call(this);\n    }\n    function colResizerFinished(cRect, distance) {\n        const {ci} = cRect;\n        const {table, selector, data} = this;\n        data.cols.setWidth(ci, distance);\n        table.render();\n        selector.resetAreaOffset();\n        horizontalScrollbarSet.call(this);\n        editorSetOffset.call(this);\n    }\n    function dataSetCellText(text, state = 'finished') {\n        const {data, table} = this;\n        if (data.settings.mode === 'read')\n            return;\n        data.setSelectedCellText(text, state);\n        const {ri, ci} = data.selector;\n        if (state === 'finished') {\n            table.render();\n        } else {\n            this.trigger('cell-edited', text, ri, ci);\n        }\n    }\n    function insertDeleteRowColumn(type) {\n        const {data} = this;\n        if (data.settings.mode === 'read')\n            return;\n        if (type === 'insert-row') {\n            data.insert('row');\n        } else if (type === 'delete-row') {\n            data.delete('row');\n        } else if (type === 'insert-column') {\n            data.insert('column');\n        } else if (type === 'delete-column') {\n            data.delete('column');\n        } else if (type === 'delete-cell') {\n            data.deleteCell();\n        } else if (type === 'delete-cell-format') {\n            data.deleteCell('format');\n        } else if (type === 'delete-cell-text') {\n            data.deleteCell('text');\n        } else if (type === 'cell-printable') {\n            data.setSelectedCellAttr('printable', true);\n        } else if (type === 'cell-non-printable') {\n            data.setSelectedCellAttr('printable', false);\n        } else if (type === 'cell-editable') {\n            data.setSelectedCellAttr('editable', true);\n        } else if (type === 'cell-non-editable') {\n            data.setSelectedCellAttr('editable', false);\n        }\n        clearClipboard.call(this);\n        sheetReset.call(this);\n    }\n    function toolbarChange(type, value) {\n        const {data} = this;\n        if (type === 'undo') {\n            this.undo();\n        } else if (type === 'redo') {\n            this.redo();\n        } else if (type === 'print') {\n            this.print.preview();\n        } else if (type === 'paintformat') {\n            if (value === true)\n                copy.call(this);\n            else\n                clearClipboard.call(this);\n        } else if (type === 'clearformat') {\n            insertDeleteRowColumn.call(this, 'delete-cell-format');\n        } else if (type === 'link') {\n        } else if (type === 'chart') {\n        } else if (type === 'autofilter') {\n            autofilter.call(this);\n        } else if (type === 'freeze') {\n            if (value) {\n                const {ri, ci} = data.selector;\n                this.freeze(ri, ci);\n            } else {\n                this.freeze(0, 0);\n            }\n        } else {\n            data.setSelectedCellAttr(type, value);\n            if (type === 'formula' && !data.selector.multiple()) {\n                editorSet.call(this);\n            }\n            sheetReset.call(this);\n        }\n    }\n    function sortFilterChange(ci, order, operator, value) {\n        this.data.setAutoFilter(ci, order, operator, value);\n        sheetReset.call(this);\n    }\n    function sheetInitEvents() {\n        const {selector, overlayerEl, rowResizer, colResizer, verticalScrollbar, horizontalScrollbar, editor, contextMenu, toolbar, modalValidation, sortFilter} = this;\n        overlayerEl.on('mousemove', evt => {\n            overlayerMousemove.call(this, evt);\n        }).on('mousedown', evt => {\n            editor.clear();\n            contextMenu.hide();\n            if (evt.buttons === 2) {\n                if (this.data.xyInSelectedRect(evt.offsetX, evt.offsetY)) {\n                    contextMenu.setPosition(evt.offsetX, evt.offsetY);\n                } else {\n                    overlayerMousedown.call(this, evt);\n                    contextMenu.setPosition(evt.offsetX, evt.offsetY);\n                }\n                evt.stopPropagation();\n            } else if (evt.detail === 2) {\n                editorSet.call(this);\n            } else {\n                overlayerMousedown.call(this, evt);\n            }\n        }).on('mousewheel.stop', evt => {\n            overlayerMousescroll.call(this, evt);\n        }).on('mouseout', evt => {\n            const {offsetX, offsetY} = evt;\n            if (offsetY <= 0)\n                colResizer.hide();\n            if (offsetX <= 0)\n                rowResizer.hide();\n        });\n        selector.inputChange = v => {\n            dataSetCellText.call(this, v, 'input');\n            editorSet.call(this);\n        };\n        m_event.bindTouch(overlayerEl.el, {\n            move: (direction, d) => {\n                overlayerTouch.call(this, direction, d);\n            }\n        });\n        toolbar.change = (type, value) => toolbarChange.call(this, type, value);\n        sortFilter.ok = (ci, order, o, v) => sortFilterChange.call(this, ci, order, o, v);\n        rowResizer.finishedFn = (cRect, distance) => {\n            rowResizerFinished.call(this, cRect, distance);\n        };\n        colResizer.finishedFn = (cRect, distance) => {\n            colResizerFinished.call(this, cRect, distance);\n        };\n        rowResizer.unhideFn = index => {\n            unhideRowsOrCols.call(this, 'row', index);\n        };\n        colResizer.unhideFn = index => {\n            unhideRowsOrCols.call(this, 'col', index);\n        };\n        verticalScrollbar.moveFn = (distance, evt) => {\n            verticalScrollbarMove.call(this, distance, evt);\n        };\n        horizontalScrollbar.moveFn = (distance, evt) => {\n            horizontalScrollbarMove.call(this, distance, evt);\n        };\n        editor.change = (state, itext) => {\n            dataSetCellText.call(this, itext, state);\n        };\n        modalValidation.change = (action, ...args) => {\n            if (action === 'save') {\n                this.data.addValidation(...args);\n            } else {\n                this.data.removeValidation();\n            }\n        };\n        contextMenu.itemClick = type => {\n            if (type === 'validation') {\n                modalValidation.setValue(this.data.getSelectedValidation());\n            } else if (type === 'copy') {\n                copy.call(this);\n            } else if (type === 'cut') {\n                cut.call(this);\n            } else if (type === 'paste') {\n                paste.call(this, 'all');\n            } else if (type === 'paste-value') {\n                paste.call(this, 'text');\n            } else if (type === 'paste-format') {\n                paste.call(this, 'format');\n            } else if (type === 'hide') {\n                hideRowsOrCols.call(this);\n            } else {\n                insertDeleteRowColumn.call(this, type);\n            }\n        };\n        m_event.bind(window, 'resize', () => {\n            this.reload();\n        });\n        m_event.bind(window, 'click', evt => {\n            this.focusing = overlayerEl.contains(evt.target);\n        });\n        m_event.bind(window, 'paste', evt => {\n            paste.call(this, 'all', evt);\n            evt.preventDefault();\n        });\n        m_event.bind(window, 'keydown', evt => {\n            if (!this.focusing)\n                return;\n            const keyCode = evt.keyCode || evt.which;\n            const {key, ctrlKey, shiftKey, metaKey} = evt;\n            if (ctrlKey || metaKey) {\n                switch (keyCode) {\n                case 90:\n                    this.undo();\n                    evt.preventDefault();\n                    break;\n                case 89:\n                    this.redo();\n                    evt.preventDefault();\n                    break;\n                case 67:\n                    copy.call(this);\n                    evt.preventDefault();\n                    break;\n                case 88:\n                    cut.call(this);\n                    evt.preventDefault();\n                    break;\n                case 85:\n                    toolbar.trigger('underline');\n                    evt.preventDefault();\n                    break;\n                case 86:\n                    break;\n                case 37:\n                    selectorMove.call(this, shiftKey, 'row-first');\n                    evt.preventDefault();\n                    break;\n                case 38:\n                    selectorMove.call(this, shiftKey, 'col-first');\n                    evt.preventDefault();\n                    break;\n                case 39:\n                    selectorMove.call(this, shiftKey, 'row-last');\n                    evt.preventDefault();\n                    break;\n                case 40:\n                    selectorMove.call(this, shiftKey, 'col-last');\n                    evt.preventDefault();\n                    break;\n                case 32:\n                    selectorSet.call(this, false, -1, this.data.selector.ci, false);\n                    evt.preventDefault();\n                    break;\n                case 66:\n                    toolbar.trigger('bold');\n                    break;\n                case 73:\n                    toolbar.trigger('italic');\n                    break;\n                default:\n                    break;\n                }\n            } else {\n                switch (keyCode) {\n                case 32:\n                    if (shiftKey) {\n                        selectorSet.call(this, false, this.data.selector.ri, -1, false);\n                    }\n                    break;\n                case 27:\n                    contextMenu.hide();\n                    clearClipboard.call(this);\n                    break;\n                case 37:\n                    selectorMove.call(this, shiftKey, 'left');\n                    evt.preventDefault();\n                    break;\n                case 38:\n                    selectorMove.call(this, shiftKey, 'up');\n                    evt.preventDefault();\n                    break;\n                case 39:\n                    selectorMove.call(this, shiftKey, 'right');\n                    evt.preventDefault();\n                    break;\n                case 40:\n                    selectorMove.call(this, shiftKey, 'down');\n                    evt.preventDefault();\n                    break;\n                case 9:\n                    editor.clear();\n                    selectorMove.call(this, false, shiftKey ? 'left' : 'right');\n                    evt.preventDefault();\n                    break;\n                case 13:\n                    editor.clear();\n                    selectorMove.call(this, false, shiftKey ? 'up' : 'down');\n                    evt.preventDefault();\n                    break;\n                case 8:\n                    insertDeleteRowColumn.call(this, 'delete-cell-text');\n                    evt.preventDefault();\n                    break;\n                default:\n                    break;\n                }\n                if (key === 'Delete') {\n                    insertDeleteRowColumn.call(this, 'delete-cell-text');\n                    evt.preventDefault();\n                } else if (keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || evt.key === '=') {\n                    dataSetCellText.call(this, evt.key, 'input');\n                    editorSet.call(this);\n                } else if (keyCode === 113) {\n                    editorSet.call(this);\n                }\n            }\n        });\n    }\n    \n    class Sheet {\n        constructor(targetEl, data) {\n            this.eventMap = new Map();\n            const {view, showToolbar, showContextmenu} = data.settings;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-sheet`);\n            this.toolbar = new Toolbar(data, view.width, !showToolbar);\n            this.print = new Print(data);\n            targetEl.children(this.toolbar.el, this.el, this.print.el);\n            this.data = data;\n            this.tableEl = m_element.h('canvas', `${ m_config.cssPrefix }-table`);\n            this.rowResizer = new Resizer(false, data.rows.height);\n            this.colResizer = new Resizer(true, data.cols.minWidth);\n            this.verticalScrollbar = new Scrollbar(true);\n            this.horizontalScrollbar = new Scrollbar(false);\n            this.editor = new Editor(m_formula.formulas, () => this.getTableOffset(), data.rows.height);\n            this.modalValidation = new ModalValidation();\n            this.contextMenu = new ContextMenu(() => this.getRect(), !showContextmenu);\n            this.selector = new Selector(data);\n            this.overlayerCEl = m_element.h('div', `${ m_config.cssPrefix }-overlayer-content`).children(this.editor.el, this.selector.el);\n            this.overlayerEl = m_element.h('div', `${ m_config.cssPrefix }-overlayer`).child(this.overlayerCEl);\n            this.sortFilter = new SortFilter();\n            this.el.children(this.tableEl, this.overlayerEl.el, this.rowResizer.el, this.colResizer.el, this.verticalScrollbar.el, this.horizontalScrollbar.el, this.contextMenu.el, this.modalValidation.el, this.sortFilter.el);\n            this.table = new m_table.Table(this.tableEl.el, data);\n            sheetInitEvents.call(this);\n            sheetReset.call(this);\n            selectorSet.call(this, false, 0, 0);\n        }\n        on(eventName, func) {\n            this.eventMap.set(eventName, func);\n            return this;\n        }\n        trigger(eventName, ...args) {\n            const {eventMap} = this;\n            if (eventMap.has(eventName)) {\n                eventMap.get(eventName).call(this, ...args);\n            }\n        }\n        resetData(data) {\n            this.editor.clear();\n            this.data = data;\n            verticalScrollbarSet.call(this);\n            horizontalScrollbarSet.call(this);\n            this.toolbar.resetData(data);\n            this.print.resetData(data);\n            this.selector.resetData(data);\n            this.table.resetData(data);\n        }\n        loadData(data) {\n            this.data.setData(data);\n            sheetReset.call(this);\n            return this;\n        }\n        freeze(ri, ci) {\n            const {data} = this;\n            data.setFreeze(ri, ci);\n            sheetReset.call(this);\n            return this;\n        }\n        undo() {\n            this.data.undo();\n            sheetReset.call(this);\n        }\n        redo() {\n            this.data.redo();\n            sheetReset.call(this);\n        }\n        reload() {\n            sheetReset.call(this);\n            return this;\n        }\n        getRect() {\n            const {data} = this;\n            return {\n                width: data.viewWidth(),\n                height: data.viewHeight()\n            };\n        }\n        getTableOffset() {\n            const {rows, cols} = this.data;\n            const {width, height} = this.getRect();\n            return {\n                width: width - cols.indexWidth,\n                height: height - rows.height,\n                left: cols.indexWidth,\n                top: rows.height\n            };\n        }\n    }\n\n    return Sheet;\n});\ndefine('skylark-xspreadsheet/component/bottombar',[\n    './element',\n    './event',\n    '../config',\n    './icon',\n    './form_input',\n    './dropdown',\n    './message',\n    '../locale/locale'\n], function (m_element, m_event, m_config, Icon, FormInput, Dropdown, m_message, m_locale) {\n    'use strict';\n    class DropdownMore extends Dropdown {\n        constructor(click) {\n            const icon = new Icon('ellipsis');\n            super(icon, 'auto', false, 'top-left');\n            this.contentClick = click;\n        }\n        reset(items) {\n            const eles = items.map((it, i) => m_element.h('div', `${ m_config.cssPrefix }-item`).css('width', '150px').css('font-weight', 'normal').on('click', () => {\n                this.contentClick(i);\n                this.hide();\n            }).child(it));\n            this.setContentChildren(...eles);\n        }\n        setTitle() {\n        }\n    }\n    const menuItems = [{\n            key: 'delete',\n            title: m_locale.tf('contextmenu.deleteSheet')\n        }];\n    function buildMenuItem(item) {\n        return m_element.h('div', `${ m_config.cssPrefix }-item`).child(item.title()).on('click', () => {\n            this.itemClick(item.key);\n            this.hide();\n        });\n    }\n    function buildMenu() {\n        return menuItems.map(it => buildMenuItem.call(this, it));\n    }\n    class ContextMenu {\n        constructor() {\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-contextmenu`).css('width', '160px').children(...buildMenu.call(this)).hide();\n            this.itemClick = () => {\n            };\n        }\n        hide() {\n            const {el} = this;\n            el.hide();\n            m_event.unbindClickoutside(el);\n        }\n        setOffset(offset) {\n            const {el} = this;\n            el.offset(offset);\n            el.show();\n            m_event.bindClickoutside(el);\n        }\n    }\n    return class Bottombar {\n        constructor(addFunc = () => {\n        }, swapFunc = () => {\n        }, deleteFunc = () => {\n        }, updateFunc = () => {\n        }) {\n            this.swapFunc = swapFunc;\n            this.updateFunc = updateFunc;\n            this.dataNames = [];\n            this.activeEl = null;\n            this.deleteEl = null;\n            this.items = [];\n            this.moreEl = new DropdownMore(i => {\n                this.clickSwap2(this.items[i]);\n            });\n            this.contextMenu = new ContextMenu();\n            this.contextMenu.itemClick = deleteFunc;\n            this.el = m_element.h('div', `${ m_config.cssPrefix }-bottombar`).children(this.contextMenu.el, this.menuEl = m_element.h('ul', `${ m_config.cssPrefix }-menu`).child(m_element.h('li', '').children(new Icon('add').on('click', () => {\n                if (this.dataNames.length < 10) {\n                    addFunc();\n                } else {\n                    m_message.xtoast('tip', 'it less than or equal to 10');\n                }\n            }), m_element.h('span', '').child(this.moreEl))));\n        }\n        addItem(name, active) {\n            this.dataNames.push(name);\n            const item = m_element.h('li', active ? 'active' : '').child(name);\n            item.on('click', () => {\n                this.clickSwap2(item);\n            }).on('contextmenu', evt => {\n                const {offsetLeft, offsetHeight} = evt.target;\n                this.contextMenu.setOffset({\n                    left: offsetLeft,\n                    bottom: offsetHeight + 1\n                });\n                this.deleteEl = item;\n            }).on('dblclick', () => {\n                const v = item.html();\n                const input = new FormInput('auto', '');\n                input.val(v);\n                input.input.on('blur', ({target}) => {\n                    const {value} = target;\n                    const nindex = this.dataNames.findIndex(it => it === v);\n                    this.renameItem(nindex, value);\n                });\n                item.html('').child(input.el);\n                input.focus();\n            });\n            if (active) {\n                this.clickSwap(item);\n            }\n            this.items.push(item);\n            this.menuEl.child(item);\n            this.moreEl.reset(this.dataNames);\n        }\n        renameItem(index, value) {\n            this.dataNames.splice(index, 1, value);\n            this.moreEl.reset(this.dataNames);\n            this.items[index].html('').child(value);\n            this.updateFunc(index, value);\n        }\n        clear() {\n            this.items.forEach(it => {\n                this.menuEl.removeChild(it.el);\n            });\n            this.items = [];\n            this.dataNames = [];\n            this.moreEl.reset(this.dataNames);\n        }\n        deleteItem() {\n            const {activeEl, deleteEl} = this;\n            if (this.items.length > 1) {\n                const index = this.items.findIndex(it => it === deleteEl);\n                this.items.splice(index, 1);\n                this.dataNames.splice(index, 1);\n                this.menuEl.removeChild(deleteEl.el);\n                this.moreEl.reset(this.dataNames);\n                if (activeEl === deleteEl) {\n                    const [f] = this.items;\n                    this.activeEl = f;\n                    this.activeEl.toggle();\n                    return [\n                        index,\n                        0\n                    ];\n                }\n                return [\n                    index,\n                    -1\n                ];\n            }\n            return [-1];\n        }\n        clickSwap2(item) {\n            const index = this.items.findIndex(it => it === item);\n            this.clickSwap(item);\n            this.activeEl.toggle();\n            this.swapFunc(index);\n        }\n        clickSwap(item) {\n            if (this.activeEl !== null) {\n                this.activeEl.toggle();\n            }\n            this.activeEl = item;\n        }\n    };\n});\ndefine('skylark-xspreadsheet/spreadsheet',[\n    './component/element',\n    './core/data_proxy',\n    './component/sheet',\n    './component/bottombar',\n    './config',\n    './locale/locale'\n//    './index.less'\n], function (m_element, DataProxy, Sheet, Bottombar, m_config, m_locale) {\n    'use strict';\n    class Spreadsheet {\n        constructor(selectors, options = {}) {\n            let targetEl = selectors;\n            this.options = options;\n            this.sheetIndex = 1;\n            this.datas = [];\n            if (typeof selectors === 'string') {\n                targetEl = document.querySelector(selectors);\n            }\n            this.bottombar = new Bottombar(() => {\n                const d = this.addSheet();\n                this.sheet.resetData(d);\n            }, index => {\n                const d = this.datas[index];\n                this.sheet.resetData(d);\n            }, () => {\n                this.deleteSheet();\n            }, (index, value) => {\n                this.datas[index].name = value;\n            });\n            this.data = this.addSheet();\n            const rootEl = m_element.h('div', `${ m_config.cssPrefix }`).on('contextmenu', evt => evt.preventDefault());\n            targetEl.appendChild(rootEl.el);\n            this.sheet = new Sheet(rootEl, this.data);\n            rootEl.child(this.bottombar.el);\n        }\n        addSheet(name, active = true) {\n            const n = name || `sheet${ this.sheetIndex }`;\n            const d = new DataProxy(n, this.options);\n            d.change = (...args) => {\n                this.sheet.trigger('change', ...args);\n            };\n            this.datas.push(d);\n            this.bottombar.addItem(n, active);\n            this.sheetIndex += 1;\n            return d;\n        }\n        deleteSheet() {\n            const [oldIndex, nindex] = this.bottombar.deleteItem();\n            if (oldIndex >= 0) {\n                this.datas.splice(oldIndex, 1);\n                if (nindex >= 0)\n                    this.sheet.resetData(this.datas[nindex]);\n            }\n        }\n        loadData(data) {\n            const ds = Array.isArray(data) ? data : [data];\n            this.bottombar.clear();\n            this.datas = [];\n            if (ds.length > 0) {\n                for (let i = 0; i < ds.length; i += 1) {\n                    const it = ds[i];\n                    const nd = this.addSheet(it.name, i === 0);\n                    nd.setData(it);\n                    if (i === 0) {\n                        this.sheet.resetData(nd);\n                    }\n                }\n            }\n            return this;\n        }\n        getData() {\n            return this.datas.map(it => it.getData());\n        }\n        cellText(ri, ci, text, sheetIndex = 0) {\n            this.datas[sheetIndex].setCellText(ri, ci, text, 'finished');\n            return this;\n        }\n        cell(ri, ci, sheetIndex = 0) {\n            return this.datas[sheetIndex].getCell(ri, ci);\n        }\n        cellStyle(ri, ci, sheetIndex = 0) {\n            return this.datas[sheetIndex].getCellStyle(ri, ci);\n        }\n        reRender() {\n            this.sheet.table.render();\n            return this;\n        }\n        on(eventName, func) {\n            this.sheet.on(eventName, func);\n            return this;\n        }\n        validate() {\n            const {validations} = this.data;\n            return validations.errors.size <= 0;\n        }\n        change(cb) {\n            this.sheet.on('change', cb);\n            return this;\n        }\n        static locale(lang, message) {\n            m_locale.locale(lang, message);\n        }\n    }\n\n    return Spreadsheet;\n\n});\ndefine('skylark-xspreadsheet/main',[\r\n    \"skylark-langx-ns\",\r\n    \"./spreadsheet\"\r\n],function(skylark,Spreadsheet){\r\n    const spreadsheet = (el, options = {}) => new Spreadsheet(el, options);\r\n\r\n\treturn skylark.attach(\"intg.xspreadsheet\",{\r\n\t\tSpreadsheet,\r\n\t\tcreate : spreadsheet\r\n\t});\r\n});\ndefine('skylark-xspreadsheet', ['skylark-xspreadsheet/main'], function (main) { return main; });\n\n"]}